{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"File Archive","text":""},{"location":"design/sequence_diagrams/backup.html","title":"Backups","text":"<p>The prerequisites are:</p> <ol> <li>Encrypt Config has been populated</li> <li>File Share for storing files has been created.</li> </ol> <p>The sequence diagram for the happy-path life cycle of a archive job is presented below:</p> <pre><code>sequenceDiagram\n  autonumber\n  Control-M-&gt;&gt;Archive End Point: start\n  Archive End Point-&gt;&gt;Encrypt Config: fetch config info\n  Encrypt Config-&gt;&gt;Archive End Point: return config info\n  Archive End Point-&gt;&gt;Archive Service: start\n  Archive Service-&gt;&gt;File Share: mount file share\n  File Share-&gt;&gt;Archive Service: mounted\n  Archive Service-&gt;&gt;File Share: create intermediate directory\n  File Share-&gt;&gt;Archive Service: directory created\n  Archive Service-&gt;&gt;Directory: get list of files\n  Directory-&gt;&gt;Archive Service: return list of files\n  loop Each File\n    Archive Service-&gt;&gt;cp: copy file\n    cp-&gt;&gt;Archive Service: file copied\n    Archive Service-&gt;&gt;gpg: is public installed?\n    gpg-&gt;&gt;Archive Service: no\n    Archive Service-&gt;&gt;gpg: install public key\n    gpg-&gt;&gt;Archive Service: key installed\n    Archive Service-&gt;&gt;gpg: encrypt file\n    gpg-&gt;&gt;Archive Service: file encrypted\n    Archive Service-&gt;&gt;File Share: move to long-term storage\n    File Share-&gt;&gt;Archive Service: encrypted file in long-term storage\n    Archive Service-&gt;&gt;gpg: delete public key\n    gpg-&gt;&gt;Archive Service: public key deleted\n  end\n  Archive Service-&gt;&gt;File Share: remove intermediate directory\n  File Share-&gt;&gt;Archive Service: intermediate directory removed\n  intermediate Service-&gt;&gt;File Share: unmount file share\n  File Share-&gt;&gt;Archive Service: file share unmounted\n  Archive Service-&gt;&gt;Archive End Point: report any failures\n  Archive End Point-&gt;&gt;Control-M: report any failures\n  Control-M-&gt;&gt;Alerting: report any failures</code></pre>"},{"location":"design/sequence_diagrams/restore.html","title":"Restore","text":"<p>The prerequisites are:</p> <ol> <li>Encrypt Config has been populated</li> <li>Decrypt Config has been populated</li> <li>File Share for storing backups has been created.</li> <li>Archive file to be restored exists.</li> </ol> <p>The sequence diagram for the happy-path life cycle of a restore job is presented below:</p> <pre><code>sequenceDiagram\n  autonumber\n  Authorized Person-&gt;&gt;Restore End Point: start\n  Restore End Point-&gt;&gt;Encrypt Config: fetch config info\n  Encrypt Config-&gt;&gt;Restore End Point: return config info\n  Restore End Point-&gt;&gt;Backup Config: fetch config info\n  Backup Config-&gt;&gt;Restore End Point: return config info\n  Restore End Point-&gt;&gt;Restore Service: start\n  Restore Service-&gt;&gt;File Share: mount file share\n  File Share-&gt;&gt;Restore Service: mounted\n\n  Restore Service-&gt;&gt;File Share: requested archive file exists?\n  File Share-&gt;&gt;Restore Service: yes\n  Restore Service-&gt;&gt;gpg: private key installed?\n  gpg-&gt;&gt;Restore Service: no\n  Restore Service-&gt;&gt;gpg: install private key\n  gpg-&gt;&gt;Restore Service: private key installed\n  Restore Service-&gt;&gt;File Share: create restore directory\n  File Share-&gt;&gt;Restore Service: directory created\n  Restore Service-&gt;&gt;File Share: copy encrypted archive to restore directory\n  File Share-&gt;&gt;Restore Service: file copied\n  Restore Service-&gt;&gt;gpg: decrypt file\n  gpg-&gt;&gt;Restore Service: file decrypted\n\n  Restore Service-&gt;&gt;File Share: unmount file share\n  File Share-&gt;&gt;Restore Service: file share unmounted\n  Restore Service-&gt;&gt;Restore End Point: report any failures\n  Restore End Point-&gt;&gt;Authenticated Person: report any failures</code></pre>"},{"location":"framework/command_line_construction.html","title":"Command Line Construction","text":"<p>Automating interactions with command line tools is never trivial--especially if you need to parameterized the commands.  Properly quoting and escaping unknown values that are going to be provided as parameters to the command line tool is a beast.  Fortunately, Python provides a way of invoking a process as though it was a command line interaction that does all of the heavy lifting for us.  We just have to provide a list of strings that would have been the space-delimited elements of the command line had we entered it by hand.</p> <p>However, there is one other requirement we want fulfilled, which is the ability to log the command that was submitted.  Having this information available when something doesn't behave as expected is invaluable.</p> <p>But we cannot simply dump the raw strings to the log files.  The command line interactions sometimes require providing secret information that should not appear in a log file.  So what the framework provides is a way of constructing a list of strings that can be used for invoking a command line operation, but will not display secret information if just rendering the results as a string.</p> <p>Let's consider one of the more complicated command line operations that needs to be performed--mounting a file share.</p> <pre><code>sudo -S mount -t cifs //some.file.share/client-name /backups/client-name -o username=account-name,password=account-key,serverino,nosharesock,actimeo=30,mfsymlinks,uid=1000,gid=1000\n</code></pre> <p>Embedded in the middle of the \"-o\" section is \"password=account-key\", and \"account-key\" is not something that should ever appear in a log file.</p> <p>The implementation of mounting the file share looks like:</p> <pre><code>    @classmethod\n    def mount_storage(\n        cls,\n        *,\n        unc: str,\n        mount_path: str,\n        account_name: str,\n        account_key: SecretStr,\n        user_id: str,\n        actimeo: int = 30,\n    ):\n        \"\"\"\n        Mount a file share on a storage account.\n\n        raises:\n            Exception: If exit code is not zero.\n        \"\"\"\n        command = SpaceDelimited(\n            line=(\n                \"sudo\",\n                \"-S\",\n                \"mount\",\n                \"-t\",\n                \"cifs\",\n                unc,\n                mount_path,\n                \"-o\",\n                CommaDelimited(\n                    line=(\n                        EqualDelimited(left=\"username\", right=account_name),\n                        EqualDelimited(left=\"password\", right=account_key),\n                        \"serverino\",\n                        \"nosharesock\",\n                        EqualDelimited(left=\"actimeo\", right=str(actimeo)),\n                        \"mfsymlinks\",\n                        EqualDelimited(left=\"uid\", right=user_id),\n                        EqualDelimited(left=\"gid\", right=user_id),\n                    )\n                ),\n            )\n        )\n\n        cls.execute(command=command)\n</code></pre> <p>What the framework provides is a way to describe the command line in terms of how the items are delimited.  The reason for this convoluted way for describing the command line is it allows us to safely log what the command was.  In the parameters for the method, account_key has a type of SecretStr.  The behavior of a SecretStr is to render a masked output when used as a string.  In order to get the true value, you have to call the get_secret_value() method of the SecretStr.</p> <p>The SpaceDelimited(..., CommaDelimited(..., EqualDelimited(left, right))) construct allows us to process the SecretStr values appropriately at the level in which they occur.  The logged output of the above construct looks like:</p> <pre><code>sudo -S mount -t cifs //p21d1290d50b001.file.core.windows.net/test-client-3 /backups/test-client-3 -o username=p21d1290d50b001,password=**********,serverino,nosharesock,actimeo=30,mfsymlinks,uid=1000,gid=1000\n</code></pre> <p>If you scroll to the right in the entry above, you will see that the password value is appropriately masked.</p> <p>But when used to submit the operation to the OS, SpaceDelimited will unmask the SecretStr values.<sup>1</sup></p> <p>The usage of the full convolution of describing the command line is only necessary when the value is a SecretStr.  In the example above, only the usage of account_key needed to be wrapped in EqualDelimited.  The rest could have been implemeted as templated strings: e.g., f\"username={account_name}\" (EqualDelimited was used for the sake of consistency).</p> <p>Let's take a look at the definitions of the SpaceDelimited chain to see how everything fits together.</p> <pre><code># standard library imports\nfrom typing import Sequence\n\n# standard library imports\nfrom pydantic import SecretStr\n\n# local imports\nfrom .comma_delimited import CommaDelimited\nfrom .equal_delimited import EqualDelimited\n\n\nclass SpaceDelimited:\n    \"\"\"\n    Represents a sequence of space delimited strings.  When used as a normal string, secret vlaues\n    will be masked.\n    \"\"\"\n\n    def __init__(\n        self, *, line: Sequence[str | SecretStr | CommaDelimited | EqualDelimited]\n    ):\n        self._line = line\n\n    def get_secret_value(self) -&gt; list[str]:\n        \"\"\"\n        Renders space delimited items as a list rather than a single string.  Secret values will be unmasked.\n        \"\"\"\n        return [\n            (\n                item.get_secret_value()\n                if isinstance(item, CommaDelimited)\n                or isinstance(item, EqualDelimited)\n                or isinstance(item, SecretStr)\n                else item\n            )\n            for item in self._line\n        ]\n\n    def __repr__(self) -&gt; str:\n        return str(self)\n\n    def __str__(self) -&gt; str:\n        return \" \".join([str(item) for item in self._line])\n</code></pre> <p>Starting with the signature of the constructor:</p> <pre><code>    def __init__(\n        self, *, line: Sequence[str | SecretStr | CommaDelimited | EqualDelimited]\n    ):\n</code></pre> <ul> <li>self is the first paramter of every instance method in Python.  It provides the class context for the instance of the object.</li> <li>\"*\" means that all of the parameters following the \"*\" must be provided as named parameters.  Usage of named parameters rather than positional parameters facilitates inheriting someone else's code.</li> <li>line is the definition of the command line.<ul> <li>Sequence means the constructor is expecting either a list or a tuple of items.</li> <li>The pipe delimited section means the list can contain any mix of strings (str), SecretStr, CommaDelimited, or EqualDelimited objects.  The technical term for this is \"discriminated union\", but in terms of reading the definition, traditionally in programming languages \"|\" means \"or\", so the usage of \"|\" in a type signature means \"type or type or type...\".  It's a way of letting the static type checker know the types the implementation can handle.</li> </ul> </li> </ul> <p>The two methods at the end are overriding built-in functionality for classes.</p> <pre><code>    def __repr__(self) -&gt; str:\n        return str(self)\n\n    def __str__(self) -&gt; str:\n        return \" \".join([str(item) for item in self._line])\n</code></pre> <p>__repr__ means \"reproduce\" and controls the representation of the object if it used in a print statement.  __str__ means string, and it controls the representation of object if it used as a string.  What we are doing here is making sure all of the contents of the line sequence are rendered as a string, which for SecretStr will come out masked.  CommaDelimited and EqualDelimited have similar overrides that unwind the nested aspects of a SpaceDelimited object into a single string.</p> <p>The \" \".join([...]) is the preferred idiom for concatenating strings in Python.  \"join\" is a method defined for string objects that says \"place this string between every entry in the provided list of strings\".  In this case, we wanted a space-delimited rendering of SpaceDelimited.  Python supports using the \"+\" operator for concatenation, but in general, usage of \"join\" is easier to maintain and has more predictable run-time performance.</p> <p><pre><code>&gt; hello_world = \"Hello \" + \"world\"\n&gt; print(hello_world)\nHello world\n&gt; hello_world = \" \".join([\"Hello\", \"world\"])\n&gt; print(hello_world)\nHello world\n&gt; hello_world = \"\".join([\"Hello\", \"world\"])\nHelloworld\n</code></pre> Both approaches accomplish the same thing, but using \"join\" is much more flexible and maintainable (the last example shows how to join strings without a delimiter between them).</p> <p>The guts of the functionality are found in the get_secret_value method.</p> <pre><code>    def get_secret_value(self) -&gt; list[str]:\n        \"\"\"\n        Renders space delimited items as a list rather than a single string.  Secret values will be unmasked.\n        \"\"\"\n        return [\n            (\n                item.get_secret_value()\n                if isinstance(item, CommaDelimited)\n                or isinstance(item, EqualDelimited)\n                or isinstance(item, SecretStr)\n                else item\n            )\n            for item in self._line\n        ]\n</code></pre> <p>The name \"get_secret_value\" was selected because that is the name used to retrieve the unmasked value from a SecretStr.  Using that name allowed us to use the same method call for CommaDelimited, EqualDelimited, and SecretStr.  Per the constructor signature, the only other kind of object that could appear in a SpaceDelimited line is a string, which can be rendered as-is.</p> <p>The construct of the return value is know as a list-comprehension, and reading it starts with the \"for\" statement at the bottom, which says \"for each value in the sequence create an entry in a new list of items\".  The \"create an entry\" is the part at the top of the construct.  The parenthesis are there for readability.  They aren't a necessary part of the syntax, but the conditional part of \"create an entry\" is more complicated than what you would typically see in a list-comprehension.</p> <p>A more typical use case would be creating a list of only name values from a list of records you retrieved from a database.  An in-line conditional can appear on either side of the for statement. When on the left side of the for statement, you must provide an else clause to provide a value for the entry.  When on the right side of the for statement, you cannot provide an else clause, because it's serving as a filter to exclude some entries:</p> <pre><code>&gt; records = [{\"name\": \"Bob\", \"id\": 0, \"phone_number\": \"xxx-xxxx\"}, {\"name\": \"Judy\", \"id\": 1, \"phone_number\": \"yyy-yyyy\"}]\n&gt; names = [record[\"name\"] for record in records]\n&gt; print(names)\n[\"Bob\", \"Judy\"]\n&gt; left_iffed = [record[\"name\"] if record[\"id\"] == 0 else \"Who?\" for record in records]\n&gt; print(left_iffed)\n[\"Bob\", \"Who?\"]\n&gt; right_iffed = [record[\"name\"] for record in records if record[\"id\"] == 0]\n&gt; print(right_iffed)\n[\"Bob\"]\n</code></pre> <p>Anyway, getting back to SpaceDelimited, if the item in the line sequence is an instance of a CommaDelimited, EqualDelimited, or SecretStr class, the entry will be created by calling the item's get_secret_value method.  For SecretStr, that's a straight-forward process--it's just going to return the unmasked value.  For CommaDelimited and EqualDelimited, things are a bit more complicated, but we'll get to those in a moment.  If it isn't one of those three types of objects, it has to be a string, so we just use the string as the entry in the list, which is what the else clause does.</p> <p>Moving on to CommaDelimited:</p> <pre><code># standard library imports\nfrom typing import Sequence\n\n# third party imports\nfrom pydantic import SecretStr\n\n# local imports\nfrom .equal_delimited import EqualDelimited\n\n\nclass CommaDelimited:\n    \"\"\"\n    Represents a sequence of strings that are rendered as comma delimited.  When used as a normal string,\n    the secret values will be masked.\n    \"\"\"\n\n    def __init__(self, *, line: Sequence[str | SecretStr | EqualDelimited]):\n        self._line = line\n\n    def get_secret_value(self) -&gt; str:\n        \"\"\"\n        Performs the rendering including the unmasking of secret values.\n        \"\"\"\n        return \",\".join(\n            [\n                (\n                    item.get_secret_value()\n                    if isinstance(item, EqualDelimited) or isinstance(item, SecretStr)\n                    else item\n                )\n                for item in self._line\n            ]\n        )\n\n    def __repr__(self) -&gt; str:\n        return str(self)\n\n    def __str__(self) -&gt; str:\n        return \",\".join([str(item) for item in self._line])\n</code></pre> <p>The difference in the line signature is that CommaDelimited can only accept string, SecretStr, or EqualDelimited objects.</p> <p>The __str__ is comma-delimited rather than space-delimited but otherwise works the same (SecretStr will be masked).</p> <p>The get_secret_method returns a comma-delimited string instead of a list, because when it is called by SpaceDelimited's get_secret_value, we want it to be part of a non-nested list of strings.  Here, the list-comprehension only has to conditionally react to EqualDelimited and SecretStr.  Any other objects in the CommaDelimited line will be strings.</p> <p>And, finally, we have EqualDelimited:</p> <pre><code># third party imports\nfrom pydantic import SecretStr\n\n\nclass EqualDelimited:\n    \"\"\"\n    Represents a pair of strings that are delimited using an equals sign.  When used as a normal string,\n    secret values will be masked.\n    \"\"\"\n\n    def __init__(self, *, left: str, right: str | SecretStr):\n        self._left = left\n        self._right = right\n\n    def get_secret_value(self) -&gt; str:\n        \"\"\"\n        Renders an equals delimited string with secret values unmasked.\n        \"\"\"\n        return \"=\".join(\n            (\n                self._left,\n                (\n                    self._right.get_secret_value()\n                    if isinstance(self._right, SecretStr)\n                    else self._right\n                ),\n            )\n        )\n\n    def __repr__(self) -&gt; str:\n        return str(self)\n\n    def __str__(self):\n        return \"=\".join((self._left, str(self._right)))\n</code></pre> <p>In this case, \"=\" is an in-fix operator, so the signature only accepts a \"to the left side of =\", which can only be a string, and \"to the right side of =\", which can be either a string or a SecretStr.</p> <p>__str__ is simply placing \"=\" between the parameter left and the parameter right.  Again, rendering is masked for SecretStr values.</p> <p>The get_secret_value method doesn't have a list-comprehension, because there are only two values.  Instead, it is placing \"=\" between left, which is a string, and right which will be unmasked if it is a SecretStr or rendered as-is if it is a string.</p> <ol> <li> <p>Strings that are intended to hold secret values should always be wrapped in something that provides default masking.  Doing so prevents accidental leakage of secrets (somebody decides to throw a print statement into the code).  It also lets people who inherit your code know what needs to be protected.\u00a0\u21a9</p> </li> </ol>"},{"location":"framework/constants.html","title":"Constants","text":"<p>One egregiouly bad practice in coding is the usage of \"magic\" values:  hard-coded strings and numbers.  These values should be provided by a config file in cases where the actual values are different in different environments, or constants, where the values are known and not expected to change.</p> <p>Usage of \"magic\" values in the code is another source of copy-and-pasting functionality, where things that are supposed to be the same across the code base can drift in the implementation.</p> <p>There should always be a single-source-of-truth for known values, and the definitions of known values should have a well known location as to where they are going to live in the code base.</p> <p>In this framework, that location is the constant package.</p> <p>So, let's take a look a relatively simple set of constants.</p> <pre><code>from enum import unique, Enum\n\n\n@unique\nclass BackupConfig(Enum):\n    \"\"\"\n    Names of secrets in the Backup Config Key Vault.\n    \"\"\"\n\n    CLIENT_NAME = \"client-name\"\n    \"\"\"The client's system-wide identifier. Used to validate backup requests.\"\"\"\n\n    POSTGRESQL_HOST = \"postgresql-host\"\n    \"\"\"The connection host for the PostgreSQL instance.\"\"\"\n\n    POSTGRESQL_PORT = \"postgresql-port\"\n    \"\"\"The connection port for the PostgreSQL instance.\"\"\"\n\n    POSTGRESQL_SERVICE_PRINCIPAL_ID = \"postgresql-service-principal-id\"\n    \"\"\"The application id of the service principal user used to perform the backups.\"\"\"\n\n    POSTGRESQL_SECRET = \"postgresql-secret\"\n    \"\"\"The secret used to get an authentication token for PostgreSQL from Entra Id.\"\"\"\n\n    KEY_NAME = \"key-name\"\n    \"\"\"The name of the key to use for encryption.\"\"\"\n\n    PUBLIC_KEY = \"public-key\"\n    \"\"\"The base64 definition of the public key to use for encryption.\"\"\"\n\n    EXCLUDE_DATABASES = \"exclude-databases\"\n    \"\"\"A comma delimited list of databases to exclude from backing up (*None* means nothing to exclude).\"\"\"\n\n    STORAGE_UNC = \"storage-unc\"\n    \"\"\"The remote mount path for the file share (url of the storage area excluding \"https:\"--keep the \"//\"). Used to mount file share.\"\"\"\n\n    STORAGE_NAME = \"storage-name\"\n    \"\"\"The Azure name of the storage account. Used to mount file share\"\"\"\n\n    STORAGE_KEY = \"storage-key\"\n    \"\"\"The key to authenticate with the storage account. Used to mount file share.\"\"\"\n\n    END_OF_MONTH_RETENTION = \"end-of-month-retention\"\n    \"\"\"The number of days to retain the end-of-month backups.\"\"\"\n\n    END_OF_YEAR_RETENTION = \"end-of-year-retention\"\n    \"\"\"The number of days to retain the end-of-year backups.\"\"\"\n</code></pre> <p>This contains the names to use when fetching the secret values from the Backup Config key vault.  Some kind of translation between the names in Python and the names in Key Vault is needed, because hyphens are not allowed in Python names, and underscores are not allowed in Key Vault.</p> <p>We're using Enum objects to represent constants.  They are immutable (can't be changed by the code), and they fit the naming convention very well.  In pretty much all languages, the naming convention for constants is ALL_CAPS.</p> <p>Looking at an example of where they are used:</p> <pre><code># standard library imports\nfrom datetime import datetime, UTC\n\n# third party imports\nfrom azure.keyvault.secrets import SecretClient\nfrom pydantic import SecretStr\n\n# application imports\nfrom long_term_storage.constant import backup_config\nfrom state_machine import AbstractRepository, Logger\n\n\nclass BackupConfig(AbstractRepository):\n    \"\"\"\n    Provides access to the client specific configurational information stored in Azure Key Vault.\n    \"\"\"\n\n    def __init__(self, logger: Logger, client: SecretClient):\n        self.logger = logger\n        self.client = client\n\n    def execute(self, *, secret_name: str) -&gt; str:\n        start_time = datetime.now(UTC)\n        self.logger.debug(\n            f\"  key vault secret {secret_name} from {self.client.vault_url} - Started\"\n        )\n\n        value = self.client.get_secret(secret_name).value\n        if value is None:\n            raise Exception(f\"{secret_name} not defined in key vault\")\n\n        end_time = datetime.now(UTC)\n        self.logger.debug(\n            f\"  key vault secret {secret_name} from {self.client.vault_url} - Completed - Runtime: {end_time - start_time}\"\n        )\n\n        return value\n\n    @property\n    def client_name(self) -&gt; str:\n        \"\"\"The client name.\"\"\"\n        return self.execute(secret_name=backup_config.BackupConfig.CLIENT_NAME.value)\n\n    @property\n    def postgresql_host(self) -&gt; str:\n        \"\"\"The PostgreSQL connection host.\"\"\"\n        return self.execute(\n            secret_name=backup_config.BackupConfig.POSTGRESQL_HOST.value\n        )\n\n    @property\n    def postgresql_port(self) -&gt; int:\n        \"\"\"The PostgreSQL connection port.\"\"\"\n        return int(\n            self.execute(\n                secret_name=backup_config.BackupConfig.POSTGRESQL_PORT.value,\n            )\n        )\n\n    @property\n    def postgresql_service_principal_id(self) -&gt; str:\n        \"\"\"The object id of the PostgreSQL service principal to perform the backups.\"\"\"\n        return self.execute(\n            secret_name=backup_config.BackupConfig.POSTGRESQL_SERVICE_PRINCIPAL_ID.value\n        )\n\n    @property\n    def postgresql_secret(self) -&gt; SecretStr:\n        \"\"\"The Service Principal secret to use for retrieving a token to connect to the PostgreSQL instance.\"\"\"\n        return SecretStr(\n            secret_value=self.execute(\n                secret_name=backup_config.BackupConfig.POSTGRESQL_SECRET.value,\n            )\n        )\n\n    @property\n    def key_name(self) -&gt; str:\n        \"\"\"The name of the encryption key.\"\"\"\n        return self.execute(secret_name=backup_config.BackupConfig.KEY_NAME.value)\n\n    @property\n    def public_key(self) -&gt; str:\n        \"\"\"A base64 definition of the encryption key.\"\"\"\n        return self.execute(secret_name=backup_config.BackupConfig.PUBLIC_KEY.value)\n\n    @property\n    def exclude_databases(self) -&gt; list[str]:\n        \"\"\"A comma delimited list of databases to exclude from backup.\"\"\"\n        exclude = self.execute(\n            secret_name=backup_config.BackupConfig.EXCLUDE_DATABASES.value,\n        )\n        if exclude:\n            return [database.strip() for database in exclude.split(\",\")]\n        return []\n\n    @property\n    def storage_unc(self) -&gt; str:\n        \"\"\"The remote mount path for the storage account (url of the storage account excluding \"https:\"--keep the \"//\").\"\"\"\n        return self.execute(secret_name=backup_config.BackupConfig.STORAGE_UNC.value)\n\n    @property\n    def storage_name(self) -&gt; str:\n        \"\"\"The Azure name of the storage account.\"\"\"\n        return self.execute(secret_name=backup_config.BackupConfig.STORAGE_NAME.value)\n\n    @property\n    def storage_key(self) -&gt; SecretStr:\n        \"\"\"The connection key for the storage account.\"\"\"\n        return SecretStr(\n            secret_value=self.execute(\n                secret_name=backup_config.BackupConfig.STORAGE_KEY.value\n            )\n        )\n\n    @property\n    def end_of_month_retention(self) -&gt; int:\n        \"\"\"The number of days to retain the end-of-month backups.\"\"\"\n        return int(\n            self.execute(\n                secret_name=backup_config.BackupConfig.END_OF_MONTH_RETENTION.value,\n            )\n        )\n\n    @property\n    def end_of_year_retention(self) -&gt; int:\n        \"\"\"The number of days to retain the end-of-year backups.\"\"\"\n        return int(\n            self.execute(\n                secret_name=backup_config.BackupConfig.END_OF_YEAR_RETENTION.value,\n            )\n        )\n</code></pre> <p>This is the Repository we use to fetch secrets from a key vault.</p> <p>In line 42, we could have implemented</p> <pre><code>return self.execute(secret_name=client_config.ClientConfig.CLIENT_NAME.value)\n</code></pre> <p>as</p> <pre><code>return self.execute(secret_name=\"client-name\")\n</code></pre> <p>However, we don't do that, because \"client-name\" is a \"magic\" value, and, in principal, magic values are bad.  If we needed to use the value of \"client-name\" somewhere else in the code base, we would have no way of determining it was defined the same way in both places, or even determining that it should be the same thing in both places.</p>"},{"location":"framework/dependency_injection.html","title":"Dependency Injection","text":"<p>When one class depends on functionality provided by another class, that's known as a \"dependency\".</p> <p>Dependency Injection<sup>1</sup> is a way of organizing code such that dependencies between classes are not hard-coded.  The reason for doing this is there are situations where you want the code to behave differently in different runtime settings, and you need a way of changing how the methods behave without changing how the methods are defined.</p> <p>Now for the complicating factor.  Not all dependencies between classes should necesarrily be managed using dependency injection.  The purpose of dependency injection is to increase reliability and maintainability of the code base.  However, if you adopt a blanket \"all dependencies will be injected\" rule, your code base will quickly devolve into unreadability, which will totally destroy the reliability and maintainability you were hoping to achieve.</p> <p>Within this framework, functionality that relies on systems that are external to the application (Repositories) will be accessed using dependency injection.  If it is functionality that can fail for reasons that are outside the control of the application's code, it should probably be accessed using dependency injection.</p> <p>Far and away, the biggest use case for dependency injection is unit testing.  The \"unit\" in unit testing is a single class.  We don't want a unit test to also test all of the class's dependency classes--especially if one of those classes is doing something like \"delete database\".  The functionality in the dependency classes will be tested with their own unit tests.</p> <p>To allow us to do this, we provide a mechanism that allows classes to fetch the functionality they need from other classes, but is also convenient for instructing the class to fetch the functionality from a different place.</p> <p>In this framework, we are using dependency mapping classes.  They are data classes where the properties of the class are methods to be called.</p> <p>Looking at an example:</p> <pre><code># repository imports\nfrom long_term_storage.repository.file_manager import FileManager\nfrom long_term_storage.repository.gpg import Gpg\nfrom long_term_storage.repository.shell import PgDump, Tar\n\n# application imports\nfrom state_machine import BaseDependency\n\n\nclass DependencyBackupAndEncrypt(BaseDependency):\n    \"\"\"\n    Repository dependencies for MachineBackupAndEncrypt.\n    \"\"\"\n\n    create_intermediate_directory = FileManager.make_dir_if_not_exists\n    remove_intermediate_directory = FileManager.remove_directory_if_exists\n    create_pg_dump_directory = FileManager.make_dir_if_not_exists\n    remove_pg_dump_directory = FileManager.remove_directory_if_exists\n    backup_schema = PgDump.dump_schema\n    remove_schema_file = FileManager.remove_file_if_exists\n    backup_data = PgDump.dump_data\n    remove_data_file = FileManager.remove_file_if_exists\n    compress = Tar.cjf_with_removal\n    remove_tarball = FileManager.remove_file_if_exists\n    encrypt = Gpg.encrypt\n    remove_encrypted_backup = FileManager.remove_file_if_exists\n    create_storage_directory = FileManager.make_dir_if_not_exists\n    move_backup = FileManager.move\n</code></pre> <p>This dependency mapper is used by the backup-and-encrypt state-machine to access functionality that resides in the Repository layer.</p> <p>The pattern is:</p> <ul> <li>Import the Repositories the Service needs.</li> <li>For each node in the state-machine, create a property named after the node and assign it the Repository method the node needs to call.</li> </ul> <p>Dependency classes all inherit from BaseDependency.</p> <pre><code># standard library import\nfrom dataclasses import dataclass\nfrom typing import Any\n\n# local imports\nfrom .abstract_repository import AbstractRepository\nfrom .config import Config\nfrom .logger import Logger\n\n\n@dataclass\nclass BaseDependency:\n    \"\"\"\n    Base class for representing repository dependencies used by machines.\n    \"\"\"\n\n    logger: Logger\n    \"\"\"Access to the logger.\"\"\"\n\n    def __getattribute__(self, name: str) -&gt; Any:\n        \"\"\"\n        Provides introspective magic to inject the logger into a repository at the time\n        at the time the repository is accessed.\n        \"\"\"\n        attribute = super().__getattribute__(name)\n        if hasattr(attribute, \"__self__\") and issubclass(\n            attribute.__self__, AbstractRepository\n        ):\n            attribute.__self__.logger = self.logger\n\n        return attribute\n</code></pre> <p>A dependency class will be instantiated with the application logger (the @dataclass decorator automagically builds a constructor that will have parameters for populating the instance variables).</p> <p>The __getattribute__ method is technically called a Nasty Bit Of Hackery.  __getattribute__ is a built-in method for classes that controls the behavior of what happens when a \".\" is used to fetch something from a class.  In this case, the behavior was overriden to check to see if the attribute value is something that belongs to a class that was derived from AbstractRepository, and, if so, make sure the application logger is available to the class the attribute value belongs to.</p> <p>Looking at an example of how the dependency mapper is used in the Service layer:</p> <pre><code>    @handle_exceptions(on_exception=\"remove_intermediate_directory\")\n    @node\n    def create_intermediate_directory(self) -&gt; Transition:\n        \"\"\"\n        overview:\n            Create the intermediate directory for pulling the backup.\n\n        is_entry: True\n\n        happy_paths:\n            - create_pg_dump_directory\n\n        unhappy_paths:\n            - remove_intermediate_directory\n        \"\"\"\n        DependencyBackupAndEncrypt(logger=self.logger).create_intermediate_directory(\n            path=Path.intermediate_backup_base(\n                client_name=self.state.client_name, database_name=self.state.database\n            )\n        )\n\n        return self.success(exit_to=self.create_pg_dump_directory)\n</code></pre> <p>Line 47 is where the dependency mapper is being used.  What's happening is:</p> <ul> <li>We instantiate the DependencyBackupAndEncrypt supplying the application logger as the constructor parameter.</li> <li>We fetch the create_intermediate_directory property, which is referring to the FileManager.make_dir_if_not_exists method.</li> <li>When the executing code hits the \".\" between DependencyBackupAndEncrypt and create_intermediate_directory, __getattribute__, inherited from BaseDependency, will be called, and finding that FileManager is a decendent of AbstractRepository, it will inject the logger into FileManager.</li> <li>The parenthetical construct following create_intermediate_directory indicates we want to call whatever was returned as a value for create_intermediate_directory (the FileManager.make_dir_if_not_exists method).</li> <li>FileManager.make_dir_if_not_exists is called with the provided parameters.</li> </ul> <p>We name the property in the dependency mapper after the node it is used in because that makes it easier to keep track of what should be used where in both the implementation and the tests.</p> <p>We do not put docstrings on the properties in the dependency mapper.  IDEs are smart enough to recognized this level of indirection, so the hovering on \"create_intermediate_directory\" in the IDE will display the help information for FileManager.make_dir_if_not_exists.</p> <p>Now, I know this probably looks terribly convoluted, so let's look at the reason things are structured this way.</p> <p>Here is the unit test for the backup-and-encrypt state-machine.</p> <pre><code>\"\"\"\nTests the backup and encrypt cod flow.\n\"\"\"\n\n# application import\nfrom long_term_storage.service.backup.backup_and_encrypt import (\n    machine_backup_and_encrypt,\n    DependencyBackupAndEncrypt,\n)\nfrom state_machine import BaseDependency, Success\n\n# mock imports\nfrom tests.mocks import MockBasic\n\n# testing imports\nfrom tests.service.failure_asserts import failure_asserts\n\n# local imports\nfrom .create_machine import create_machine\n\n\ndef get_mocks() -&gt; DependencyBackupAndEncrypt:\n    \"\"\"\n    Mock the repository dependencies for the machine.\n    \"\"\"\n\n    class DependencyMocks(BaseDependency):\n        create_intermediate_directory = MockBasic.success\n        remove_intermediate_directory = MockBasic.success\n        create_pg_dump_directory = MockBasic.success\n        remove_pg_dump_directory = MockBasic.success\n        backup_schema = MockBasic.success\n        remove_schema_file = MockBasic.success\n        backup_data = MockBasic.success\n        remove_data_file = MockBasic.success\n        compress = MockBasic.success\n        remove_tarball = MockBasic.success\n        encrypt = MockBasic.success\n        remove_encrypted_backup = MockBasic.success\n        create_storage_directory = MockBasic.success\n        move_backup = MockBasic.success\n\n    return DependencyMocks  # pyright: ignore\n\n\ndef test_happy_path(monkeypatch):\n    \"\"\"Test the happy path.\"\"\"\n    with monkeypatch.context() as patch:\n        DependencyMocks = get_mocks()\n        patch.setattr(\n            machine_backup_and_encrypt,\n            \"DependencyBackupAndEncrypt\",\n            DependencyMocks,\n        )\n\n        machine = create_machine(2)\n\n        results = machine.execute()\n\n        node_order = []\n        for result in results:\n            assert isinstance(result, Success)\n            node_order.append(result.node)\n\n        assert node_order == [\n            \"MachineBackupAndEncrypt.create_intermediate_directory\",\n            \"MachineBackupAndEncrypt.create_pg_dump_directory\",\n            \"MachineBackupAndEncrypt.backup_schema\",\n            \"MachineBackupAndEncrypt.backup_data\",\n            \"MachineBackupAndEncrypt.compress\",\n            \"MachineBackupAndEncrypt.encrypt\",\n            \"MachineBackupAndEncrypt.create_storage_directory\",\n            \"MachineBackupAndEncrypt.move_backup\",\n            \"MachineBackupAndEncrypt.remove_encrypted_backup\",\n            \"MachineBackupAndEncrypt.remove_tarball\",\n            \"MachineBackupAndEncrypt.remove_data_file\",\n            \"MachineBackupAndEncrypt.remove_schema_file\",\n            \"MachineBackupAndEncrypt.remove_pg_dump_directory\",\n            \"MachineBackupAndEncrypt.remove_intermediate_directory\",\n            \"MachineBackupAndEncrypt.report_results\",\n        ]\n\n\ndef test_create_intermedite_failure(monkeypatch):\n    \"\"\"Test when creation of the intermediate directory fails.\"\"\"\n    with monkeypatch.context() as patch:\n        DependencyMocks = get_mocks()\n        DependencyMocks.create_intermediate_directory = MockBasic.failure\n        patch.setattr(\n            machine_backup_and_encrypt,\n            \"DependencyBackupAndEncrypt\",\n            DependencyMocks,\n        )\n\n        failure_asserts(\n            create_machine=create_machine,\n            result_count=3,\n            failing_node=0,\n            with_message=\"test_client_name test_postgresql.somewhere.in.azure test_database unrecognized exception: unit test failure\",\n        )\n\n\ndef test_create_pg_dump_directory_failure(monkeypatch):\n    \"\"\"Test when the creation of the pg_dump directory fails.\"\"\"\n    with monkeypatch.context() as patch:\n        DependencyMocks = get_mocks()\n        DependencyMocks.create_pg_dump_directory = MockBasic.failure\n        patch.setattr(\n            machine_backup_and_encrypt,\n            \"DependencyBackupAndEncrypt\",\n            DependencyMocks,\n        )\n\n        failure_asserts(\n            create_machine=create_machine,\n            result_count=5,\n            failing_node=1,\n            with_message=\"test_client_name test_postgresql.somewhere.in.azure test_database unrecognized exception: unit test failure\",\n        )\n\n\ndef test_backup_schema_failure(monkeypatch):\n    \"\"\"Test when backing up the schema fails.\"\"\"\n    with monkeypatch.context() as patch:\n        DependencyMocks = get_mocks()\n        DependencyMocks.backup_schema = MockBasic.failure\n        patch.setattr(\n            machine_backup_and_encrypt,\n            \"DependencyBackupAndEncrypt\",\n            DependencyMocks,\n        )\n\n        failure_asserts(\n            create_machine=create_machine,\n            result_count=7,\n            failing_node=2,\n            with_message=\"test_client_name test_postgresql.somewhere.in.azure test_database unrecognized exception: unit test failure\",\n        )\n\n\ndef test_backup_data_failure(monkeypatch):\n    \"\"\"Test when backing up the data fails.\"\"\"\n    with monkeypatch.context() as patch:\n        DependencyMocks = get_mocks()\n        DependencyMocks.backup_data = MockBasic.failure\n        patch.setattr(\n            machine_backup_and_encrypt,\n            \"DependencyBackupAndEncrypt\",\n            DependencyMocks,\n        )\n\n        failure_asserts(\n            create_machine=create_machine,\n            result_count=9,\n            failing_node=3,\n            with_message=\"test_client_name test_postgresql.somewhere.in.azure test_database unrecognized exception: unit test failure\",\n        )\n\n\ndef test_compress_failure(monkeypatch):\n    \"\"\"Test when tarring the backups fails.\"\"\"\n    with monkeypatch.context() as patch:\n        DependencyMocks = get_mocks()\n        DependencyMocks.compress = MockBasic.failure\n        patch.setattr(\n            machine_backup_and_encrypt,\n            \"DependencyBackupAndEncrypt\",\n            DependencyMocks,\n        )\n\n        failure_asserts(\n            create_machine=create_machine,\n            result_count=11,\n            failing_node=4,\n            with_message=\"test_client_name test_postgresql.somewhere.in.azure test_database unrecognized exception: unit test failure\",\n        )\n\n\ndef test_encrypt_failure(monkeypatch):\n    \"\"\"Test when encrypting the tarball fails.\"\"\"\n    with monkeypatch.context() as patch:\n        DependencyMocks = get_mocks()\n        DependencyMocks.encrypt = MockBasic.failure\n        patch.setattr(\n            machine_backup_and_encrypt,\n            \"DependencyBackupAndEncrypt\",\n            DependencyMocks,\n        )\n\n        failure_asserts(\n            create_machine=create_machine,\n            result_count=13,\n            failing_node=5,\n            with_message=\"test_client_name test_postgresql.somewhere.in.azure test_database unrecognized exception: unit test failure\",\n        )\n\n\ndef test_create_storage_directory_failure(monkeypatch):\n    \"\"\"Test when creating the long-term storage directory fails.\"\"\"\n    with monkeypatch.context() as patch:\n        DependencyMocks = get_mocks()\n        DependencyMocks.create_storage_directory = MockBasic.failure\n        patch.setattr(\n            machine_backup_and_encrypt,\n            \"DependencyBackupAndEncrypt\",\n            DependencyMocks,\n        )\n\n        failure_asserts(\n            create_machine=create_machine,\n            result_count=14,\n            failing_node=6,\n            with_message=\"test_client_name test_postgresql.somewhere.in.azure test_database unrecognized exception: unit test failure\",\n        )\n\n\ndef test_move_backup_failure(monkeypatch):\n    \"\"\"Test when moving encrypted file from intermediate to long-term storage fails.\"\"\"\n    with monkeypatch.context() as patch:\n        DependencyMocks = get_mocks()\n        DependencyMocks.move_backup = MockBasic.failure\n        patch.setattr(\n            machine_backup_and_encrypt,\n            \"DependencyBackupAndEncrypt\",\n            DependencyMocks,\n        )\n\n        failure_asserts(\n            create_machine=create_machine,\n            result_count=15,\n            failing_node=7,\n            with_message=\"test_client_name test_postgresql.somewhere.in.azure test_database unrecognized exception: unit test failure\",\n        )\n\n\ndef test_remove_encrypted_backup_failure(monkeypatch):\n    \"\"\"Test when removing intermediate encrypted backup fails.\"\"\"\n    with monkeypatch.context() as patch:\n        DependencyMocks = get_mocks()\n        DependencyMocks.remove_encrypted_backup = MockBasic.failure\n        patch.setattr(\n            machine_backup_and_encrypt,\n            \"DependencyBackupAndEncrypt\",\n            DependencyMocks,\n        )\n\n        failure_asserts(\n            create_machine=create_machine,\n            result_count=15,\n            failing_node=8,\n            with_message=\"test_client_name test_postgresql.somewhere.in.azure test_database unrecognized exception: unit test failure\",\n        )\n\n\ndef test_remove_tarball_failure(monkeypatch):\n    \"\"\"Test when removing the tarball fails.\"\"\"\n    with monkeypatch.context() as patch:\n        DependencyMocks = get_mocks()\n        DependencyMocks.remove_tarball = MockBasic.failure\n        patch.setattr(\n            machine_backup_and_encrypt,\n            \"DependencyBackupAndEncrypt\",\n            DependencyMocks,\n        )\n\n        failure_asserts(\n            create_machine=create_machine,\n            result_count=15,\n            failing_node=9,\n            with_message=\"test_client_name test_postgresql.somewhere.in.azure test_database unrecognized exception: unit test failure\",\n        )\n\n\ndef test_remove_data_file_failure(monkeypatch):\n    \"\"\"Test when removing the data backup file fails.\"\"\"\n    with monkeypatch.context() as patch:\n        DependencyMocks = get_mocks()\n        DependencyMocks.remove_data_file = MockBasic.failure\n        patch.setattr(\n            machine_backup_and_encrypt,\n            \"DependencyBackupAndEncrypt\",\n            DependencyMocks,\n        )\n\n        failure_asserts(\n            create_machine=create_machine,\n            result_count=15,\n            failing_node=10,\n            with_message=\"test_client_name test_postgresql.somewhere.in.azure test_database unrecognized exception: unit test failure\",\n        )\n\n\ndef test_remove_schema_file_failure(monkeypatch):\n    \"\"\"Test when removing the schema backup file fails.\"\"\"\n    with monkeypatch.context() as patch:\n        DependencyMocks = get_mocks()\n        DependencyMocks.remove_schema_file = MockBasic.failure\n        patch.setattr(\n            machine_backup_and_encrypt,\n            \"DependencyBackupAndEncrypt\",\n            DependencyMocks,\n        )\n\n        failure_asserts(\n            create_machine=create_machine,\n            result_count=15,\n            failing_node=11,\n            with_message=\"test_client_name test_postgresql.somewhere.in.azure test_database unrecognized exception: unit test failure\",\n        )\n\n\ndef test_remove_pg_dump_directory_failure(monkeypatch):\n    \"\"\"Test when removing the pg_dump directory fails.\"\"\"\n    with monkeypatch.context() as patch:\n        DependencyMocks = get_mocks()\n        DependencyMocks.remove_pg_dump_directory = MockBasic.failure\n        patch.setattr(\n            machine_backup_and_encrypt,\n            \"DependencyBackupAndEncrypt\",\n            DependencyMocks,\n        )\n\n        failure_asserts(\n            create_machine=create_machine,\n            result_count=15,\n            failing_node=12,\n            with_message=\"test_client_name test_postgresql.somewhere.in.azure test_database unrecognized exception: unit test failure\",\n        )\n\n\ndef test_remove_intermediate_directory_failure(monkeypatch):\n    \"\"\"Test when removing the intermediate directory fails.\"\"\"\n    with monkeypatch.context() as patch:\n        DependencyMocks = get_mocks()\n        DependencyMocks.remove_intermediate_directory = MockBasic.failure\n        patch.setattr(\n            machine_backup_and_encrypt,\n            \"DependencyBackupAndEncrypt\",\n            DependencyMocks,\n        )\n\n        failure_asserts(\n            create_machine=create_machine,\n            result_count=15,\n            failing_node=13,\n            with_message=\"test_client_name test_postgresql.somewhere.in.azure test_database unrecognized exception: unit test failure\",\n        )\n</code></pre> <p>We will discuss the structuring of unit tests in a later episode, but I have included the entire test here to emphasize that unit tests do not simply test what you intended the implementation of a class to do.  You also have to confirm you have defined behavior for all of the possible ways the implementation could fail while trying to fulfill its intended purpose.</p> <p>Getting back to dependency injection, the relevant section is:</p> <pre><code>def get_mocks() -&gt; DependencyBackupAndEncrypt:\n    \"\"\"\n    Mock the repository dependencies for the machine.\n    \"\"\"\n\n    class DependencyMocks(BaseDependency):\n        create_intermediate_directory = MockBasic.success\n        remove_intermediate_directory = MockBasic.success\n        create_pg_dump_directory = MockBasic.success\n        remove_pg_dump_directory = MockBasic.success\n        backup_schema = MockBasic.success\n        remove_schema_file = MockBasic.success\n        backup_data = MockBasic.success\n        remove_data_file = MockBasic.success\n        compress = MockBasic.success\n        remove_tarball = MockBasic.success\n        encrypt = MockBasic.success\n        remove_encrypted_backup = MockBasic.success\n        create_storage_directory = MockBasic.success\n        move_backup = MockBasic.success\n\n    return DependencyMocks  # pyright: ignore\n</code></pre> <p>What we are doing here is creating \"mocks\" of the outside functionality the class depends upon.  This function creates a dependency mapper that by default is saying everything will happen as expected.  Then, in the tests, we substitute this dependency mapper for the one the code is supposed to use in a real word scenario.</p> <p>Looking at the happy-path test where everything runs as expected:</p> <pre><code>def test_happy_path(monkeypatch):\n    \"\"\"Test the happy path.\"\"\"\n    with monkeypatch.context() as patch:\n        DependencyMocks = get_mocks()\n        patch.setattr(\n            machine_backup_and_encrypt,\n            \"DependencyBackupAndEncrypt\",\n            DependencyMocks,\n        )\n\n        machine = create_machine(2)\n\n        results = machine.execute()\n\n        node_order = []\n        for result in results:\n            assert isinstance(result, Success)\n            node_order.append(result.node)\n\n        assert node_order == [\n            \"MachineBackupAndEncrypt.create_intermediate_directory\",\n            \"MachineBackupAndEncrypt.create_pg_dump_directory\",\n            \"MachineBackupAndEncrypt.backup_schema\",\n            \"MachineBackupAndEncrypt.backup_data\",\n            \"MachineBackupAndEncrypt.compress\",\n            \"MachineBackupAndEncrypt.encrypt\",\n            \"MachineBackupAndEncrypt.create_storage_directory\",\n            \"MachineBackupAndEncrypt.move_backup\",\n            \"MachineBackupAndEncrypt.remove_encrypted_backup\",\n            \"MachineBackupAndEncrypt.remove_tarball\",\n            \"MachineBackupAndEncrypt.remove_data_file\",\n            \"MachineBackupAndEncrypt.remove_schema_file\",\n            \"MachineBackupAndEncrypt.remove_pg_dump_directory\",\n            \"MachineBackupAndEncrypt.remove_intermediate_directory\",\n            \"MachineBackupAndEncrypt.report_results\",\n        ]\n</code></pre> <p>In line 49 we are fetching a copy of our mock dependencies.</p> <p>In lines 50 through 54, we inject our mock dependencies into the class definition. The setattr function is saying \"for the module that the class being tested lives in, machine_backup_and_encrypt, replace DependencyBackupAndEncrypt with DependencyMocks\".</p> <p>We set everything up for default success using MockBasic.success, because none of these calls expect a return value.  MockBasic.success is about as simple a method as you can get.</p> <pre><code>    @classmethod\n    def success(cls, **kwargs) -&gt; Any:\n        \"\"\"The mocked function succeeded and had nothing to return.\"\"\"\n</code></pre> <p>It doesn't do anything except return without error.  And that's the behavior we want in the unit test.  We do not want our unit tests to go out and start creating directories in the file system of the machine they are being run on.  We are only testing the functionality that resides within the class being tested.</p> <p>The magic \"***kwargs\" says the method accepts whatever named parameters it is called with.  Since we are using named parameters throughout the system, the success method can be used to mock any method where a return value is not expected.</p> <p>Now we'll take a look at a failure scenario.  Executing \"mkdir -p ...\" is something that can fail.  Maybe the disk is out of space or you don't have permissions to make the directory where it's trying to be created.  In an automated system, that is an unrecoverable situation that we want reported back to us.  We want to make sure there is defined behavior for handling a failure of \"mkdir -p ...\", so the program doesn't just die silently.</p> <pre><code>def test_create_intermedite_failure(monkeypatch):\n    \"\"\"Test when creation of the intermediate directory fails.\"\"\"\n    with monkeypatch.context() as patch:\n        DependencyMocks = get_mocks()\n        DependencyMocks.create_intermediate_directory = MockBasic.failure\n        patch.setattr(\n            machine_backup_and_encrypt,\n            \"DependencyBackupAndEncrypt\",\n            DependencyMocks,\n        )\n\n        failure_asserts(\n            create_machine=create_machine,\n            result_count=3,\n            failing_node=0,\n            with_message=\"test_client_name test_postgresql.somewhere.in.azure test_database unrecognized exception: unit test failure\",\n        )\n</code></pre> <p>In line 87, we fecth our mock dependencies. In line 88, we change the behavior for create_intermediate_directory from MockBasic.success to MockBasic.failure. Lines 89 through 93 inject our mock dependencies into the machine_backup_and_encrypt module.</p> <p>MockBasic.failure, also, is not a complicated function.</p> <pre><code>    @classmethod\n    def failure(cls, **kwargs) -&gt; Any:\n        \"\"\"The mocked function raised an exception.\"\"\"\n        raise Exception(\"unit test failure\")\n</code></pre> <p>We don't care why \"mkdir -p ...\" may have failed.  We just want to make sure the class behaved the way it should when it encountered a failure with \"mkdir -p ...\".</p> <p>The reason we separate the dependency mapper into per-usage of the dependencies is because the dependencies may be used more than once.  If we look back at the original definition of DependencyBackupAndEncrypt, we will find that create_intermediate_directory, create_pg_dump_directory, and create_storage_directory are all using FileManager.make_dir_if_not_exists.</p> <p>Without separating them, we would be unable to test failures for create_pg_dump_directory or create_storage_directory.  Were we to set up FileManager.make_dir_if_not_exists to fail directly, the implementation would never reach the usages of create_pg_dump_directory or create_storage_directory, because it would always fail at create_intermediate_directory and bypass the code for the other usages.</p> <ol> <li> <p>Usage of dependency injection in Python code bases predates the term \"dependency injection\" by about a decade, so within Python projects you will often find references to \"monkey patching\", because that's what Python people called it before the Java people came up with the term \"dependency injection\".\u00a0\u21a9</p> </li> </ol>"},{"location":"framework/end_points.html","title":"End Points","text":"<p>End-points are responsible for invoking the system behavior.</p> <p>There are two classes defined for processing end-point behavior.  The first defines a class called EndPoint.</p> <pre><code># standard library imports\nfrom traceback import format_exc\n\n# application imports\nfrom state_machine import Logger\nfrom state_machine import Failure, AbstractMachine\n\n# local imports\nfrom .dependency_end_point import DependencyEndPoint\n\n\nclass EndPoint:\n    \"\"\"\n    Wrapper around a state machine to execute the machine and report failures to stdout.\n    \"\"\"\n\n    def __init__(\n        self,\n        *,\n        logger: Logger,\n        machine: AbstractMachine,\n    ):\n        self._logger = logger\n        self._machine = machine\n\n    def execute(self):\n        \"\"\"\n        Executes the machine, filters any failures, reports failures on stdout, and exits with the status of the number of failures.\n        \"\"\"\n        try:\n            self._results = self.machine.execute()\n\n            self._failures = [\n                result for result in self._results if isinstance(result, Failure)\n            ]\n\n            for failure in self._failures:\n                self.logger.error(f\"Failure: {failure}\")\n                DependencyEndPoint(logger=self.logger).execute_write_to_stdout(\n                    content=f\"Failure: {failure}\"\n                )\n\n            DependencyEndPoint(logger=self.logger).execute_exit(\n                result=len(self._failures)\n            )\n        except Exception as exception:\n            self.logger.critical(f\"Critical exception: {format_exc()}\")\n            DependencyEndPoint(logger=self.logger).execute_write_to_stdout(\n                content=f\"Critical failure: {exception}\"\n            )\n            DependencyEndPoint(logger=self.logger).execute_exit(result=1)\n\n    @property\n    def logger(self):\n        return self._logger\n\n    @property\n    def machine(self):\n        return self._machine\n</code></pre> <p>The constructor takes two parameters:</p> <ul> <li>logger is the system logger.</li> <li>machine is the state-machine service to be executed.</li> </ul> <p>The execute method runs the state-machine and compiles the the failure reports.</p> <pre><code>    def execute(self):\n        \"\"\"\n        Executes the machine, filters any failures, reports failures on stdout, and exits with the status of the number of failures.\n        \"\"\"\n        try:\n            self._results = self.machine.execute()\n\n            self._failures = [\n                result for result in self._results if isinstance(result, Failure)\n            ]\n\n            for failure in self._failures:\n                self.logger.error(f\"Failure: {failure}\")\n                DependencyEndPoint(logger=self.logger).execute_write_to_stdout(\n                    content=f\"Failure: {failure}\"\n                )\n\n            DependencyEndPoint(logger=self.logger).execute_exit(\n                result=len(self._failures)\n            )\n        except Exception as exception:\n            self.logger.critical(f\"Critical exception: {format_exc()}\")\n            DependencyEndPoint(logger=self.logger).execute_write_to_stdout(\n                content=f\"Critical failure: {exception}\"\n            )\n            DependencyEndPoint(logger=self.logger).execute_exit(result=1)\n</code></pre> <p>The first thing we are going to do in the try-block, is execute the state-machine, which is going to report the successes and failures back to us.</p> <p>We then filter out the failures from the results.</p> <p>For each failure we output a line describing the failure to stdout.  DependencyEndPoint.execute_write_to_stdout is a wrapper Python's builtin print function.  We treat as a Repository for unit testing purposes.</p> <p>We then exit the process with the count of failures that occurred as the exit-code.  Zero failures means everything was happy.  DependencyEndPoint.execute_exit is a wrapper around Python's builtin exit function.  Calling exit in the middle a unit test stops everything--including the unit test framework.</p> <p>We setup self._results and self._failures as instance variables, so the outcomes of executing a machine are available in unit testing.</p> <p>The second type of end-point is a DynamicMountingEndPoint.</p> <pre><code># application imports\nfrom state_machine import Logger\nfrom long_term_storage.service.dynamic_mount import (\n    MachineDynamicMount,\n    StateDynamicMount,\n)\n\n# local imports\nfrom .end_point import EndPoint\n\n\nclass DynamicMountingEndPoint(EndPoint):\n    \"\"\"\n    Executes a state machine within a dynamic mounting machine.\n    \"\"\"\n\n    def __init__(\n        self,\n        *,\n        logger: Logger,\n        state_dynamic_mount: StateDynamicMount,\n    ):\n        wrapped_machine = MachineDynamicMount(logger=logger, state=state_dynamic_mount)\n        super().__init__(logger=logger, machine=wrapped_machine)\n</code></pre> <p>Dynamic mounting/unmounting of the file-shares was tacked on top of existing code that assumed the file-share would be mounted prior to execution.  MachineDynamicMount that takes an arbitrary state-machine as a parameter, mounts the file-share prior to executing the provided machine, and unmounts the file-share following execution of the machine.</p> <p>DynamicMountingEndPoint overrides the construction of EndPoint to insert MachineDynamicMount as the state-machine to be executed.</p> <p>The full definition of an \"end-point\" in this case is a command line script to be executed by the Control-M scheduler.  Taking a look at the definition of the backup script:</p> <pre><code>\"\"\"\nScript to execute the backup of a PostgreSQL instance.\n\nusage: python -m backup.run [-h] [--tenant_id TENANT_ID] [--authority_host AUTHORITY_HOST] client_name eoy_month key_vault client_id client_secret\n\nBackup a PostgreSQL instance.\n\npositional arguments:\n  client_name           The name of the client to be backed up\n  eoy_month             The month that designates the end-of-year (1-12)\n  key_vault             The url of the client's key vault\n  client_id             The client id for the Service Principal\n  client_secret         The secret for the Service Principal\n\noptions:\n  -h, --help            show this help message and exit\n  --tenant_id TENANT_ID\n                        The tenant id for the key vault (optional)\n  --authority_host AUTHORITY_HOST\n                        The authority for authenticating the Service Principal (optional)\n\"\"\"\n\n# standard library imports\nimport argparse\nfrom traceback import format_exc\n\n# third party imports\nfrom pydantic import SecretStr\n\n# application imports\nfrom long_term_storage.model.connection.key_vault import ServicePrincipal\nfrom state_machine.config import encryption\nfrom long_term_storage.repository import ClientLogger\nfrom long_term_storage.repository.key_vault import BackupConfigModel\nfrom long_term_storage.end_point.dynamic_mounting_end_point import (\n    DynamicMountingEndPoint,\n    StateDynamicMount,\n)\nfrom long_term_storage.service.backup.backup_databases import (\n    MachineBackupDatabases,\n    StateBackupDatabases,\n)\n\n\ndef run(\n    client_name: str,\n    eoy_month: int,\n    tenant_id: str,\n    client_id: str,\n    client_secret: str,\n    authority_host: str,\n    key_vault: str,\n):\n    \"\"\"\n    Configure and execute the job.\n    \"\"\"\n    try:\n        # Create the logger.\n        logger = ClientLogger(\n            client_name=client_name,\n            file_name=MachineBackupDatabases.__module__.split(\".\")[2],\n        )\n\n        logger.info(\"***************\")\n\n        # Load connection config from key vault.\n        connection_model = ServicePrincipal(\n            keyvault_host=key_vault,\n            service_principal_id=client_id,\n            client_secret=SecretStr(secret_value=encryption.decrypt(client_secret)),\n            tenant_id=tenant_id,\n            authority_host=authority_host,\n        )\n        backup_config = BackupConfigModel.from_keyvault(\n            logger=logger, connection_model=connection_model\n        )\n\n        # Bundle up the model the machine expects and create the machine.\n        state = StateBackupDatabases(\n            client_name=client_name, backup_config=backup_config, eoy_month=eoy_month\n        )\n        machine = MachineBackupDatabases(logger=logger, state=state)\n\n        # Use the end-point that wraps the machine with auto-mounting/unmounting\n        # of the file share.\n        end_point = DynamicMountingEndPoint(\n            logger=logger,\n            state_dynamic_mount=StateDynamicMount(\n                client_name=client_name,\n                backup_config=backup_config,\n                machine_to_wrap=machine,\n            ),\n        )\n        end_point.execute()\n\n    # If anything goes wrong, dump the traceback to stdout and exit with a failure.\n    except Exception as exception:\n        print(f\"Critical failure: {exception}\")\n        print(format_exc())\n        exit(1)\n\n\nif __name__ == \"__main__\":\n    # Define the command line arguments.\n    parser = argparse.ArgumentParser(\n        prog=\"python -m backup.run\", description=\"Backup a PostgreSQL instance.\"\n    )\n    parser.add_argument(\n        \"client_name\", help=\"The name of the client to be backed up\", type=str\n    )\n    parser.add_argument(\n        \"eoy_month\", help=\"The month that designates the end-of-year (1-12)\", type=int\n    )\n    parser.add_argument(\"key_vault\", help=\"The url of the client's key vault\", type=str)\n    parser.add_argument(\n        \"client_id\", help=\"The client id for the Service Principal\", type=str\n    )\n    parser.add_argument(\n        \"client_secret\", help=\"The secret for the Service Principal\", type=str\n    )\n    parser.add_argument(\n        \"--tenant_id\",\n        help=\"The tenant id for the key vault (optional)\",\n        type=str,\n        default=\"e17e2402-2a40-42ce-ad75-5848b8d4f6b6\",\n    )\n    parser.add_argument(\n        \"--authority_host\",\n        help=\"The authority for authenticating the Service Principal (optional)\",\n        default=\"https://login.microsoftonline.com\",\n    )\n\n    # Parse the command line arguments.\n    args = parser.parse_args()\n\n    # Execute the job.\n    run(\n        client_name=args.client_name,\n        eoy_month=args.eoy_month,\n        tenant_id=args.tenant_id,\n        client_id=args.client_id,\n        client_secret=args.client_secret,\n        authority_host=args.authority_host,\n        key_vault=args.key_vault,\n    )\n</code></pre> <p>The script starts at the bottom-ish of the file in the part following line 98.</p> <pre><code>if __name__ == \"__main__\":\n</code></pre> <p>This is a magic incantation in Python that determines whether the module was invoked directly from the command line or has been imported by another module.  When the module is executed from the command line, the builtin value of __name__ will contain \"__main__\".  When imported, __name__ will contain a module namespace value that is not \"__main__\", so when importing, the part after the \"if\" statement will not be executed.</p> <p>The first thing the script does is defined the command line parameters.</p> <pre><code>    # Define the command line arguments.\n    parser = argparse.ArgumentParser(\n        prog=\"python -m backup.run\", description=\"Backup a PostgreSQL instance.\"\n    )\n    parser.add_argument(\n        \"client_name\", help=\"The name of the client to be backed up\", type=str\n    )\n    parser.add_argument(\n        \"eoy_month\", help=\"The month that designates the end-of-year (1-12)\", type=int\n    )\n    parser.add_argument(\"key_vault\", help=\"The url of the client's key vault\", type=str)\n    parser.add_argument(\n        \"client_id\", help=\"The client id for the Service Principal\", type=str\n    )\n    parser.add_argument(\n        \"client_secret\", help=\"The secret for the Service Principal\", type=str\n    )\n    parser.add_argument(\n        \"--tenant_id\",\n        help=\"The tenant id for the key vault (optional)\",\n        type=str,\n        default=\"e17e2402-2a40-42ce-ad75-5848b8d4f6b6\",\n    )\n    parser.add_argument(\n        \"--authority_host\",\n        help=\"The authority for authenticating the Service Principal (optional)\",\n        default=\"https://login.microsoftonline.com\",\n    )\n</code></pre> <p>We instantiate an ArgumentParser object, and define each of the command line arguments.</p> <p>We then compile the definition of the ArgumentParser, which will take care of reading the arguments from the command line and providing the usage/help info for the script when run from the command line.</p> <pre><code>    args = parser.parse_args()\n</code></pre> <p>This exposes the command line arguments as named properties on the \"args\" variable.</p> <p>Finally, we call the run function set up the EndPoint layer and execute the Service layer.</p> <pre><code>    # Execute the job.\n    run(\n        client_name=args.client_name,\n        eoy_month=args.eoy_month,\n        tenant_id=args.tenant_id,\n        client_id=args.client_id,\n        client_secret=args.client_secret,\n        authority_host=args.authority_host,\n        key_vault=args.key_vault,\n    )\n</code></pre> <p>Now, we'll look at the definition of the run function.</p> <pre><code>def run(\n    client_name: str,\n    eoy_month: int,\n    tenant_id: str,\n    client_id: str,\n    client_secret: str,\n    authority_host: str,\n    key_vault: str,\n):\n    \"\"\"\n    Configure and execute the job.\n    \"\"\"\n    try:\n        # Create the logger.\n        logger = ClientLogger(\n            client_name=client_name,\n            file_name=MachineBackupDatabases.__module__.split(\".\")[2],\n        )\n\n        logger.info(\"***************\")\n\n        # Get acces to the key vault containing the client config.\n        KeyVault.logger = logger\n        connection_model = ServicePrincipal(\n            keyvault_host=key_vault,\n            service_principal_id=client_id,\n            client_secret=SecretStr(secret_value=encryption.decrypt(client_secret)),\n            tenant_id=tenant_id,\n            authority_host=authority_host,\n        )\n        key_vault_client = KeyVault().execute(connection_model=connection_model)\n        backup_config = ClientConfig(logger, key_vault_client)\n\n        # Bundle up the model the machine expects and create the machine.\n        state = StateBackupDatabases(\n            client_name=client_name, backup_config=backup_config, eoy_month=eoy_month\n        )\n        machine = MachineBackupDatabases(logger=logger, state=state)\n\n        # Use the end-point that wraps the machine with auto-mounting/unmounting\n        # of the file share.\n        end_point = DynamicMountingEndPoint(\n            logger=logger,\n            state_dynamic_mount=StateDynamicMount(\n                client_name=client_name,\n                backup_config=backup_config,\n                machine_to_wrap=machine,\n            ),\n        )\n        end_point.execute()\n\n    # If anything goes wrong, dump the traceback to stdout and exit with a failure.\n    except Exception as exception:\n        print(f\"Critical failure: {exception}\")\n        print(format_exc())\n        exit(1)\n</code></pre> <p>We wrap it in a try-block.  While there should be no unhadled exceptions in the End-Point or Service layers, if one does occur, we want to receive an alert.</p> <p>The first thing we are doing is setting up the logger.</p> <pre><code>        # Create the logger.\n        logger = ClientLogger(\n            client_name=client_name,\n            file_name=MachineBackupDatabases.__module__.split(\".\")[2],\n        )\n</code></pre> <p>This is an atypical way of logging in Python.  Normally, the logger would just be exposed as a \"global\" variable within each module's definition, and Python's logging system is smart enough to disentangle the multiple definitions.  In this case, however, we wanted the logs to be organized as one directory per client--information that isn't available in the \"global\" module namespace, so we've built a little wrapper around the logging system to make sure logs are routed to the correct directory.</p> <p>The parameters for ClientLogger are:</p> <ul> <li>client_name is the name of the client directory the log file should appear in.</li> <li>file_name is the name of the log file.  MachineBackupDatabases.__module__.split(\".\")[2] is some introspective magic.  __module__ is a value every class has that identifies the full namespace path to the class.  For the MachineBackupDatabases class, the value would be \"long_term_storage.services.backup.backup_databases.machine_backup_databases.MachineBackupDatabases\".  The best name for the log file is the overall service name, which is the third element in the module name \"backup\".  So we split the string on \".\" and take the third element (lists are zero-indexed).</li> </ul> <p>The next thing we do is log a bunch of asterisks.  This is just an easily searchable string that means \"start of run\".</p> <p>Next, we're going to load information from the Azure Key Vault where the connection information and secrets needed to perform the backup live.  The information necessary to connect to this key vault was provided in the command line arguments.</p> <pre><code>        # Load connection config from key vault.\n        connection_model = ServicePrincipal(\n            keyvault_host=key_vault,\n            service_principal_id=client_id,\n            client_secret=SecretStr(secret_value=encryption.decrypt(client_secret)),\n            tenant_id=tenant_id,\n            authority_host=authority_host,\n        )\n        backup_config = BackupConfigModel.from_keyvault(\n            logger=logger, connection_model=connection_model\n        )\n</code></pre> <p>Lines 69 through 75 are populating a data model that provides the information necessary for a Service Principal to access a key vault.</p> <p>The primary weirdness here is in populating client_secret.  The client_secret for the Service Principal is not a value we want to expose, but since it needs to be provided as a command line argument, and all command line arguments are visible in clear text while a process is running, the command line parameter containing the value had to be encrypted prior to submitting the job.  So, we have to decrypt that value.  The encryption.decrypt function provides the clear-text, decrypted value, but we still want masking rules to apply to it, so it has to be provided to the connection model as a SecretStr.</p> <p>Line 76 fetches the config information from the key vault.</p> <p>Next, we instantiate the state-machine that will do the work.</p> <pre><code>        # Bundle up the model the machine expects and create the machine.\n        state = StateBackupDatabases(\n            client_name=client_name, backup_config=backup_config, eoy_month=eoy_month\n        )\n        machine = MachineBackupDatabases(logger=logger, state=state)\n</code></pre> <p>We build the state object, StateBackupDatabases, which contains:</p> <ul> <li>client_name is the name of the client being backed up.</li> <li>backup_config the config information from the key vault.</li> <li>eoy_month is a numeric value indicating which month is considered to be the client's end-of-year month.</li> </ul> <p>We then instantiate MachineBackupDatabases with the application logger and its defining state object.</p> <p>Next we instantiate an End-Point object.</p> <pre><code>        # Use the end-point that wraps the machine with auto-mounting/unmounting\n        # of the file share.\n        end_point = DynamicMountingEndPoint(\n            logger=logger,\n            state_dynamic_mount=StateDynamicMount(\n                client_name=client_name,\n                backup_config=backup_config,\n                machine_to_wrap=machine,\n            ),\n        )\n</code></pre> <p>In this case, we are using dynamic mounting of the file-share, so we use the DynamicMountingEndPoint.  As parameters, it expects:</p> <ul> <li>logger is the application logger.</li> <li>state_dynamic_mount is a state object for MachineDynamicMount, which expects:<ul> <li>client_name is the name of the client being backed up.</li> <li>backup_config is the config information from the key vault.</li> <li>machine_to_wrap is the instance of the state-machine to execute inbetween mounting and unmounting of the file-share.</li> </ul> </li> </ul> <p>Finally, we execute the end-point which, in turn, will execute the service.</p> <pre><code>        end_point.execute()\n</code></pre>"},{"location":"framework/layers.html","title":"Layers","text":"<p>The framework is structured using End-Point\u2194Service\u2194Repository layers.  It's a pattern outlining what code should live where.  Each layer has its own set of responsibilities:</p> <ul> <li>End-Point: The entrance point for a requested action. It's responsible for making sure the parameters make sense, passing the request to the service layer, and formatting the response from service layer into something consumable by the requestor.</li> <li>Service: This is where the business-logic lives. It's responsible about making decisions about what should be done.</li> <li>Repository: This is where the code that actually goes out and does something lives. It's responsible for interacting with things outside of the service.</li> </ul> <pre><code>graph LR\nM[Scheduler] --&gt; E[End-Point]\nE --&gt; S[Service]\nS --&gt; R1[File-system Repository]\nR1 --&gt; S\nS --&gt; R2[Database Repository]\nR2 --&gt; S\nS --&gt; R3[... Repository]\nR3 --&gt; S\nS --&gt; E\nE --&gt; M</code></pre> <p>Correspondingly, the code that implements the things to be done will be found in the directories named:</p> <ul> <li>end_point: Contains the job setup, execution, and response to the caller.</li> <li>service: Contains the state-machines that make decisions about what to do.</li> <li>repository: Contains the interactions with file system, database, gpg...</li> </ul> <p>The reason for separating things this way is testability.  By separating the code that decides what to do from the code that does something, all of the decision branches in the business logic can be exercised by replacing the code that \"does something\" with \"do nothing\" or \"fail miserably\" mock code in unit tests.</p> <p>The framework is also implementing the Results Pattern.  Everything the code attempts to do can have one of two outcomes--it either succeeded or it failed.  Success and Failure are the \"results\" in the Results Pattern.</p> <p>Any code where an exception can be raised resides in the Repository layer.  The Service layer will convert any exceptions into a Failure.</p> <p>The reason for handling things this way is we can use unit tests to guarantee there are no there are no coding errors in out Service and End-Point layers.  It also provides us with a clean way to handle partial successes.  Say we want to backup a database server that has ten databases on it.  We don't want an exception raised while backing up the first database to block the potential success of the other nine databases.  We want the system to try to backup all ten and generate an alert for any that fail.</p> <p>The Results Pattern accommodates this situation very well.  When the end-point reports back to scheduler, it ignores the successes and only reports failure occurrences.  The scheduler can then generate alerts based on the failure notifications it received.</p>"},{"location":"framework/namespaces_and_imports.html","title":"Namespaces and Imports","text":"<p>Namespaces provide a hierarchal mechanism for identifying what lives where.  Anytime a \".\" is used, it can be read as \"from the namespace to the left of the dot, give me the item named on the right of the dot\".</p> <p>Namespace organization is pervasive, but there are three basic levels:</p> <ul> <li>package: A directory containing a set of modules (Python files) and subpackages (nested directories).<ul> <li>module: A Python file containing classes, functions, variables...<ul> <li>class: A class definition containing methods and variables.</li> </ul> </li> </ul> </li> </ul> <p>In the file system, you will find a structure like:</p> <pre><code>package/\n    __init__.py\n    module1.py\n    module2.py\n    subpackage1/\n        __init__.py\n        module3.py\n        module4.py\n    subpackage2/\n        __init__.py\n        module5.py\n        module6.py\n</code></pre> <p>One thing to note in that structure is __init__.py.  First and foremost this is a file that identifies the directory as a Python package, and the contents can be imported by other Python modules.  However, upon importing a package, the contents of __init__.py will be executed, so the file also serves as a \"constructor\" for the package.  Most commonly it simply contains a set of import statements that let users know which modules are considered \"public\" and meant to be used by modules outside the package and which are \"internal\" and not intended to be used externally.</p> <p>Import statements pull functionality from an outside source into a Python module.  There are two forms of the import statement.</p> <ul> <li>Import statements that start with \"import\" bring the imported namespace into the module's namespace.  Accessing items from the imported namespace will require the whole path to access items.</li> <li>Import statements that start with \"from\" bring specific parts of the imported namespace into the module's namespace.<sup>1</sup></li> </ul> <p>\"import\" example:</p> <pre><code>import package.subpackage1\n\nmodule3_class = package.subpackage1.Module3Class()\n</code></pre> <p>\"from\" example:</p> <pre><code>from package.subpackage1 import Module3Class\n\nmodule3_class = Module3Class()\n</code></pre> <p>In general, \"from\" style imports are preferable to \"import\" style.</p> <p>Python also supports what are known as \"relative\" imports.  Say module3.py needed something from module1.py in the package tree.  The usage of prefixed \".\" can indicate where in the tree the import is coming from.  One \".\" means \"from this directory\".  Two \"..\" means \"from the directory above\".  So in module3.py, we may find something like:</p> <pre><code>from ..module1 import some_function\n</code></pre> <p>The import statements should always appear at the top of the module file.  Additionally, the imports are organized into sections:</p> <ul> <li>standard library imports: Functionality brought in from Python's standard library.</li> <li>third party imports: Functionality brought in from the Python package ecosystem.</li> <li>application imports: Functionality brought in from other parts of the code base.</li> <li>local imports: Relative imports bringing in functionality from nearby parts of the package tree.</li> </ul> <pre><code># standard library imports\nfrom datetime import datetime, UTC\n\n# third party imports\nfrom joblib import delayed, Parallel\n\n# application imports\nfrom long_term_storage.constant.path import Path\nfrom long_term_storage.model import MasterConfigModel\nfrom state_machine.config import Config\nfrom state_machine.decorator import (\n    handle_exceptions,\n    machine,\n    no_exceptions,\n    node,\n)\nfrom state_machine import AbstractMachine, Failure, Transition\n\n# local imports\nfrom ..eom_delete import MachineEomDelete, StateEomDelete\nfrom .dependency_eom_deletion_candidates import DependencyEomDeletionCandidates\nfrom .state_eom_deletion_candidates import StateEomDeletionCandidates\n</code></pre> <p>Lines 1 and 2 are imports from the Python's standard library.</p> <p>Lines 4 and 5 are imports third party package imports.</p> <p>Lines 7 through 17 are the application imports.</p> <p>Lines 19 through 22 are the package's local level imports.</p> <ol> <li> <p>Python also supports \"from package import *\", which means bring in everything package has.  Don't use that kind of import.  Though it still exists for reverse-compatability reasons, it was long ago found to be a Bad Idea.\u00a0\u21a9</p> </li> </ol>"},{"location":"framework/navigating_object_orientation.html","title":"Navigating Object Orientation","text":"<p>Object Orientation came into existence to solve two software development problems that were frequently encountered prior to its introduction:</p> <ul> <li>Reliance on global variables, which led to a lot of change-this, break-that seemingly unrelated part of the code base.</li> <li>Redundant code generated by copy-and-pasting similar functionality in many different places, which led to the problem of when you wanted to change that part of the functionality, you had to track down all of the places it was implemented--a process that generally took things failing in production two or three times before you found all of them.</li> </ul> <p>If we jump in the way-back machine, there was a time when everything lived in what has come to be called the \"global\" namespace.  Any part of the code base could access and modify anything else that was defined in the code base.</p> <p>The first solution to this problem was the introduction of \"functions\" that had a \"local\" namespace.  Variables defined in one function could not be modified by another function.  This meant you were free to edit the individual functions safe in the knowledge that changing the value of a variable within a function will not break any of the other functions.</p> <p>However, there was still a need to sometimes provide information that was available to many different functions, so it did not entirely remove the usage of \"global\" variables.  Change-this-break-that didn't happen as frequently, but it still happened.</p> <p>Object Orientation sought to remove the reliance on global variables by introducing the concept of a \"class\".  A class is a self-contained collection of variables and functions that may or may not be accessible to other classes, depending on the level of exposure you, as the programmer, decide to give them.  Although, since they wanted to emphasize that the functions in a class should not be confused with what was formerly referred to as a function, they renamed \"function\" to \"method\".  The primary difference between a \"function\" and a \"method\" is that a \"method\" has automatic access to the \"class variables\" whereas a \"function\" does not.</p> <p>In Object Oriented terms, this is referred to as \"encapsulation\", which simply means stuff defined inside a class cannot be manipulated by anything outside of the class.  Organizing code this way allows you to see everything that will be affected by changing a variable within the class.  It doesn't completely eliminate change-this-break-that, but it does get rid of the \"break-that seemingly unrelated part of the code base\"--you can only break things that are directly dependent on the class you are editing, which is much easier to track down.</p> <p>Most Object Oriented languages provide keywords for designating the level of encapsulation an item will be given:</p> <ul> <li>private: The item is only accessible from within the class it is defined in.</li> <li>protected: The item is accessible within the class or any subclasses derived from the class.</li> <li>public: The item is available to anything in the code base that uses the class.</li> </ul> <p>Python does not have keywords for enforcing encapsulation, so it is performed by convention:</p> <ul> <li>Prefixing an item with two underscores indicates it is private, and it should not be used anywhere except within the class it was defined.<sup>1</sup></li> <li>Prefixing an item with one underscore indicates it is protected, and it should not be used anywhere outside the class or any of it's subclasses.</li> <li>No underscore indicates the item is public.</li> </ul> <p>The other problem Object Orientation sought to address was the practice of copy-and-pasting chunks of code that provide similar functionality.</p> <p>This problem was tackled by introducing the concept of \"inheritance\".  One class can be \"derived\" from another class, and the \"derived\" subclass will \"inherit\" all of the code defined in the class it is \"derived\" from.</p> <p>We can take a look at how this works by working our way backwards through an inheritance tree.</p> <pre><code># standard library imports\nimport os\n\n# repository imports\nfrom long_term_storage.repository.shell.delimited import SpaceDelimited\n\n# application imports\nfrom long_term_storage.model.connection.postgresql import ServicePrincipal\n\n# local imports\nfrom .command import Command\n\n\nclass PgDump(Command):\n    \"\"\"\n    Interacting with pg_dump.\n    \"\"\"\n\n    @classmethod\n    def dump_data(cls, *, connection_model: ServicePrincipal, path: str):\n        \"\"\"\n        Pulls a SQL rendering of the data in the database to path.\n\n        raises:\n            Exception: If exit code is not zero.\n        \"\"\"\n        command = SpaceDelimited(\n            line=(\n                \"pg_dump\",\n                \"-h\",\n                connection_model.host,\n                \"-p\",\n                str(connection_model.port),\n                \"-U\",\n                connection_model.service_principal_id,\n                \"--no-owner\",\n                \"--data-only\",\n                connection_model.database,\n                \"--file\",\n                path,\n            )\n        )\n\n        cls.execute(command=command, connection_model=connection_model)\n\n    @classmethod\n    def dump_roles(cls, *, connection_model: ServicePrincipal, path: str):\n        \"\"\"\n        Pulls a SQL rendering of the roles in the database to path.\n\n        raises:\n            Exception: If exit code is not zero.\n        \"\"\"\n        command = SpaceDelimited(\n            line=(\n                \"pg_dumpall\",\n                \"-h\",\n                connection_model.host,\n                \"-p\",\n                str(connection_model.port),\n                \"-U\",\n                connection_model.service_principal_id,\n                \"--quote-all-identifiers\",\n                \"--no-role-passwords\",\n                \"--roles-only\",\n                \"--file\",\n                path,\n            )\n        )\n\n        cls.execute(command=command, connection_model=connection_model)\n\n    @classmethod\n    def dump_schema(cls, *, connection_model: ServicePrincipal, path: str):\n        \"\"\"\n        Pulls a SQL rendering of the schema for the database to path.  Ownership is not backed up.\n\n        raises:\n            Exception: If exit code is not zero.\n        \"\"\"\n        command = SpaceDelimited(\n            line=(\n                \"pg_dump\",\n                \"-h\",\n                connection_model.host,\n                \"-p\",\n                str(connection_model.port),\n                \"-U\",\n                connection_model.service_principal_id,\n                \"--no-owner\",\n                \"--schema-only\",\n                connection_model.database,\n                \"--file\",\n                path,\n            )\n        )\n\n        cls.execute(command=command, connection_model=connection_model)\n\n    @classmethod\n    def execute(cls, *, command: SpaceDelimited, connection_model: ServicePrincipal):\n        \"\"\"\n        Executes a pg_dump statement.\n        \"\"\"\n        env = os.environ\n        env[\"PGSSLMODE\"] = \"require\"\n        env[\"PGPASSWORD\"] = connection_model.token.get_secret_value()\n\n        super().execute(\n            command=command,\n            env=env,\n        )\n</code></pre> <p>This is a Repository layer class that implements interactions with pg_dump--the command line tool for backing up PostgreSQL databases.</p> <p>In the line that declares the class:</p> <pre><code>class PgDump(Command):\n</code></pre> <p>The parenthetical component indicates the class is derived from the Command class, so, looking at the definition of Command (in an IDE, you would right-click on \"Command\" and select \"Go to Definition\"):</p> <pre><code># standard library imports\nfrom datetime import datetime, UTC\nfrom os import environ, _Environ\nimport subprocess\n\n\n# repository imports\nfrom state_machine import AbstractRepository\nfrom long_term_storage.repository.shell.delimited import SpaceDelimited\n\n\nclass Command(AbstractRepository):\n    \"\"\"\n    Base class for executing command line actions.\n    \"\"\"\n\n    @classmethod\n    def execute(\n        cls,\n        *,\n        command: SpaceDelimited,\n        cwd: str | None = None,\n        env: _Environ = environ,\n        text: bool = True,\n        start_new_session: bool = False,\n        input: str | None = None,\n    ) -&gt; subprocess.CompletedProcess[str]:\n        \"\"\"\n        Executes the command line action.\n\n        raises:\n            Exception: If exit code is not zero.\n        \"\"\"\n        start_time = datetime.now(UTC)\n        cls.logger.debug(f\"  {command} - Started\")\n\n        result = subprocess.run(\n            command.as_list(),\n            capture_output=True,\n            env=env,\n            cwd=cwd,\n            text=text,\n            start_new_session=start_new_session,\n            input=input,\n        )\n\n        end_time = datetime.now(UTC)\n        if result.returncode != 0:\n            cls.logger.debug(\n                f\"  {command} - Error: {result.returncode} - Runtime: {end_time - start_time}\"\n            )\n            raise Exception(result.stderr)\n\n        cls.logger.debug(f\"  {command} - Completed - Runtime: {end_time - start_time}\")\n\n        return result\n</code></pre> <p>We have a general purpose definition of the \"execute\" method that works for all Repositories that require executing command-line actions.  The reason we don't want to re-implement this code in each individual Repository class is because there is standardized debug logging behavior we want all of the command-line interactions to use.  Were the logging code to be separately implemented in each Repository class, it wouldn't be \"standardized\".  Changing the \"standard\" or implementing a new command-line Repository would give plenty of opportunity for the code to drift away from the \"standard\".</p> <p>Now then, looking at the class definition:</p> <pre><code>class Command(AbstractRepository):\n</code></pre> <p>We see that Command itself is subclassed from AbstractRepository, so we'll take a quick look at the definition of AbstractRepository.</p> <pre><code># standard library imports\nfrom typing import Any\n\n# local imports\nfrom .logger import Logger\n\n\nclass AbstractRepository:\n    \"\"\"\n    Abstract base class for repositories.\n\n    *logger* will be injected when accessing a repository action from a Dependency set of repositories for a machine.\n    \"\"\"\n\n    logger: Logger\n\n    @classmethod\n    def execute(cls) -&gt; Any:\n        \"\"\"\n        Needs to be overriden in subclasses.  All actions taken by a repository should be executed in this method as\n        this is the assumed mocking point for unit tests.\n        \"\"\"\n        raise NotImplementedError()\n</code></pre> <p>The purpose of AbstractRepository is to support some rather down-in-the-weeds functionality that injects a logger object into a Repository class when it is used.</p> <p>Interpreting AbstractRepository tells us that anything inheriting AbstractRepository will receive a logger property and be expected to implement an \"execute\" method.  What makes AbstractRepository \"abstract\" is that there isn't an implementation for the execute method.  In and of itself, this class doesn't do anything but identify one of its derivative classes as something that is coming from the Repository layer.</p> <p>So the inheritance chain is:</p> <ul> <li>AbstractRepository provides the logger.</li> <li>Command provides a generalized implementation of the execute method.</li> <li>PgDump provides a specific implementation of the execute method to meet the additional requirements of pg_dump.</li> </ul> <p>Which brings us to another Object Oriented concept, which is re-using parts of a class.  There are two ways of modifying the behavior of a class in a subclass.</p> <ul> <li>Extention: Adding new methods.</li> <li>Override: Changing the behavior of an inherited method.</li> </ul> <p>The PgDump class exhibits both of these methods.  The dump_data and dump_schema methods are extentions of the Command class.  The execute method is an override of the execute method inherited from the Command class.</p> <p>Taking a closer look at the execute method:</p> <pre><code>    @classmethod\n    def execute(cls, *, command: SpaceDelimited, connection_model: ServicePrincipal):\n        \"\"\"\n        Executes a pg_dump statement.\n        \"\"\"\n        env = os.environ\n        env[\"PGSSLMODE\"] = \"require\"\n        env[\"PGPASSWORD\"] = connection_model.token.get_secret_value()\n\n        super().execute(\n            command=command,\n            env=env,\n        )\n</code></pre> <p>We see that there was a modification in the calling parameters.  Command.execute has many parameters that are needed for the general functioning purposes, but of those, command is the only one needed one that is needed by the use case in PgDump.  However, pg_dump needs to be able to provide a password to authenticate with the PostgreSQL instance, so we needed an additional parameter to be able to provide that functionality.</p> <p>env[\"PGPASSWORD\"] = connection_model.token.get_secret_value() is where that is being used--the connection_model represents a Service Principal, and the \"token\" part of connection_model will go authenticate the Service Principal with Entra Id and fetch a token that will be used to authenticate with PostgreSQL, which is passed to the command-line interaction as an environmental variable.</p> <p>The version of execute defined in Command is then called by using the special built-in function called super, which says \"using the class variables and method definitions in the subclass, execute the code code of the method as it is defined in the super-class\".</p> <p>Additionally, pg_dump defaults to trying to establish a non-ssl connection to PostgreSQL which will fail, so we setup requiring ssl using a PostgreSQL environmental variable for the bash sub-process to execute the pg_dump command.</p> <p>There is one final piece of magic, which is the @classmethod decorator.</p> <p>All Object Oriented languages provide two kinds of methods:</p> <ul> <li>Instance methods: Methods that can only be called on an instantiated instance of a class.  These methods have full access to everything defined in the class, and they are inherited by subclasses.</li> <li>Static methods: Methods that can be called without instantiating the class.  These methods do not have access to anything defined in the class, and they are not inherited (they act like old-fashioned functions).</li> </ul> <p>Python provides a type of method that is in between those two:  classmethods.  They can be called without instantiating the class, but they have access to properties defined at the class level (in this example, the logger object inherited from AbstractRepository).  They also have access to other classmethods defined in the class.  But most importantly, they can be inherited, so you can extend and override the same way you would with instance methods without having to re-implement everything the way you would with static methods.  In general, the usage of classmethods rather than static methods is preferred.</p> <p>And this brings us to one final Object Oriented concept:  \"instantiation\".</p> <p>Instantiation is the creation of a new object.  All object oriented languages support the concept of a \"constructor\" which provides the initialization of the class when it is instantiated.  In Python, the constructor is a special method called \"__init__\".</p> <p>Looking at a classic Object Oriented example:</p> <pre><code>import json\n\nclass Animal:\n    @classmethod\n    def from_json(cls, json_document):\n        instantition_info = json.loads(json_document)\n        return cls(\n            sound=instantiation_info[\"sound\"],\n            number_of_toes=instantiation_info[\"number_of_toes\"]\n        )\n\n    @classmethod\n    def what_am_id(cls):\n        return cls.__name__\n\n    def __init__(self, sound, number_of_toes):\n        self._sound = sound\n        self._number_of_toes = number_of_toes\n\n    def make_sound(self):\n        return self._sound\n\n    def how_many_toes(self):\n        return self._number_of_toes\n\nclass Dog(Animal):\n    def __init__(self, sound=\"bark\", number_of_toes=20):\n        super().__init__(sound=sound, number_of_toes=number_of_toes)\n\nclass Cat(Animal):\n    def __init__(self, sound=\"meow\", number_of_toes=20):\n        super().__init__(sound=sound, number_of_toes=number_of_toes)\n</code></pre> <p>To instantiate a Dog, we would code it as:</p> <pre><code>&gt;&gt;&gt; dog = Dog()\n&gt;&gt;&gt; print(dog.make_sound())\nbark\n&gt;&gt;&gt; print(dog.how_many_toes())\n20\n</code></pre> <p>The classmethods are accessible on either the instance level or the class level:</p> <pre><code>&gt;&gt; print(Dog.what_am_i())\nDog\n&gt;&gt;&gt; dog = Dog()\n&gt;&gt;&gt; print(dog.what_am_id())\nDog\n</code></pre> <p>However, calling an \"instance\" method that hasn't been instantiated will produce an error, because without instantiation, the \"self\" context doesn't exist.</p> <pre><code>&gt;&gt;&gt; Dog.make_sound()\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nTypeError: Dog.make_sound() missing 1 required positional argument: 'self'\n</code></pre> <p>This is telling us that the method expected to be called with \"self\" as the first parameter.  Under the hood, when Python calls an instance method on an instantiated object, it automatically includes the \"self\" context of the class as the first parameter.<sup>2</sup></p> <p>When a class is used as a \"callable\"--parenthesis tacked on to the end of it--Python will execute the __init__ method. That's \"instantiating\" the class. An instantiated class is known as an \"object\", and that's where the \"Object\" in \"Object Oriented\" comes from.</p> <p>We have two classmethods, and looking at the last one first:</p> <pre><code>&gt;&gt;&gt; print(Animal.what_am_i())\nAnimal\n&gt;&gt;&gt; print(Dog.what_am_i())\nDog\n&gt;&gt;&gt; print(Cat.what_am_i())\nCat\n</code></pre> <p>Obiously, it's that's a trivial thing to do, but it does demonstrate inheritance of classmethods.</p> <p>The more common use case is is the other classmethod:  from_json.  This is what's know as a Factory<sup>3</sup>.  Factories wrap up commonly used ways of instantiating objects using alternative parameters to the ones provided by the constructor.</p> <p>In this case, we wanted to be able to instantiate an Animal from a json document.</p> <pre><code>&gt;&gt;&gt; seven_toed_cat = '{\"sound\": \"meow\", \"number_of_toes\": 28}'\n&gt;&gt;&gt; cat = Cat.from_json(json_document=seven_toed_cat)\n&gt;&gt;&gt; print(cat.make_sound())\nmeow\n&gt;&gt;&gt; print(cat.number_of_toes())\n28\n</code></pre> <p>Another thing to note about methods and functions in general is the definition of default values.  For example, in the Dog class, we provided default values for the characteristics of a dog that are going to be true for most dogs.</p> <pre><code>    def __init__(self, sound=\"bark\", number_of_toes=20):\n</code></pre> <p>Had we not wanted to provide default values, the Animal tree could have been simplified:</p> <pre><code>import json\n\nclass Animal:\n    @classmethod\n    def from_json(cls, json_document):\n        instantition_info = json.loads(json_document)\n        return cls(\n            sound=instantiation_info[\"sound\"],\n            number_of_toes=instantiation_info[\"number_of_toes\"]\n        )\n\n    @classmethod\n    def what_am_id(cls):\n        return cls.__name__\n\n    def __init__(self, sound, number_of_toes):\n        self._sound = sound\n        self._number_of_toes = number_of_toes\n\n    def make_sound(self):\n        return self._sound\n\n    def how_many_toes(self):\n        return self._number_of_toes\n\nclass Dog(Animal):\n    \"\"\"Represents a dog.\"\"\"\n\nclass Cat(Animal):\n    \"\"\"Represents a cat.\"\"\"\n</code></pre> <p>The thing to note is that the implementations for __init__ are absent from Dog and Cat.  You don't have to implement a constructor unless the behavior of the constructor differs from the one inherited from the super-class.</p> <p>Now, it's also possible to question why we would implement empty classes that don't differ from the super-class.  And, indeed, we could have implemented Animal as:</p> <pre><code>import json\n\nclass Animal:\n    @classmethod\n    def from_json(cls, json_document):\n        instantition_info = json.loads(json_document)\n        return cls(\n            sound=instantiation_info[\"sound\"],\n            number_of_toes=instantiation_info[\"number_of_toes\"],\n            animal_type=instantiation_info[\"animal_type\"]\n        )\n\n    def __init__(self, sound, number_of_toes, animal_type):\n        self._sound = sound\n        self._number_of_toes = number_of_toes\n        self._animal_type =  animal_type\n\n    def make_sound(self):\n        return self._sound\n\n    def how_many_toes(self):\n        return self._number_of_toes\n\n    def what_am_id(cls):\n        return self._animal_type\n</code></pre> <p>The reason for treating \"animal type\" as a class rather than a characteristic is that the code is often much more concise and less error prone when you can move information about the problem domain into the type system.</p> <p>Say we wanted to add Fish to our pantheon of animals and wanted to know if the animal could breathe under water.  The version with the empty classes would become:</p> <pre><code>from abc import abstractmethod\nimport json\n\nclass AbstractAnimal:\n    @classmethod\n    def from_json(cls, json_document):\n        instantition_info = json.loads(json_document)\n        return cls(\n            sound=instantiation_info[\"sound\"],\n            number_of_toes=instantiation_info[\"number_of_toes\"]\n        )\n\n    @classmethod\n    def what_am_id(cls):\n        return cls.__name__\n\n    def __init__(self, sound, number_of_toes):\n        self._sound = sound\n        self._number_of_toes = number_of_toes\n\n    @abstractmethod\n    def can_breathe_under_water(self):\n        \"\"\"Needs to be implemeted in subclasses.\"\"\"\n\n    def make_sound(self):\n        return self._sound\n\n    def how_many_toes(self):\n        return self._number_of_toes\n\nclass Dog(AbstractAnimal):\n    \"\"\"Represents a dog.\"\"\"\n\n    def can_breathe_under_water(self):\n        return \"No\"\n\nclass Cat(AbstractAnimal):\n    \"\"\"Represents a cat.\"\"\"\n\n    def can_breathe_under_water(self):\n        return \"No\"\n\nclass Fish(AbstractAnimal):\n    \"\"\"Represents a fish.\"\"\"\n\n    def can_breathe_under_water(self):\n        return \"Yes\"\n</code></pre> <p>Comparing that to a single-Animal-with-animal-type implementation:</p> <pre><code>import json\n\nclass Animal:\n    @classmethod\n    def from_json(cls, json_document):\n        instantition_info = json.loads(json_document)\n        return cls(\n            sound=instantiation_info[\"sound\"],\n            number_of_toes=instantiation_info[\"number_of_toes\"],\n            animal_type=instantiation_info[\"animal_type\"]\n        )\n\n    def __init__(self, sound, number_of_toes, animal_type):\n        self._sound = sound\n        self._number_of_toes = number_of_toes\n        self._animal_type =  animal_type\n\n    def can_breathe_under_water(self):\n        if self._animal_type == \"Dog\":\n            return \"No\"\n        elif self._animal_type == \"Cat\":\n            return \"No\"\n        elif self._animal_type == \"Fish\":\n            return \"Yes\"\n        else:\n            raise Exception(f\"Unknown animal type {self._animal_type}\")\n\n    def make_sound(self):\n        return self._sound\n\n    def how_many_toes(self):\n        return self._number_of_toes\n\n    def what_am_id(cls):\n        return self._animal_type\n</code></pre> <p>There are a number of problems with this implementation of can_breate_under_water.  It will continue to grow and become unwieldy as we add more animal types.  But the most egregious flaw is that it's very fragile.  The static type checker is not going to be able to let you know when you introduce an error into your code, which is easy to do with this kind of implementation.</p> <pre><code>&gt;&gt;&gt; fish = Animal(sound=\"glup\", number_of_toes=0, animal_type=\"fish\")\n&gt;&gt;&gt; fish.can_breathe_under_water()\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\n  File \"/home/daniel.mcrae/develop/long-term-storage/animal.py\", line 26, in can_breathe_under_water\n    raise Exception(f\"Unknown animal type {self._animal_type}\")\nException: Unknown animal type fish\n</code></pre> <p>When first looking at an Object Oriented code base, it's going to look like a splattered mess.  Object Orientation involves placing the functionality in a lot of different files, and usually, the base class definitions are not going to reside in the same directory as the sub-classed code that makes use of the base classes.  This is because the base class functionality is used in many different places throughout the code base.  There will be an overarching organizational scheme that facilitates figuring out what is supposed to live where (although if the code base has been around for a decade, you will probably find there are multiple organizational schemes layered on top each other--in which case, the code base genuinely is a splattered mess that will be difficult to learn).</p> <p>As some general guidelines:</p> <ul> <li>If you find yourself copy-and-pasting similar functionality, think about parameterizing the functionality and putting it into a base class.  Python supports multiple inheritance, so you can mix-and-match functionality with \"mix-ins\".  \"class Dog(AbstractAnimal, CanRunMixin)\" inherits both the functionality of AbstractAnimal and the functionality describing animals that can run.</li> <li>If you find yourself generating a lengthy if ... elif ... elif ... else ... based on a property in a class, that property may be better implemented as individual types (in general, anything that allows static typing to catch potential implementation errors is the preferred approach).</li> <li>It is important to learn the pre-existing organizational scheme for the code base, and abide by it even if you think there is a better way of organizing the code.</li> <li>Right-click \"Go to Definition\" is your friend.</li> </ul> <ol> <li> <p>Python did implement name mangling for things prefixed with two underscores, so \"private\" is kind of enforced--you have to jump through some non-trivial introspective magic to get access to a \"private\" item outside of the class it's defined in. However, private was one of those things that made sense on a conceptual level, but in practice, it may not have been such a good idea.  Usage of it has led to the generation of copious amounts of redundant code.  The two lines of code you needed to modify to extend a class to suit you needs becomes hundreds of lines of code simply because the item you needed access to couldn't be reached by the subclass.  Because \"private\" is not really private in Python, and people are going to perform the ugly introspective magic rather than re-implement the entire class, the preference is to stick with \"protected\" and \"public\".\u00a0\u21a9</p> </li> <li> <p>Technically, we could call the method if we provided a self context from another instantiated object, however, the use cases for doing that are very limited, and in general there is probably a better way of doing whatever you are trying to do.\u00a0\u21a9</p> </li> <li> <p>The \"all instantiations must be performed using factories\" aspect of the Factory Pattern does not apply to Python.  Fortunately, Python was late enough to the Object Oriented party to recognize that the introduction of the \"new\" keywork used in other languages for instantiation was a mistake.  Using the Factory Pattern is the only way to instantiate objects--the constructor is just the default Factory.\u00a0\u21a9</p> </li> </ol>"},{"location":"framework/repositories.html","title":"Repositories","text":"<p>One of the key organizational elements in a code base is differentiating between code whose behavior is completely under your control and the code that depends on external systems, which may or may not do what you want them to.</p> <p>External systems are anything that can fail for reasons unrelated to your code:  File systems, calls across a network, databases, APIs...</p> <p>Interactions with external systems are placed in the Repository layer.  The reason for doing this is testability.  You cannot setup a testing environment where you could test all of the possible ways a network connection could fail, so you isolate the code that depends on interacting with things across a network, and in the unit tests, you simulate networking failures through what is known as \"mocking\".  In the tests, the Repository layer code is replaced with code that simulates both successful interactions and failing interactions with the external system.</p> <p>Code in the repository layer is stupid in the sense that it does not make any decisions.  It simply receives a request, forwards the request to the external system, and returns the results.  It doesn't attempt to interpret what is going on.  All of the meaningful interpretations of the interactions with the external system and decisions about what to do next take place in the Service layer.</p> <p>Looking at an example:</p> <pre><code># standard library imports\nimport os\nimport subprocess\n\n# application imports\nfrom long_term_storage.repository.shell.delimited import SpaceDelimited\n\n# local imports\nfrom .command import Command\n\n\nclass Tar(Command):\n    \"\"\"\n    Interations with tar.\n    \"\"\"\n\n    @classmethod\n    def cjf_with_removal(\n        cls, *, directory_to_run_in: str, directory_to_tar: str, tarball: str\n    ):\n        \"\"\"\n        Tars the directory specified by *directory_to_tar* located in *intermediate_path* to the tarball specified by *tarball*.\n        Uses bzip compression and removes *directory_to_tar* when complete.  Runs in the working directory specified by\n        *directory_to_run_in*.\n\n        raises:\n            Exception: If exit code is not zero.\n        \"\"\"\n        command = SpaceDelimited(\n            line=(\"tar\", \"-cjf\", directory_to_tar, tarball, \"--remove-files\")\n        )\n\n        cls.execute(command=command, cwd=directory_to_run_in)\n\n    @classmethod\n    def xjf(cls, *, tarball: str, path: str):\n        \"\"\"\n        Untars the tarball specified by *file_name* to the location specified by *path*.  Expects a tarball with bzip compression.\n\n        raises:\n            Exception: If exit code is not zero.\n        \"\"\"\n        command = SpaceDelimited(line=(\"tar\", \"-xjf\", tarball, \"-C\", path))\n\n        cls.execute(command=command)\n</code></pre> <p>This is a Repository for interacting with the tar command line tool.  The first thing we see is \"class Tar(Command)\" is inheriting the Command class, so we'll take a look at the definition of Command.</p> <pre><code># standard library imports\nfrom datetime import datetime, UTC\nfrom os import environ, _Environ\nimport subprocess\n\n\n# repository imports\nfrom state_machine import AbstractRepository\nfrom long_term_storage.repository.shell.delimited import SpaceDelimited\n\n\nclass Command(AbstractRepository):\n    \"\"\"\n    Base class for executing command line actions.\n    \"\"\"\n\n    @classmethod\n    def execute(\n        cls,\n        *,\n        command: SpaceDelimited,\n        cwd: str | None = None,\n        env: _Environ = environ,\n        text: bool = True,\n        start_new_session: bool = False,\n        input: str | None = None,\n    ) -&gt; subprocess.CompletedProcess[str]:\n        \"\"\"\n        Executes the command line action.\n\n        raises:\n            Exception: If exit code is not zero.\n        \"\"\"\n        start_time = datetime.now(UTC)\n        cls.logger.debug(f\"  {command} - Started\")\n\n        result = subprocess.run(\n            command.get_secret_value(),\n            capture_output=True,\n            env=env,\n            cwd=cwd,\n            text=text,\n            start_new_session=start_new_session,\n            input=input,\n        )\n\n        end_time = datetime.now(UTC)\n        if result.returncode != 0:\n            cls.logger.debug(\n                f\"  {command} - Error: {result.returncode} - Runtime: {end_time - start_time}\"\n            )\n            raise Exception(result.stderr)\n\n        cls.logger.debug(f\"  {command} - Completed - Runtime: {end_time - start_time}\")\n\n        return result\n</code></pre> <p>The Command class is inheriting AbstractRepository, we'll take a quick look at that as well.</p> <pre><code># standard library imports\nfrom typing import Any\n\n# local imports\nfrom .logger import Logger\n\n\nclass AbstractRepository:\n    \"\"\"\n    Abstract base class for repositories.\n\n    *logger* will be injected when accessing a repository action from a Dependency set of repositories for a machine.\n    \"\"\"\n\n    logger: Logger\n\n    @classmethod\n    def execute(cls) -&gt; Any:\n        \"\"\"\n        Needs to be overriden in subclasses.  All actions taken by a repository should be executed in this method as\n        this is the assumed mocking point for unit tests.\n        \"\"\"\n        raise NotImplementedError()\n</code></pre> <p>AbstractRepository is the base class for all Repositories.  It has three purposes:</p> <ul> <li>Make sure a Repository has access to the application's logger.</li> <li>Centralizes the \"go do something\" code in the execute method (gives us a place to standardize the debug logging for a Repository).</li> <li>Allows for identification of a Repository class as implementing a Repository, because there is some run-time dependency injection we will want to do for Repositories (covered in the Dependency Injection section).</li> </ul> <p>To serve these purposes, it provides a logger property and an abstract method called execute.</p> <p>Also, another thing to note is that we are using classmethods to implement the Respositories.  The Repository classes do not need to be instantiated.  The only encapsulated contextual item they contain is the logger, which should be they same for any given application.</p> <p>Moving back to the Command class, the execute method has been given a concrete implementation of the abstract method inherited from AbstractRepository.</p> <pre><code>    @classmethod\n    def execute(\n        cls,\n        *,\n        command: SpaceDelimited,\n        cwd: str | None = None,\n        env: _Environ = environ,\n        start_new_session: bool = False,\n        input: str | None = None,\n    ) -&gt; subprocess.CompletedProcess[str]:\n        \"\"\"\n        Executes the command line action.\n\n        raises:\n            Exception: If exit code is not zero.\n        \"\"\"\n        start_time = datetime.now(UTC)\n        cls.logger.debug(f\"  {command} - Started\")\n\n        result = subprocess.run(\n            command.get_secret_value(),\n            capture_output=True,\n            env=env,\n            cwd=cwd,\n            start_new_session=start_new_session,\n            input=input,\n        )\n\n        end_time = datetime.now(UTC)\n        if result.returncode != 0:\n            cls.logger.debug(\n                f\"  {command} - Error: {result.returncode} - Runtime: {end_time - start_time}\"\n            )\n            raise Exception(result.stderr)\n\n        cls.logger.debug(f\"  {command} - Completed - Runtime: {end_time - start_time}\")\n\n        return result\n</code></pre> <p>The execute method generalizes interacting with command line tools and standardizes the debug logging for such interactions.  It has a number of parameters that are needed to support the different needs of different tools.</p> <ul> <li>command is the only required parameter, and it expects to receive a SpaceDelimited object.</li> <li>env is the set of environmental variables that will be available to the command line tool. Defaults to the same environment the calling process has.</li> <li>cwd is the working directory for executing the command line tool. Defaults to the same working directory of the calling process.</li> <li>start_new_session is a flag indicating whether execution should take place as a background process (putting \"&amp;\" at the end of a command line call). Default to no.</li> <li>input is a value to be used should the command line tool prompt for more information. Placing secret information in command line parameters should be avoided if possible--all command line parameters are readable in clear text while the process is running. This parameter can sometimes be used to answer password prompts. Defaults to None.</li> </ul> <p>The first thing done is to record the start time of the action. When a system is experiencing weirdness, the ability to look at the log files and quickly determine \"that looks like it's taking too much or too little time\" without having to do calculations based on the time stamps of the entries greatly speeds up the diagnosis. Computers are good at computing, so let's just go ahead and have the computer do the calculations and report the how long things took to execute in the log.</p> <p>Next we use Python's subprocess.run function to submit the request to the OS, which bypasses the need to worry about the escaping, quoting, and all of the other nastiness encountered when trying to craft dynamic bash commands.</p> <p>We check the exit code, and if it isn't zero, we raise and exception with the contents of stderr as the message.  This is not appropriate behavior for all command line tools.  Some are not posix compliant and have non-zero exit-codes that actually succeeded.  It's also possible that some may place sensitive information in stderr that should not be logged.  If a command line tool is found that exhibits either of these behaviors, the execute method will need to be overriden in the Repository class to accommodate the unexpected behavior ot the command line tool.</p> <p>Finally, we log the runtime and return the result, which will include the contents of stdout.</p> <p>So, moving back to our original Repository example, the Tar class, let's take a look at the first method.</p> <pre><code>    @classmethod\n    def cjf_with_removal(\n        cls, *, directory_to_run_in: str, directory_to_tar: str, tarball: str\n    ):\n        \"\"\"\n        Tars the directory specified by *directory_to_tar* located in *directory_to_run_in* to the tarball specified by *tarball*.\n        Uses bzip compression and removes *directory_to_tar* when complete.  Runs in the working directory specified by\n        *directory_to_run_in*.\n\n        raises:\n            Exception: If exit code is not zero.\n        \"\"\"\n        command = SpaceDelimited(\n            line=(\"tar\", \"-cjf\", directory_to_tar, tarball, \"--remove-files\")\n        )\n\n        cls.execute(command=command, cwd=directory_to_run_in)\n</code></pre> <p>The parameters are:</p> <ul> <li>directory_to_run_in: tar records the full path of what is being tarred, and since when we use this file in a restore process, we want it to untar to a different directory path than where it was during the backup, the only thing we want in the tarball path is just the directory that is being tarred.  To accomplish that, tar will need to be executed in the directory the directory being tarred lives in.  This parameter provides the working directory to use when invoking tar.</li> <li>directory_to_tar is the name of the directory we will be tarring.</li> <li>tarball is the name of the resulting tarball file.</li> </ul> <p>The command line that will be executed is something like:</p> <pre><code>tar -cjf some-directory-that-is-being-tarred tarball.tbz --remove-files\n</code></pre> <p>The cjf parameter means:</p> <ul> <li>c: We're creating a tarball.</li> <li>j: Use bzip for compression.</li> <li>f: The next parameter will be what wer are tarring.</li> </ul> <p>The --remove-files tells tar to remove the directory that was tarred after tarring has completed.</p> <p>We then call the execute method supplying the command line definition and setting cwd for the process to the directory we want tar to think it's running in.</p> <p>The second method is for untarring.</p> <pre><code>    @classmethod\n    def xjf(cls, *, tarball: str, path: str):\n        \"\"\"\n        Untars the tarball specified by *file_name* to the location specified by *path*.  Expects a tarball with bzip compression.\n\n        raises:\n            Exception: If exit code is not zero.\n        \"\"\"\n        command = SpaceDelimited(line=(\"tar\", \"-xjf\", tarball, \"-C\", path))\n\n        cls.execute(command=command)\n</code></pre> <p>The parameters are:</p> <ul> <li>tarball is the name of the tar file to be untarred.</li> <li>path is directory the untarred results should live in.</li> </ul> <p>The command line that will be executed is something like:</p> <pre><code>tar -xjf tarball.tbz -C /path/to/some/location\n</code></pre> <p>The parameters for tar are:</p> <ul> <li>x: We're extracting contenets from a tarball.</li> <li>j: The tarball was compressed using bzip.</li> <li>f: The next parameter will be the name of the tarball.</li> <li>C: We will be untarring to a different location than it was originally tarred from.</li> </ul>"},{"location":"framework/services.html","title":"Services","text":"<p>The services contain the parts of the code that decide what should be done, and once that decision has been made, they invoke one or more repositories to go out and perform the actions.</p> <p>The services are built with state-machines using the result pattern (the outcome of trying to do something is either Success or Failure).  A state-machine is just a collection of \"nodes\" that, depending on the outcome of the node's action, will transition to a different node to be executed.  That's the machine.</p> <p>The \"state\" is a collection of variables that allow the nodes to communicate with each other and make decisions about what to do next.</p> <p>Visually, a state-machine is depicted in the diagram below (this is the process for backing up and encrypting the backup of a database).  The green arrows represent the \"happy path\"--what happens if everything processes as expected.  The red arrows are \"unhappy paths\"--what happens when, for some reason, the action could not be performed.</p> <p>The reason for explicitly separating the code into happy and unhappy paths is this is an automated system that is intended to run without baby-sitting.  Any time something unexpected happens that prevents execution of the happy path, the system needs to generate an alert to escalate the problem to a human being for investigation.  That behavior is easiest to generalize as follow-an-unhappy-path, generate-an-alert.</p> <p>Also, what might be apparent in the diagram is that the implementation is quite granular.  Each node is only executing one action that may or may not succeed.</p> <p>The reason for this level of granularity is that a well built automated system can run for years without any problems.  During that time, everybody will forget the system even exists, so when something does go wrong, there will be a reverse-engineering effort involved in figuring out what happened and what needs to be done about it.  The reverse-engineering effort can be greatly facilitated by failure reports that tell you exactly which step(s) failed, and, by looking at the diagram, you can determine what state the system was left in as a result of the failure(s).</p> <p>Each service is composed of one or more machines.</p> <p></p> <p>The happy-path process for this backup-and-encrypt state-machine is:</p> <ol> <li>Create an intermediate working directory in the storage area.</li> <li>Create the directory to dump the SQL files to.</li> <li>Use pgdump to pull a backup of the schema to the intermediate area.</li> <li>Use pgdump to pull a backup of the data to the intermediate area.</li> <li>Use tar to unify, compress and remove the intermediate backup directory.</li> <li>Use gpg to encrypt the tar file.</li> <li>Create the long term storage directory in the storage area.</li> <li>Move the encrypted file to the long term storage directory.</li> <li>Clean up intermediate directory.</li> <li>Report the Success/Failure outcomes back to the where ever it was called from.</li> </ol> <p>Step 9 (starting at remove_encrypted_backup) has been broken into six separate steps to accommodate the unhappy-path behavior in the previous steps. In the event any of them failing, we want to make sure there is no unencrypted data hanging around, and the system is in a state where, if we re-run the backup, there is nothing from the previous run that could interfere with the re-run (the technical term for this is indempodent).</p>"},{"location":"framework/services.html#state-machines","title":"State Machines","text":"<p>The implementation of a state-machine has three components:</p> <ul> <li>State: A data object contatining the state variables.</li> <li>Dependencies: A data object containing the repositories the state-machine will use to perform actions.</li> <li>Machine: A class implementing the nodes that compose a state-machine.</li> </ul>"},{"location":"framework/services.html#states","title":"States","text":"<p>For the state-machine depicted above, the State object is defined as:</p> <pre><code># standard library imports\nfrom datetime import datetime, UTC\n\n# third party imports\nfrom pydantic import Field\n\n# repository imports\nfrom long_term_storage.repository.key_vault import BackupConfigModel\n\n# application imports\nfrom long_term_storage.model.connection.key_vault import ServicePrincipal\nfrom state_machine import BaseState\n\n\nclass StateBackupAndEncrypt(BaseState):\n    \"\"\"\n    State variables for MachineBackupAndEncrypt.\n    \"\"\"\n\n    client_name: str = Field(frozen=True)\n    \"\"\"The name of the client being backed up.\"\"\"\n\n    backup_config: BackupConfigModel = Field(frozen=True)\n    \"\"\"The configuration information from the key vault.\"\"\"\n\n    eoy_month: int = Field(frozen=True)\n    \"\"\"The numeric representation of the end-of-year month.\"\"\"\n\n    database: str = Field(frozen=True)\n    \"\"\"The name of the database being backed up.\"\"\"\n\n    postgresql_host: str = Field(frozen=True)\n    \"\"\"The PostgreSQL instance name that will be reported back in Failures.\"\"\"\n\n    time_stamp: datetime = Field(default=datetime.now(UTC), frozen=True)\n    \"\"\"The time stamp used for building the dates in the paths.  Default to utc now.\"\"\"\n</code></pre> <p>All state classes derive from BaseState.  BaseState simply performs a little bit of configuration for what is allowed to be placed in the data model.</p> <p>Taking a look at the first entry:</p> <pre><code>    client_name: str = Field(frozen=True)\n    \"\"\"The name of the client being backed up.\"\"\"\n</code></pre> <p>In line 20, \"client_name\" is the name of the data element, \": str\" declares that it is intended to only contain string value, and \"= Field(frozen=True) declares that this data element is immutable--after instantiation of the data object, it can't be changed.</p> <p>Line 21 is a docstring explaining \"why this thing exists\".</p>"},{"location":"framework/services.html#dependencies","title":"Dependencies","text":"<p>For the state-machine depicted above, the dependencies object is defined as:</p> <pre><code># repository imports\nfrom long_term_storage.repository.file_manager import FileManager\nfrom long_term_storage.repository.gpg import Gpg\nfrom long_term_storage.repository.shell import PgDump, Tar\n\n# application imports\nfrom state_machine import BaseDependency\n\n\nclass DependencyBackupAndEncrypt(BaseDependency):\n    \"\"\"\n    Repository dependencies for MachineBackupAndEncrypt.\n    \"\"\"\n\n    create_intermediate_directory = FileManager.make_dir_if_not_exists\n    remove_intermediate_directory = FileManager.remove_directory_if_exists\n    create_pg_dump_directory = FileManager.make_dir_if_not_exists\n    remove_pg_dump_directory = FileManager.remove_directory_if_exists\n    backup_schema = PgDump.dump_schema\n    remove_schema_file = FileManager.remove_file_if_exists\n    backup_data = PgDump.dump_data\n    remove_data_file = FileManager.remove_file_if_exists\n    compress = Tar.cjf_with_removal\n    remove_tarball = FileManager.remove_file_if_exists\n    encrypt = Gpg.encrypt\n    remove_encrypted_backup = FileManager.remove_file_if_exists\n    create_storage_directory = FileManager.make_dir_if_not_exists\n    move_backup = FileManager.move\n</code></pre> <p>The purpose of the dependencies object is to facilitate unit testing.  It provides a handy inventory of what needs to be mocked.  It also provides a way of performing individual mocking behavior.  For example, in this state-machine, the \"make_dir_if_not_exists\" method is used in the first node, third, and second to last one.  Were we to set up make_dir_if_not_exists directly to fail, the other two nodes could not be tested, because the machine would always fail in the first node, and the machine would follow a failure path that skips the other two nodes.</p> <p>What's happening here is we are assigning the class methods of the repositories to data elements in the dependency object.  Then, in the machine, we will invoke the data element rather than the repository method directly.</p> <p>The convention is to prefix the name of the data element with the node name it will be used in.  In this case, there aren't any cases where more than one repository is being used by a node, so the data element names are the same as the node names.</p> <p>Docstrings are applied to the class name, so the class will be picked up by the documentation system.  However, docstrings are not applied to the data elements.  The IDE is smart enough to disentangle the indirection and provide intellisence hints based on the class method that is being referred to rather than the data element.</p> <p>For the same reason, static typing is not used for the data elements. Duck typing in this case is sufficient to make sure the parameters and return types match up as according to the class method's signature.</p>"},{"location":"framework/services.html#machines","title":"Machines","text":"<p>For the state-machine depicted above, the machine is defined as:</p> <pre><code># application imports\nfrom long_term_storage.constant.path import Path\nfrom long_term_storage.model.connection.postgresql import ServicePrincipal\nfrom state_machine.decorator import handle_exceptions, machine, node\nfrom state_machine import AbstractMachine, Transition\n\n# local imports\nfrom .state_backup_and_encrypt import StateBackupAndEncrypt\nfrom .dependency_backup_and_encrypt import DependencyBackupAndEncrypt\n\n\n@machine\nclass MachineBackupAndEncrypt(AbstractMachine):\n    \"\"\"\n    overview: |+\n        Database backups need to be pulled and encrypted.\n\n        The steps to perform this are:\n\n        1. Create an intermediate working directory in the storage area.\n        2. Create the directory to dump the SQL files to.\n        3. Use pgdump to pull a backup of the schema to the intermediate area.\n        4. Use pgdump to pull a backup of the data to the intermediate area.\n        5. Use tar to unify, compress and remove the intermediate backup directory.\n        6. Use gpg to encrypt the tar file.\n        7. Create the long term storage directory in the storage area.\n        8. Move the encrypted file to the long term storage directory.\n        9. Clean up intermediate directory.\n        10. Report the Success/Failure outcomes back to the where ever it was called from.\n    \"\"\"\n\n    @handle_exceptions(on_exception=\"remove_intermediate_directory\")\n    @node\n    def create_intermediate_directory(self) -&gt; Transition:\n        \"\"\"\n        overview:\n            Create the intermediate directory for pulling the backup.\n\n        is_entry: True\n\n        happy_paths:\n            - create_pg_dump_directory\n\n        unhappy_paths:\n            - remove_intermediate_directory\n        \"\"\"\n        DependencyBackupAndEncrypt(logger=self.logger).create_intermediate_directory(\n            path=Path.intermediate_backup_base(\n                client_name=self.state.client_name, database_name=self.state.database\n            )\n        )\n\n        return self.success(exit_to=self.create_pg_dump_directory)\n\n    @handle_exceptions(on_exception=\"report_results\")\n    @node\n    def remove_intermediate_directory(self) -&gt; Transition:\n        \"\"\"\n        overview:\n            Remove the intermediate directory.\n\n        happy_paths:\n            - report_results\n\n        unhappy_paths:\n            - report_results\n        \"\"\"\n        path = Path.intermediate_backup_base(\n            client_name=self.state.client_name, database_name=self.state.database\n        )\n        DependencyBackupAndEncrypt(logger=self.logger).remove_intermediate_directory(\n            path=path\n        )\n\n        return self.success(exit_to=self.report_results)\n\n    @handle_exceptions(on_exception=\"remove_pg_dump_directory\")\n    @node\n    def create_pg_dump_directory(self) -&gt; Transition:\n        \"\"\"\n        overview:\n            Create the intermediate directory for pg_dump to pull the backup.\n\n        happy_paths:\n            - backup_schema\n\n        unhappy_paths:\n            - remove_pg_dump_directory\n        \"\"\"\n        path = Path.intermediate_backup_directory(\n            client_name=self.state.client_name,\n            database_name=self.state.database,\n            time_stamp=self.state.time_stamp,\n        )\n        DependencyBackupAndEncrypt(logger=self.logger).create_pg_dump_directory(\n            path=path\n        )\n\n        return self.success(exit_to=self.backup_schema)\n\n    @handle_exceptions(on_exception=\"remove_intermediate_directory\")\n    @node\n    def remove_pg_dump_directory(self) -&gt; Transition:\n        \"\"\"\n        overview:\n            Remove the pg_dump directory.\n\n        happy_paths:\n            - remove_intermediate_directory\n\n        unhappy_paths:\n            - remove_intermediate_directory\n        \"\"\"\n        path = Path.intermediate_backup_directory(\n            client_name=self.state.client_name,\n            database_name=self.state.database,\n            time_stamp=self.state.time_stamp,\n        )\n        DependencyBackupAndEncrypt(logger=self.logger).remove_pg_dump_directory(\n            path=path\n        )\n\n        return self.success(exit_to=self.remove_intermediate_directory)\n\n    @handle_exceptions(on_exception=\"remove_schema_file\")\n    @node\n    def backup_schema(self) -&gt; Transition:\n        \"\"\"\n        overview:\n            Backup the schema to the intermediate area.\n\n        happy_paths:\n            - backup_data\n\n        unhappy_paths:\n            - remove_schema_file\n        \"\"\"\n        connection_model = ServicePrincipal(\n            host=self.state.client_config.postgresql_host,\n            port=self.state.client_config.postgresql_port,\n            service_principal_id=self.state.client_config.postgresql_service_principal_id,\n            client_secret=self.state.client_config.postgresql_secret,\n            database=self.state.database,\n        )\n\n        path = Path.intermediate_backup_schema_file(\n            client_name=self.state.client_name,\n            database_name=self.state.database,\n            time_stamp=self.state.time_stamp,\n        )\n\n        DependencyBackupAndEncrypt(logger=self.logger).backup_schema(\n            connection_model=connection_model, path=path\n        )\n\n        return self.success(exit_to=self.backup_data)\n\n    @handle_exceptions(on_exception=\"remove_pg_dump_directory\")\n    @node\n    def remove_schema_file(self) -&gt; Transition:\n        \"\"\"\n        overview:\n            Remove the schema file.\n\n        happy_paths:\n            - remove_pg_dump_directory\n\n        unhappy_paths:\n            - remove_pg_dump_directory\n        \"\"\"\n        path = Path.intermediate_backup_schema_file(\n            client_name=self.state.client_name,\n            database_name=self.state.database,\n            time_stamp=self.state.time_stamp,\n        )\n        DependencyBackupAndEncrypt(logger=self.logger).remove_schema_file(path=path)\n\n        return self.success(exit_to=self.remove_pg_dump_directory)\n\n    @handle_exceptions(on_exception=\"remove_data_file\")\n    @node\n    def backup_data(self) -&gt; Transition:\n        \"\"\"\n        overview:\n            Backup the data to the intermediate area.\n\n        happy_paths:\n            - compress\n\n        unhappy_paths:\n            - remove_data_file\n        \"\"\"\n        connection_model = ServicePrincipal(\n            host=self.state.client_config.postgresql_host,\n            port=self.state.client_config.postgresql_port,\n            service_principal_id=self.state.client_config.postgresql_service_principal_id,\n            client_secret=self.state.client_config.postgresql_secret,\n            database=self.state.database,\n        )\n\n        path = Path.intermediate_backup_data_file(\n            client_name=self.state.client_name,\n            database_name=self.state.database,\n            time_stamp=self.state.time_stamp,\n        )\n\n        DependencyBackupAndEncrypt(logger=self.logger).backup_data(\n            connection_model=connection_model, path=path\n        )\n\n        return self.success(exit_to=self.compress)\n\n    @handle_exceptions(on_exception=\"remove_schema_file\")\n    @node\n    def remove_data_file(self) -&gt; Transition:\n        \"\"\"\n        overview:\n            Remove the data file.\n\n        happy_paths:\n            - remove_schema_file\n\n        unhappy_paths:\n            - remove_schema_file\n        \"\"\"\n        path = Path.intermediate_backup_data_file(\n            client_name=self.state.client_name,\n            database_name=self.state.database,\n            time_stamp=self.state.time_stamp,\n        )\n        DependencyBackupAndEncrypt(logger=self.logger).remove_data_file(path=path)\n\n        return self.success(exit_to=self.remove_schema_file)\n\n    @handle_exceptions(on_exception=\"remove_tarball\")\n    @node\n    def compress(self) -&gt; Transition:\n        \"\"\"\n        overview:\n            Consolidate, compress, and remove the backup folder.\n\n        happy_paths:\n            - encrypt\n\n        unhappy_paths:\n            - remove_tarball\n        \"\"\"\n        directory_to_run_in = Path.intermediate_backup_base(\n            client_name=self.state.client_name, database_name=self.state.database\n        )\n\n        directory_to_tar = Path.intermediate_tarball_file(\n            client_name=self.state.client_name,\n            database_name=self.state.database,\n            time_stamp=self.state.time_stamp,\n        )\n\n        tarball = self.state.time_stamp.strftime(Path.TIMESTAMP_FORMAT.value)\n\n        DependencyBackupAndEncrypt(logger=self.logger).compress(\n            directory_to_run_in=directory_to_run_in,\n            directory_to_tar=directory_to_tar,\n            tarball=tarball,\n        )\n\n        return self.success(exit_to=self.encrypt)\n\n    @handle_exceptions(on_exception=\"remove_data_file\")\n    @node\n    def remove_tarball(self) -&gt; Transition:\n        \"\"\"\n        overview:\n            Remove the tarball.\n\n        happy_paths:\n            - remove_data_file\n\n        unhappy_paths:\n            - remove_data_file\n        \"\"\"\n        path = Path.intermediate_tarball_file(\n            client_name=self.state.client_name,\n            database_name=self.state.database,\n            time_stamp=self.state.time_stamp,\n        )\n        DependencyBackupAndEncrypt(logger=self.logger).remove_tarball(path=path)\n\n        return self.success(exit_to=self.remove_data_file)\n\n    @handle_exceptions(on_exception=\"remove_encrypted_backup\")\n    @node\n    def encrypt(self) -&gt; Transition:\n        \"\"\"\n        overview:\n            Encrypt the backup.\n\n        happy_paths:\n            - create_storage_directory\n\n        unhappy_paths:\n            - remove_encrypted_backup\n        \"\"\"\n        key_name = self.state.client_config.key_name\n\n        from_file = Path.intermediate_tarball_file(\n            client_name=self.state.client_name,\n            database_name=self.state.database,\n            time_stamp=self.state.time_stamp,\n        )\n\n        to_file = Path.intermediate_backup_file(\n            client_name=self.state.client_name,\n            database_name=self.state.database,\n            time_stamp=self.state.time_stamp,\n            key_name=self.state.client_config.key_name,\n        )\n\n        DependencyBackupAndEncrypt(logger=self.logger).encrypt(\n            key_name=key_name, from_file=from_file, to_file=to_file\n        )\n\n        return self.success(exit_to=self.create_storage_directory)\n\n    @handle_exceptions(on_exception=\"remove_tarball\")\n    @node\n    def remove_encrypted_backup(self) -&gt; Transition:\n        \"\"\"\n        overview:\n            Remove the encrypted backup.\n\n        happy_paths:\n            - remove_tarball\n\n        unhappy_paths:\n            - remove_tarball\n        \"\"\"\n        path = Path.intermediate_backup_file(\n            client_name=self.state.client_name,\n            database_name=self.state.database,\n            time_stamp=self.state.time_stamp,\n            key_name=self.state.client_config.key_name,\n        )\n        DependencyBackupAndEncrypt(logger=self.logger).remove_encrypted_backup(\n            path=path\n        )\n\n        return self.success(exit_to=self.remove_tarball)\n\n    @handle_exceptions(on_exception=\"remove_encrypted_backup\")\n    @node\n    def create_storage_directory(self) -&gt; Transition:\n        \"\"\"\n        overview:\n            Make sure the storage directory exists.\n\n        happy_paths:\n            - move_backup\n\n        unhappy_paths:\n            - remove_encrypted_backup\n        \"\"\"\n        path = Path.long_term_storage_directory(\n            client_name=self.state.client_name,\n            database_name=self.state.database,\n            time_stamp=self.state.time_stamp,\n            eoy_month=self.state.eoy_month,\n        )\n\n        DependencyBackupAndEncrypt(logger=self.logger).create_storage_directory(\n            path=path\n        )\n\n        return self.success(exit_to=self.move_backup)\n\n    @handle_exceptions(on_exception=\"remove_encrypted_backup\")\n    @node\n    def move_backup(self) -&gt; Transition:\n        \"\"\"\n        overview:\n            Move the encrypted backup to long-term-storage area.\n\n        happy_paths:\n            - remove_encrypted_backup\n\n        unhappy_paths:\n            - remove_encrypted_backup\n        \"\"\"\n        from_path = Path.intermediate_backup_file(\n            client_name=self.state.client_name,\n            database_name=self.state.database,\n            time_stamp=self.state.time_stamp,\n            key_name=self.state.client_config.key_name,\n        )\n\n        to_path = Path.long_term_backup_file(\n            client_name=self.state.client_name,\n            database_name=self.state.database,\n            time_stamp=self.state.time_stamp,\n            key_name=self.state.client_config.key_name,\n            eoy_month=self.state.eoy_month,\n        )\n\n        DependencyBackupAndEncrypt(logger=self.logger).move_backup(\n            from_path=from_path, to_path=to_path\n        )\n\n        return self.success(exit_to=self.remove_encrypted_backup)\n\n    @property\n    def failure_prefix(self) -&gt; str:\n        \"\"\"A message to be prepended to the failure reporting messages.\"\"\"\n        return f\"{self.state.client_name} {self.state.postgresql_host} {self.state.database}\"\n\n    @property\n    def state(self) -&gt; StateBackupAndEncrypt:\n        \"\"\"\n        Overrides base functionality of state to return the proper type for this machine.\n        \"\"\"\n        return self._state  # pyright: ignore\n</code></pre> <p>Perhaps one of the things initially notable is there is nearly as much text in the docstrings as there is code implementing what the node does.  The dosctrings describe the design of the state-machine and how the nodes are allowed to flow from one to the next.  They are used to generate the design diagram for the state-machine.  They are required.  There are both compile-time and run-time checks that guarantee the flow between nodes in the implementation matches the documented design of the state-machine.</p> <p>The approach to building the state-machine is to start with the overview section of the class-level docstring where you sketch out the off-the-top-of-your-head happy-path steps. Then nodes are stubbed out for each of the steps in the happy path, and while building the docstrings for the happy-path nodes, you put some consideration into what happens if the node is doesn't do what it is intended to do, which are the unhappy paths. The nodes are stubbed out for the unhappy paths, and documentation.document_machines is run to render the diagram.</p> <p>Once you've stared at the diagram for a while and decided the machine would do what you wanted it to, then it is time to implement the behavior of the nodes, which is usually quite trivial, since any individual node isn't supposed to do very much.</p> <p>Anyway, looking at the code, the first new item to make an appearance is the machine decorator.</p> <pre><code>@machine\nclass MachineBackupAndEncrypt(AbstractMachine):\n</code></pre> <p>Decorators in Python lines that are prefixed with an ampersand \"@\".  They call their defining function at compile-time.  The defining function will receive the decorated item as a parameter, and can perform processing based on the definition of the item.</p> <p>The @machine decorator will perform a lot of compile-time validations to make sure the state-machine definition is self-consistent--every path called out in the docstrings for the nodes have a method defined to implement them, all the implemented nodes are reachable, the entrance node is identified, and at least one terminal node is defined.</p> <p>All state-machines are inherited from AbstractMachine, which will be covered in a later episode.</p> <p>Next comes the docstring.</p> <pre><code>    \"\"\"\n    overview: |+\n        Database backups need to be pulled and encrypted.\n\n        The steps to perform this are:\n\n        1. Create an intermediate working directory in the storage area.\n        2. Create the directory to dump the SQL files to.\n        3. Use pgdump to pull a backup of the schema to the intermediate area.\n        4. Use pgdump to pull a backup of the data to the intermediate area.\n        5. Use tar to unify, compress and remove the intermediate backup directory.\n        6. Use gpg to encrypt the tar file.\n        7. Create the long term storage directory in the storage area.\n        8. Move the encrypted file to the long term storage directory.\n        9. Report the Success/Failure outcomes back to the where ever it was called from.\n    \"\"\"\n</code></pre> <p>The docstring contains a yaml description of the machine that is required to have an \"overview:\" entry--@machine will raise a NoOverviewError at compile-time if the overview section is not populated.</p> <p>Next come the node definitions.</p> <pre><code>    @handle_exceptions(on_exception=\"remove_intermediate_directory\")\n    @node\n    def create_intermediate_directory(self) -&gt; Transition:\n        \"\"\"\n        overview:\n            Create the intermediate directory for pulling the backup.\n\n        is_entry: True\n\n        happy_paths:\n            - create_pg_dump_directory\n\n        unhappy_paths:\n            - remove_intermediate_directory\n        \"\"\"\n        DependencyBackupAndEncrypt(logger=self.logger).create_intermediate_directory(\n            path=Path.intermediate_backup_base(\n                client_name=self.state.client_name, database_name=self.state.database\n            )\n        )\n\n        return self.success(exit_to=self.create_pg_dump_directory)\n</code></pre> <p>The @handle_exception decorator wraps the node in a try-block, and the on_exception parameter identifies which node will be transitioned to in the event an exception is raised while executing the code in the node.  All nodes must either be decorated with @handle_exception to define the exception handling path or @no_exceptions when the code will not raise any exceptions.</p> <p>The @node decorator identifies the method as a node and validates all of the required parts of the node docstring are present.</p> Docstring Section Description Required overview Why this node is here. Yes is_entry Indicates the node is the entry point for the machine. One per machine is_terminal Indicates the node is an exit point for the machine. At least one per machine (normally provided by return_results from the base class) happy_paths A list of the happy-path exits the node can take. If the node is not terminal and there are no unhappy_paths. unhappy_paths A list of the unhappy-path exits the node can take. If the node is not terminal and there are no happy_paths. invokes_machine Another state-machine the node may route to. No <p>So, the docstring for this node:</p> <pre><code>        \"\"\"\n        overview:\n            Create the intermediate directory for pulling the backup.\n\n        is_entry: True\n\n        happy_paths:\n            - create_pg_dump_directory\n\n        unhappy_paths:\n            - remove_intermediate_directory\n        \"\"\"\n</code></pre> <p>Is interpreted as:</p> <ul> <li>overview: We want to make sure the intermediate directory for processing backups exists.</li> <li>is_entry: This node is the entry point for the machine.</li> <li>happy_paths: The node can send Success results to create_pg_dump_directory.</li> <li>unhappy_paths: The node can send Failure results to remove_intermediate_directory.</li> </ul> <p>Finally, we have the implementation.</p> <pre><code>        DependencyBackupAndEncrypt(logger=self.logger).create_intermediate_directory(\n            path=Path.intermediate_backup_base(\n                client_name=self.state.client_name, database_name=self.state.database\n            )\n        )\n\n        return self.success(exit_to=self.create_pg_dump_directory)\n</code></pre> <p>\"DependencyBackupAndEncrypt(logger=self.logger)\" instantiates the DependencyBackupAndEncrypt data object with the system logger so the repository objects can log their messages.</p> <p>\"create_intermediate_directory\" calls the method we mapped back in the DependencyBackupAndEncrypt definition.</p> <pre><code>    create_intermediate_directory = FileManager.make_dir_if_not_exists\n</code></pre> <p>So, we're executing FileManager.make_dir_if_not_exists with the defined path parameter.</p> <p>The call to Path.intermediate_backup_base is not considered a \"repository\" call because it has no dependencies outside the service layer.  It's completely under our control, and the unit tests we built for it guarantee it will behave exactly as expected. Then we return a Success transition that specifies the next node to be executed.</p> <p>At the bottom of the class we have two properties defined.</p> <pre><code>    @property\n    def failure_prefix(self) -&gt; str:\n        \"\"\"A message to be prepended to the failure reporting messages.\"\"\"\n        return f\"{self.state.client_name} {self.state.postgresql_host} {self.state.database}\"\n\n    @property\n    def state(self) -&gt; StateBackupAndEncrypt:\n        \"\"\"\n        Overrides base functionality of state to return the proper type for this machine.\n        \"\"\"\n        return self._state  # pyright: ignore\n</code></pre> <p>These are the \"abstract\" portions of the base class. They don't have a default implementation and need to have their implementation defined on a per-machine basis.</p> <p>The first, \"failure_prefix\", is a message that will be prepended to any failure messages the machine may generate. The failures reported from a state-machine will include which node the failure occurred in, but for this machine, we would also like to know which client, PostgreSQL instance, and database name the failure is associated with.</p> <p>The second, \"state\", just changes the type returned by the state property. In the base class, the type being returned is StateBase, because the data elements for a specific state-machine aren't known by the state-machine library.  The \"# pyright: ignore\" turns off static type-checking for that line.  In the base class self._state is defined as a StateBase variable, which doesn't match up with the return value of StateBackupAndEncrypt.  However, since we know the machine will be instantiated with a StateBackupAndEncrypt object to be placed into self._state, it's safe to ignore static-typing telling us \"this isn't right\".</p>"},{"location":"framework/tests.html","title":"Unit Tests","text":"<p>Unit testing is based on pytest, which is expected to be executed within the top-level project directory.</p> <pre><code>pytest -s\n</code></pre> <p>Individual tests can be executed by specifying the tests file name.  Example:</p> <pre><code>pytest tests/state_machine/machine/test_happy_path.py -s\n</code></pre> <p>The unit tests exercise the parts of the code base that make decisions about what should be done.  They do not execute the parts of the code base that actually go out and do something.</p> <p>Within the tests directory you will find:</p> <ul> <li>constant: Unit tets of standardized templating behavior based on the constants.</li> <li>end_point: Unit tests of the End-Point layer.</li> <li>mocks: Code to emulate the parts of the code base that go out and do something.</li> <li>service: Unit tests for the code in the Service layer.</li> <li>state_machine: Unit tests for the Machine base classes.</li> </ul> <p>The directory structures for the unit tests mirror the directory structure of the long_term_storage code being tested.</p> <p>pytest discovers tests based on naming convention.  Python files beginning with \"test\" are considered to be test files that need to be executed.  Functions within the test files that begin with \"test\" are considered the test cases.</p> <p>All of the red and green paths in the diagrams need to be tested.  Additionally, any \"if\" branches within a node need to be tested.</p>"},{"location":"framework/tests.html#service-layer","title":"Service Layer","text":"<p>The sample state-machine for the testing discussion looks like:</p> <p></p> <p>The machine:</p> <ul> <li>Queries the PostgreSQL instance to get a list of databases to be backed up.</li> <li>Ensures the correct public key is installed for encryption.</li> <li>Invokes MachineBackupAndEncrypt for each of the databases to perform the backup.</li> <li>Invokes MachineEomDeletionCandidates to remove end-of-month backups that are beyond their retention period.</li> <li>Invokes MachineEoyDeletionCandidates to remove end-of-year backups that are beyond their retention period.</li> </ul> <p>The Service layer tests may contain two convience functions:</p> <ul> <li>create_machine.py: Instantiates the state-machine being tested.</li> <li>inject_machines.py: Creates mocks of other state-machines that may be invoked by the machine being tested.</li> </ul>"},{"location":"framework/tests.html#create_machine-example","title":"create_machine example","text":"<pre><code># application imports\nfrom long_term_storage.service.backup.backup_databases import (\n    MachineBackupDatabases,\n    StateBackupDatabases,\n)\n\n# mocks\nfrom tests.mocks import MockBackupConfigModel, MockLogger\n\n\ndef create_machine(eoy_month: int = 1) -&gt; MachineBackupDatabases:\n    \"\"\"\n    Create a machine for testing.\n    \"\"\"\n    logger = MockLogger()\n\n    return MachineBackupDatabases(\n        logger=logger,\n        state=StateBackupDatabases(\n            client_name=\"test_client_name\",\n            backup_config=MockBackupConfigModel(),\n            eoy_month=eoy_month,\n        ),\n    )\n</code></pre> <p>create_machine returns an instance of the machine being tested.  This version has been parameterized with eoy_month, which is used for testing a variations of the backup process (end-of-year backups have a different long-term-storage directory than end-of-month backups).</p> <p>Logger is a mocked to not produce any output. BackupConfigModel is mocked to provide a standard set of return values that would have been pulled from Key Vault.</p>"},{"location":"framework/tests.html#inject_machines-example","title":"inject_machines example","text":"<pre><code># to be mocked\nfrom long_term_storage.service.backup.backup_and_encrypt import MachineBackupAndEncrypt\nfrom long_term_storage.service.retention_end_of_month.eom_deletion_candidates import (\n    MachineEomDeletionCandidates,\n)\nfrom long_term_storage.service.retention_end_of_year.eoy_deletion_candidates import (\n    MachineEoyDeletionCandidates,\n)\nfrom state_machine import Success\n\n# mock imports\nfrom tests.mocks import MockInvokedMachine\n\n\ndef inject_machines(\n    patch,\n):\n    \"\"\"Mock the nested state machines.\"\"\"\n    patch.setattr(\n        MachineBackupAndEncrypt,\n        \"execute\",\n        MockInvokedMachine.success(\n            Success(\n                node=\"MachineBackupAndEncrypt.report_results\",\n            )\n        ),\n    )\n    patch.setattr(\n        MachineEomDeletionCandidates,\n        \"execute\",\n        MockInvokedMachine.success(\n            Success(\n                node=\"MachineEomDeletionCandidates.report_results\",\n            )\n        ),\n    )\n    patch.setattr(\n        MachineEoyDeletionCandidates,\n        \"execute\",\n        MockInvokedMachine.success(\n            Success(\n                node=\"MachineEoyDeletionCandidates.report_results\",\n            )\n        ),\n    )\n</code></pre> <p>The machine being tested invokes three other machines while it is processing.  The machines will be instantiated by the underlying code while testing, but we replace the execute method of the invoked machines to make them behave as though they only had one node that always executed successfully.</p>"},{"location":"framework/tests.html#happy-path-test-example","title":"Happy path test example","text":"<pre><code>\"\"\"\nTest the discovery of databases to be backed up.\n\"\"\"\n\n# standard library imports\nfrom pprint import pprint\n\n# application import\nfrom long_term_storage.service.backup.backup_databases import (\n    machine_backup_databases,\n    DependencyBackupDatabases,\n)\nfrom state_machine import BaseDependency, Success\n\n# import mocks\nfrom tests.mocks import MockBasic, MockPostgreSQL\n\n# testing imports\nfrom tests.service.failure_asserts import failure_asserts\n\n# local imports\nfrom .create_machine import create_machine\nfrom .inject_machines import inject_machines\n\n\ndef get_mocks() -&gt; DependencyBackupDatabases:\n    \"\"\"\n    Mock the repository dependencies for the machine.\n    \"\"\"\n\n    class DependencyMock(BaseDependency):\n        fetch_databases = MockPostgreSQL.list_databases_four_results\n        does_public_key_exist = MockBasic.success\n        remove_pre_installed_public_key = MockBasic.success\n        install_public_key = MockBasic.success\n        trust_public_key = MockBasic.success\n        remove_public_key = MockBasic.success\n\n    return DependencyMock  # pyright: ignore\n\n\ndef test_happy_path(monkeypatch):\n    \"\"\"Test the happy path.\"\"\"\n    with monkeypatch.context() as patch:\n        inject_machines(patch)\n        DependencyMocks = get_mocks()\n        patch.setattr(\n            machine_backup_databases,\n            \"DependencyBackupDatabases\",\n            DependencyMocks,\n        )\n\n        machine = create_machine()\n\n        results = machine.execute()\n\n        node_order = []\n        for result in results:\n            assert isinstance(result, Success)\n            node_order.append(result.node)\n\n        assert node_order == [\n            \"MachineBackupDatabases.fetch_databases\",\n            \"MachineBackupDatabases.does_public_key_exist\",\n            \"MachineBackupDatabases.install_public_key\",\n            \"MachineBackupDatabases.trust_public_key\",\n            \"MachineBackupAndEncrypt.report_results\",\n            \"MachineBackupAndEncrypt.report_results\",\n            \"MachineBackupAndEncrypt.report_results\",\n            \"MachineBackupAndEncrypt.report_results\",\n            \"MachineBackupDatabases.backup_databases\",\n            \"MachineBackupDatabases.remove_public_key\",\n            \"MachineEomDeletionCandidates.report_results\",\n            \"MachineBackupDatabases.end_of_month_retention\",\n            \"MachineEoyDeletionCandidates.report_results\",\n            \"MachineBackupDatabases.end_of_year_retention\",\n            \"MachineBackupDatabases.report_results\",\n        ]\n</code></pre> <p>When testing the happy path, we want to confirm that the green paths in the diagram are followed as expected:</p> <ul> <li>No failures occur--tested in lines 58 and 59.</li> <li>The nodes for the testing scenario are executed in the expected order--tested in lines 62 through 78.</li> </ul> <p>The first thing we will look at is the dependency injection.</p> <pre><code>def get_mocks() -&gt; DependencyBackupDatabases:\n    \"\"\"\n    Mock the repository dependencies for the machine.\n    \"\"\"\n\n    class DependencyMock(BaseDependency):\n        fetch_databases = MockPostgreSQL.list_databases_four_results\n        does_public_key_exist = MockBasic.success\n        remove_pre_installed_public_key = MockBasic.success\n        install_public_key = MockBasic.success\n        trust_public_key = MockBasic.success\n        remove_public_key = MockBasic.success\n\n    return DependencyMock  # pyright: ignore\n</code></pre> <p>Here we are recreating the dependency mapper used by the state-machine to replace the functionality that would go out and change things with functionality that behaves as though that code had been executed successfully.  Most of the Repository calls in this state-machine don't expect a return value, so MockBasic.success is used--a function that does nothing and returns without failure.</p> <p>The difference is for the fetch_databases node, which does expect databases that need to be backed up to be returned by PostgreSQL. Requesting a backup of a PostgreSQL instance that has no databases to backup is considered a failure condition that needs to be reported back to us.</p> <p>Looking at the Repository definition of list_databases originally used by the production system:</p> <pre><code>    @classmethod\n    def list_databases(\n        cls,\n        *,\n        connection_model: ServicePrincipal,\n        excluding: list[str] = [],\n    ) -&gt; list[str]:\n        if excluding:\n            exclude = [f\"'{database}'\" for database in excluding]\n            statement = f\"\"\"\n                select\n                    datname\n                from pg_database\n                where\n                    datname not in ({\",\".join(exclude)}) and\n                    not datistemplate\n            \"\"\"\n        else:\n            statement = \"\"\"\n                select\n                    datname\n                from pg_database\n                where\n                    not datistemplate\n            \"\"\"\n\n        return [\n            record[\"datname\"]\n            for record in cls.execute(\n                statement=statement,\n                connection_model=connection_model,\n            )\n        ]\n</code></pre> <p>We see that it is issuing a query that has a single column and will be returned as a list of strings that contain the database names.  To mock this behavior, we create a method that returns a set of expected results.</p> <pre><code>    @classmethod\n    def list_databases_four_results(cls, **kwargs) -&gt; Any:\n        \"\"\"Returns a list of four databases.\"\"\"\n        return [\n            \"test_database_1\",\n            \"test_database_2\",\n            \"test_database_3\",\n            \"test_database_4\",\n        ]\n</code></pre> <p>Instead of querying a PostgreSQL instance, the unit test will continue processing as though it had queried a PostgreSQL instance and PostgreSQL reported there were four databases to be backed up.</p> <p>Looking at the definition of the happy path test:</p> <pre><code>def test_happy_path(monkeypatch):\n    \"\"\"Test the happy path.\"\"\"\n    with monkeypatch.context() as patch:\n</code></pre> <p>We see the function defining the test takes a single parameter: monkeypatch.  monkeypatch is then used in a \"with\" statement, which is known as a \"context generator\".  Context generators say \"this block of code will share the context provided by 'with ...'\".</p> <p>In this case, the provided context is \"patch\".</p> <p>\"monkeypatch\" provides the dependency injection functionality.  Within the monkeypatch context, \"patched\" items will use the alternative behavior when the test is executed.  The reason for doing it this way is to isolate the dependency injection to just the code being tested.  Say we had a situation where the code is using the datetime.now(UTC) function to get the current time, but we needed to the test to always take place at a fixed point in time, so we override the behavior of utctime to return a fixed time.  Doing that outside of a monkeypatch context would interfere with the test framework, which also needs to be able use datetime.now(UTC) to determine what time it is.</p> <p>Moving on to the dependency injection:</p> <pre><code>        inject_machines(patch)\n        DependencyMocks = get_mocks()\n        patch.setattr(\n            machine_backup_databases,\n            \"DependencyBackupDatabases\",\n            DependencyMocks,\n        )\n</code></pre> <p>Line 45 sets up mocks of the state-machines that will be invoked by this one.</p> <p>Line 46 fetches a copy of out mock definitions.</p> <p>Lines 47 through 51 inject the mocks into the original code base.  The first parameter of setattr identifies the target of the injection.  In this case, it's the module the state-machine was defined in.  The second parameter identifies the name of the item that will be substituted.  The third parameter is what should be used instead of the original definition.  What this statement says is, \"For every usage of DependencyBackupDatabases in the machine_backup_databases module, use DependencyMocks instead\".</p> <p>We then create the machine, execute the machine, and gather the results.</p> <pre><code>        machine = create_machine()\n\n        results = machine.execute()\n</code></pre> <p>Now that the machine has been executed, we are ready to confirm it behaved as expected.  Our first expectation is that it only followed green paths in the diagram, so we examine each of the results to confirm there were no Failures.</p> <pre><code>        node_order = []\n        for result in results:\n            assert isinstance(result, Success)\n            node_order.append(result.node)\n</code></pre> <p>While we are checking the results, we also gather a list of the node names that were executed in the order they were executed.  That list is used in the final statement to confirm the flow through the nodes matches what we expected to happen.</p> <pre><code>        assert node_order == [\n            \"MachineBackupDatabases.fetch_databases\",\n            \"MachineBackupDatabases.does_public_key_exist\",\n            \"MachineBackupDatabases.install_public_key\",\n            \"MachineBackupDatabases.trust_public_key\",\n            \"MachineBackupAndEncrypt.report_results\",\n            \"MachineBackupAndEncrypt.report_results\",\n            \"MachineBackupAndEncrypt.report_results\",\n            \"MachineBackupAndEncrypt.report_results\",\n            \"MachineBackupDatabases.backup_databases\",\n            \"MachineBackupDatabases.remove_public_key\",\n            \"MachineEomDeletionCandidates.report_results\",\n            \"MachineBackupDatabases.end_of_month_retention\",\n            \"MachineEoyDeletionCandidates.report_results\",\n            \"MachineBackupDatabases.end_of_year_retention\",\n            \"MachineBackupDatabases.report_results\",\n        ]\n</code></pre> <p>That's as far as the unit test is taken.  We are only interested in confirming that the business logic will make the decisions we expect it to make.</p>"},{"location":"framework/tests.html#failure-path-test-example","title":"Failure path test example","text":"<p>Failure testing has been generalized into a convenience function called failure_asserts.</p> <pre><code>\"\"\"\nConvience function for testing failure paths.\n\"\"\"\n\n# standard library imports\nfrom pprint import pprint\nfrom typing import Callable\n\n# application imports\nfrom state_machine import AbstractMachine, Failure\n\n\ndef failure_asserts(\n    create_machine: Callable[..., AbstractMachine],\n    result_count: int,\n    failing_node: int,\n    with_message: str,\n):\n    \"\"\"\n    Function for testing failure paths.\n\n    parameters:\n        create_machine (Callable): The function to create an instance of the machine.\n        result_count (int): The number of success/failure results that are expected to be generated under the testing conditions.\n        failing_node (int): The location of the node that was configured to fail.\n        with_message (str): The expected failure message.\n    \"\"\"\n    machine = create_machine()\n\n    results = machine.execute()\n\n    pprint(results)\n    print()\n    print(len(results))\n    print(results[failing_node].__class__.__name__, results[failing_node])\n\n    assert len(results) == result_count\n    assert isinstance(results[failing_node], Failure)\n    assert with_message in results[failing_node].message  # pyright: ignore\n</code></pre> <p>failure_asserts creates the machine, executes the machine, prints some useful debugging information in case the test fails, and asserts:</p> <ul> <li>The count of success/failure results matches what was expected based on the failure scenario that was set up.</li> <li>The node that was configured to fail did indeed fail.</li> <li>The failure message that will be reported in an alert is what would be expected for the failure condition.</li> </ul> <p>Looking at the first node that needs to be tested:</p> <pre><code>    @handle_exceptions(on_exception=\"end_of_month_retention\")\n    @node\n    def fetch_databases(self) -&gt; Transition:\n        \"\"\"\n        overview:\n            Retrieve a list of the databases to be backed up.\n\n        is_entry: True\n\n        happy_paths:\n            - does_public_key_exist\n\n        unhappy_paths:\n            - end_of_month_retention\n        \"\"\"\n        # The name of the database instance used in failure reporting is\n        # stored separately from the client_config in case there are connection\n        # problems with client_config, which could result in an exception in\n        # the exception handler.\n        self.state.postgresql_url = self.state.client_config.postgresql_host\n\n        # Bundle up the information needed to authenticate and connect to the database.\n        connection_model = ServicePrincipal(\n            host=self.state.client_config.postgresql_host,\n            port=self.state.client_config.postgresql_port,\n            service_principal_id=self.state.client_config.postgresql_service_principal_id,\n            client_secret=self.state.client_config.postgresql_secret,\n        )\n\n        # Collect the list of databases not to be backed up.\n        excluding = (\n            master_config.machine_backup_databases.exclude_everywhere\n            + self.state.client_config.exclude_databases\n        )\n\n        # Fetch the databases to be backed up.\n        self.state.databases = [\n            record[\"datname\"]\n            for record in DependencyBackupDatabases(logger=self.logger).fetch_databases(\n                connection_model=connection_model, excluding=excluding\n            )\n        ]\n\n        # If there are databases, proceed with backing them up.\n        if self.state.databases:\n            return self.success(exit_to=self.does_public_key_exist)\n        # Otherwise, inform us that we requested a backup of a PostgreSQL instance that has no databases to backup.\n        else:\n            return self.failure(\n                exit_to=self.end_of_month_retention,\n                message=f\"no databases to backup\",\n            )\n</code></pre> <p>The first thing to note is that we have a @handle_exceptions decorator.  This indicates that unrecoverable failures can occur while trying to process this node.  This node is querying the database, which may be unreachable or somebody removed the backup user.  It doesn't really matter why we might not be able to query the database.  If we can't query the database server, we can't continue with trying to back it up.</p> <p>So we want to test what happens in the Service layer under these circumstances.</p> <pre><code>def test_fetch_databases_failed(monkeypatch):\n    \"\"\"Test when querying for list of databases fails.\"\"\"\n    with monkeypatch.context() as patch:\n        inject_machines(patch)\n        DependencyMocks = get_mocks()\n        DependencyMocks.fetch_databases = MockBasic.failure\n        patch.setattr(\n            machine_backup_databases,\n            \"DependencyBackupDatabases\",\n            DependencyMocks,\n        )\n\n        failure_asserts(\n            create_machine=create_machine,\n            result_count=6,\n            failing_node=0,\n            with_message=\"test_client_name test_postgresql_url.rest.of.url unrecognized exception: unit test failure\",\n        )\n</code></pre> <p>Setting up the patching context is the same as for the happy path.  But we have one change we want to make for the dependency injections.  After we have fetched the mocks in line 105, we change the behavior of fetch_databases in line 106.  Instead of returning a set of database records that would allow the state-machine to continue processing, we rasie an exception to simulate a connection failure when trying to query the database.</p> <p>We then call failure_asserts to validate that the machine behaved as expected under these conditions.</p> <pre><code>        failure_asserts(\n            create_machine=create_machine,\n            result_count=6,\n            failing_node=0,\n            with_message=\"test_client_name test_postgresql_url.rest.of.url unrecognized exception: unit test failure\",\n        )\n</code></pre> <p>The parameters for failure_assert are:</p> <ul> <li>create_machine: The function used to create a test state-machine.</li> <li>result_count: The number of success/failure messages we expect to be executed under these circumstances. The failure path for fetch_databases has four nodes in the design, however, two of those nodes invoke outside state-machines, which back in inject_machines we set up to just return one success result.  So the four nodes from this machine plus the two from the mocked state-machines gives us 6 results we expect to find in the result list.</li> <li>failing_node: The result in the list we expect to be the failure we provoked in this machine.  This test is causing the first node to fail, so we expect the first result in the list to be the failure.</li> <li>with_message: The message we expect the machine to generate as a result of this kind of failure.</li> </ul> <p>The nodes are expected to return either self.success or self.failure.  These are convenience methods in AbstractMachine that perform the appropriate logging and build the Transition object in a consistent manner.  They are also useful for determining paths that need to be tested, since any place we see \"return self.failure(...)\" needs to be tested.</p> <p>Reviewing the implementation of fetch_databases, we also see that line 115 also contains a \"return self.failure(...)\".  The condition that allows us to get to that failure path is if we successfully query the PostgreSQL instance, but it reported back that there are no databases to backup.</p> <p>So we want to test that path as well.</p> <pre><code>def test_fetch_databases_empty(monkeypatch):\n    \"\"\"Test when no databases to backup.\"\"\"\n    with monkeypatch.context() as patch:\n        inject_machines(patch)\n        DependencyMocks = get_mocks()\n        DependencyMocks.fetch_databases = MockBasic.empty_list\n        patch.setattr(\n            machine_backup_databases,\n            \"DependencyBackupDatabases\",\n            DependencyMocks,\n        )\n\n        failure_asserts(\n            create_machine=create_machine,\n            result_count=6,\n            failing_node=0,\n            with_message=\"test_client_name test_postgresql_url.rest.of.url no databases to backup\",\n        )\n</code></pre> <p>The difference in the mocking behavior is in line 86, where instead of returning a list of databases to be backed up, it returns an empty list.</p> <p>The difference in the failure_asserts test is in with_message. We're still failing in the first node, and the machine is designed to follow the same paths in this situation, but the message that will be reported back in the failure report is different.</p>"},{"location":"secret/config_secrets.html","title":"Config Secrets","text":"<p>The secrets module provides a couple of scripts for managing secrets in config files.</p> <p>The primary intention of adding secrets to the config file system was for use in dev environments where you're trying to figure out how to get something to work, and you quick-and-dirty cram clear-text credentials into code.  Then you forget about them and check them into the repository.</p> <p>Danger</p> <p>Never, never, ever check clear-text credentials into a source-code repository.  Finding them there should be treated as a Sev 1 Security Incident that requires changing the credentials immediately.  Source-code repositories are considered low-hanging fruit for criminals searching for credentials.  Nobody ever runs the level of intrusion-detection monitoring on source-code repositories they would in a prod environment.  Once something has been checked into the repository, it's really hard to remove.  The whole purpose of a version management system is to keep a history of everything that has changed.</p> <p>Anyway, the config secrets expect to find an encryption key in /etc/fernet.key.</p> <p>The key can be generated using:</p> <pre><code>python -m secrets.generate_key fernet.key\n</code></pre> <p>Then:</p> <pre><code>sudo mv fernet.key /etc\n</code></pre> <p>Usage within code:</p> <pre><code>from from state_machine.config import Config\n\nconfig = Config()\nsecret = config.secrets.category_name.secret_name\n</code></pre> <p>The secrets.yaml file is excluded by gitignore, and it is assumed everybody will generate their own key and populate their own version of any secret information they need to encrypt.</p>"},{"location":"secret/generate_key.html","title":"Generate Key","text":"<p>Generate an encryption key.  Will error out if trying to overwrite an existing key.</p> <pre><code>python -m secret.generate_key file_name\n</code></pre> positional <ul> <li>file_name: Name of the file to place the key in--must not already exist.</li> </ul>"},{"location":"secret/generate_key.html#secret.generate_key.generate_key","title":"generate_key","text":"<pre><code>generate_key(file_name: str)\n</code></pre> <p>Generate a Fernet key.</p> Source code in <code>secret/generate_key.py</code> <pre><code>def generate_key(file_name: str):\n    \"\"\"\n    Generate a Fernet key.\n    \"\"\"\n    if os.path.exists(file_name):\n        print(f\"{file_name} already exists\")\n        exit(1)\n    key = Fernet.generate_key()\n    with open(file_name, \"w\") as file_out:\n        file_out.write(key.decode())\n</code></pre>"},{"location":"secret/set.html","title":"Generate Key","text":"<p>Sets a secret value in the master secrets.yaml file.</p> <p>Command line usage:</p> <pre><code>python -m secret.set\n</code></pre> prompts <ul> <li>Category: The group the secret belongs to.</li> <li>Name: The name of the secret.</li> <li>Secret: The value of the secret.</li> </ul>"},{"location":"secret/set.html#secret.set.set","title":"set","text":"<pre><code>set()\n</code></pre> <p>Sets an encrypted value in the secrets config file.</p> Source code in <code>secret/set.py</code> <pre><code>def set():\n    \"\"\"\n    Sets an encrypted value in the secrets config file.\n    \"\"\"\n    category = input(\"Category: \")\n    name = input(\"Name: \")\n    secret = getpass(\"Secret: \")\n\n    config = Config()\n    config.secrets.set(category, name, secret)\n</code></pre>"},{"location":"source_code/end_point/dependency_end_point.html","title":"dependency_end_point","text":""},{"location":"source_code/end_point/dependency_end_point.html#end_point.dependency_end_point.DependencyEndPoint","title":"DependencyEndPoint","text":"<p>             Bases: <code>state_machine.BaseDependency</code></p> <p>The repository dependencies for executing an end-point.</p> Source code in <code>end_point/dependency_end_point.py</code> <pre><code>class DependencyEndPoint(BaseDependency):\n    \"\"\"The repository dependencies for executing an end-point.\"\"\"\n\n    execute_write_to_stdout = Process.write_to_stdout\n    execute_exit = Process.exit\n</code></pre>"},{"location":"source_code/end_point/dynamic_mounting_end_point.html","title":"dynamic_mounting_end_point","text":""},{"location":"source_code/end_point/dynamic_mounting_end_point.html#end_point.dynamic_mounting_end_point.DynamicMountingEndPoint","title":"DynamicMountingEndPoint","text":"<p>             Bases: <code>end_point.end_point.EndPoint</code></p> <p>Executes a state machine within a dynamic mounting machine.</p> Source code in <code>end_point/dynamic_mounting_end_point.py</code> <pre><code>class DynamicMountingEndPoint(EndPoint):\n    \"\"\"\n    Executes a state machine within a dynamic mounting machine.\n    \"\"\"\n\n    def __init__(\n        self,\n        *,\n        logger: Logger,\n        state_dynamic_mount: StateDynamicMount,\n    ):\n        wrapped_machine = MachineDynamicMount(logger=logger, state=state_dynamic_mount)\n        super().__init__(logger=logger, machine=wrapped_machine)\n</code></pre>"},{"location":"source_code/end_point/end_point.html","title":"end_point","text":""},{"location":"source_code/end_point/end_point.html#end_point.end_point.EndPoint","title":"EndPoint","text":"<p>Wrapper around a state machine to execute the machine and report failures to stdout.</p> Source code in <code>end_point/end_point.py</code> <pre><code>class EndPoint:\n    \"\"\"\n    Wrapper around a state machine to execute the machine and report failures to stdout.\n    \"\"\"\n\n    def __init__(\n        self,\n        *,\n        logger: Logger,\n        machine: AbstractMachine,\n    ):\n        self._logger = logger\n        self._machine = machine\n\n    def execute(self):\n        \"\"\"\n        Executes the machine, filters any failures, reports failures on stdout, and exits with the status of the number of failures.\n        \"\"\"\n        try:\n            self._results = self.machine.execute()\n\n            self._failures = [\n                result for result in self._results if isinstance(result, Failure)\n            ]\n\n            for failure in self._failures:\n                self.logger.error(f\"Failure: {failure}\")\n                DependencyEndPoint(logger=self.logger).execute_write_to_stdout(\n                    content=f\"Failure: {failure}\"\n                )\n\n            DependencyEndPoint(logger=self.logger).execute_exit(\n                result=len(self._failures)\n            )\n        except Exception as exception:\n            self.logger.critical(f\"Critical exception: {format_exc()}\")\n            DependencyEndPoint(logger=self.logger).execute_write_to_stdout(\n                content=f\"Critical failure: {exception}\"\n            )\n            DependencyEndPoint(logger=self.logger).execute_exit(result=1)\n\n    @property\n    def logger(self):\n        return self._logger\n\n    @property\n    def machine(self):\n        return self._machine\n</code></pre>"},{"location":"source_code/end_point/end_point.html#end_point.end_point.EndPoint.execute","title":"execute","text":"<pre><code>execute()\n</code></pre> <p>Executes the machine, filters any failures, reports failures on stdout, and exits with the status of the number of failures.</p> Source code in <code>end_point/end_point.py</code> <pre><code>def execute(self):\n    \"\"\"\n    Executes the machine, filters any failures, reports failures on stdout, and exits with the status of the number of failures.\n    \"\"\"\n    try:\n        self._results = self.machine.execute()\n\n        self._failures = [\n            result for result in self._results if isinstance(result, Failure)\n        ]\n\n        for failure in self._failures:\n            self.logger.error(f\"Failure: {failure}\")\n            DependencyEndPoint(logger=self.logger).execute_write_to_stdout(\n                content=f\"Failure: {failure}\"\n            )\n\n        DependencyEndPoint(logger=self.logger).execute_exit(\n            result=len(self._failures)\n        )\n    except Exception as exception:\n        self.logger.critical(f\"Critical exception: {format_exc()}\")\n        DependencyEndPoint(logger=self.logger).execute_write_to_stdout(\n            content=f\"Critical failure: {exception}\"\n        )\n        DependencyEndPoint(logger=self.logger).execute_exit(result=1)\n</code></pre>"},{"location":"source_code/model/connection/key_vault/service_principal.html","title":"service_principal","text":""},{"location":"source_code/model/connection/key_vault/service_principal.html#model.connection.key_vault.service_principal.ServicePrincipal","title":"ServicePrincipal","text":"<p>             Bases: <code>pydantic.BaseModel</code></p> <p>Connection information to a key vault for authenticating a service principal.</p> Source code in <code>model/connection/key_vault/service_principal.py</code> <pre><code>class ServicePrincipal(BaseModel):\n    \"\"\"Connection information to a key vault for authenticating a service principal.\"\"\"\n\n    keyvault_host: str\n    \"\"\"The host of the key vault.\"\"\"\n\n    service_principal_id: str\n    \"\"\"The application id of the service principal.\"\"\"\n\n    client_secret: SecretStr\n    \"\"\"The client secret fo authenticating the service principal.\"\"\"\n\n    tenant_id: str = Field(default=\"e17e2402-2a40-42ce-ad75-5848b8d4f6b6\")\n    \"\"\"The tenant for authentication.\"\"\"\n\n    authority_host: str = Field(default=\"https://login.microsoftonline.com\")\n    \"\"\"The authority host for authentication.\"\"\"\n\n    @property\n    def client(self) -&gt; SecretClient:\n        \"\"\"\n        Returns a client for interacting with key vault.\n        \"\"\"\n        os.environ[\"AZURE_TENANT_ID\"] = self.tenant_id\n        os.environ[\"AZURE_CLIENT_ID\"] = self.service_principal_id\n        os.environ[\"AZURE_CLIENT_SECRET\"] = self.client_secret.get_secret_value()\n        os.environ[\"AZURE_AUTHORITY_HOST\"] = self.authority_host\n\n        credential = EnvironmentCredential()\n\n        return SecretClient(vault_url=self.keyvault_host, credential=credential)\n</code></pre>"},{"location":"source_code/model/connection/key_vault/service_principal.html#model.connection.key_vault.service_principal.ServicePrincipal.authority_host","title":"authority_host  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>authority_host: str = pydantic.Field(\n    default=\"https://login.microsoftonline.com\"\n)\n</code></pre> <p>The authority host for authentication.</p>"},{"location":"source_code/model/connection/key_vault/service_principal.html#model.connection.key_vault.service_principal.ServicePrincipal.client","title":"client  <code>property</code>","text":"<pre><code>client: azure.keyvault.secrets.SecretClient\n</code></pre> <p>Returns a client for interacting with key vault.</p>"},{"location":"source_code/model/connection/key_vault/service_principal.html#model.connection.key_vault.service_principal.ServicePrincipal.client_secret","title":"client_secret  <code>instance-attribute</code>","text":"<pre><code>client_secret: pydantic.SecretStr\n</code></pre> <p>The client secret fo authenticating the service principal.</p>"},{"location":"source_code/model/connection/key_vault/service_principal.html#model.connection.key_vault.service_principal.ServicePrincipal.keyvault_host","title":"keyvault_host  <code>instance-attribute</code>","text":"<pre><code>keyvault_host: str\n</code></pre> <p>The host of the key vault.</p>"},{"location":"source_code/model/connection/key_vault/service_principal.html#model.connection.key_vault.service_principal.ServicePrincipal.service_principal_id","title":"service_principal_id  <code>instance-attribute</code>","text":"<pre><code>service_principal_id: str\n</code></pre> <p>The application id of the service principal.</p>"},{"location":"source_code/model/connection/key_vault/service_principal.html#model.connection.key_vault.service_principal.ServicePrincipal.tenant_id","title":"tenant_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tenant_id: str = pydantic.Field(\n    default=\"e17e2402-2a40-42ce-ad75-5848b8d4f6b6\"\n)\n</code></pre> <p>The tenant for authentication.</p>"},{"location":"source_code/model/connection/postgresql/az_cli.html","title":"az_cli","text":""},{"location":"source_code/model/connection/postgresql/az_cli.html#model.connection.postgresql.az_cli.AzCli","title":"AzCli","text":"<p>             Bases: <code>pydantic.BaseModel</code></p> <p>Connection information for connecting to PostgreSQL using a token where Entra Id authentication was performed locally using Azure CLI.</p> Source code in <code>model/connection/postgresql/az_cli.py</code> <pre><code>class AzCli(BaseModel):\n    \"\"\"\n    Connection information for connecting to PostgreSQL using a token where Entra Id authentication\n    was performed locally using Azure CLI.\n    \"\"\"\n\n    host: str\n    \"\"\"\n    The url for connecting to PostgreSQL.\n    \"\"\"\n\n    port: int\n    \"\"\"\n    The port for connecting to PostgreSQL.\n    \"\"\"\n\n    username: str\n    \"\"\"\n    The user name that was used when authenticating with Entra Id.\n    \"\"\"\n\n    database: str = Field(default=\"postgres\")\n    \"\"\"\n    The name of the database to connect to.\n    \"\"\"\n\n    token_host: str = Field(\n        default=\"https://ossrdbms-aad.database.windows.net/.default\"\n    )\n    \"\"\"\n    The url used to fetch a PostgreSQL token from Entra Id.\n    \"\"\"\n\n    @property\n    def token(self) -&gt; SecretStr:\n        \"\"\"\n        Fetches the authentication token with the assumption the user has authenticated\n        with Azure CLI.\n        \"\"\"\n        credential = DefaultAzureCredential()\n        token = credential.get_token(self.token_host)\n\n        return SecretStr(secret_value=token.token)\n</code></pre>"},{"location":"source_code/model/connection/postgresql/az_cli.html#model.connection.postgresql.az_cli.AzCli.database","title":"database  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>database: str = pydantic.Field(default='postgres')\n</code></pre> <p>The name of the database to connect to.</p>"},{"location":"source_code/model/connection/postgresql/az_cli.html#model.connection.postgresql.az_cli.AzCli.host","title":"host  <code>instance-attribute</code>","text":"<pre><code>host: str\n</code></pre> <p>The url for connecting to PostgreSQL.</p>"},{"location":"source_code/model/connection/postgresql/az_cli.html#model.connection.postgresql.az_cli.AzCli.port","title":"port  <code>instance-attribute</code>","text":"<pre><code>port: int\n</code></pre> <p>The port for connecting to PostgreSQL.</p>"},{"location":"source_code/model/connection/postgresql/az_cli.html#model.connection.postgresql.az_cli.AzCli.token","title":"token  <code>property</code>","text":"<pre><code>token: pydantic.SecretStr\n</code></pre> <p>Fetches the authentication token with the assumption the user has authenticated with Azure CLI.</p>"},{"location":"source_code/model/connection/postgresql/az_cli.html#model.connection.postgresql.az_cli.AzCli.token_host","title":"token_host  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>token_host: str = pydantic.Field(\n    default=\"https://ossrdbms-aad.database.windows.net/.default\"\n)\n</code></pre> <p>The url used to fetch a PostgreSQL token from Entra Id.</p>"},{"location":"source_code/model/connection/postgresql/az_cli.html#model.connection.postgresql.az_cli.AzCli.username","title":"username  <code>instance-attribute</code>","text":"<pre><code>username: str\n</code></pre> <p>The user name that was used when authenticating with Entra Id.</p>"},{"location":"source_code/model/connection/postgresql/service_principal.html","title":"service_principal","text":""},{"location":"source_code/model/connection/postgresql/service_principal.html#model.connection.postgresql.service_principal.ServicePrincipal","title":"ServicePrincipal","text":"<p>             Bases: <code>pydantic.BaseModel</code></p> <p>Connection information to PostgreSQL for authenticating with a service principal.</p> Source code in <code>model/connection/postgresql/service_principal.py</code> <pre><code>class ServicePrincipal(BaseModel):\n    \"\"\"\n    Connection information to PostgreSQL for authenticating with a service principal.\n    \"\"\"\n\n    host: str\n    \"\"\"The url for connecting to the PostgreSQL instance.\"\"\"\n\n    port: int\n    \"\"\"The port for connecting to the PostgreSQL instance.\"\"\"\n\n    service_principal_id: str\n    \"\"\"The service principal object id.\"\"\"\n\n    client_secret: SecretStr\n    \"\"\"The client secret to fetch a PostgreSQL token from Entra Id.\"\"\"\n\n    database: str = Field(default=\"postgres\")\n    \"\"\"The name of the database.\"\"\"\n\n    tenant_id: UUID1 = Field(default=\"e17e2402-2a40-42ce-ad75-5848b8d4f6b6\")\n    \"\"\"The tenant for authentication.\"\"\"\n\n    authority_host: HttpUrl = Field(default=\"https://login.microsoftonline.com\")\n    \"\"\"The authority host for authentication.\"\"\"\n\n    token_host: HttpUrl = Field(\n        default=\"https://ossrdbms-aad.database.windows.net/.default\"\n    )\n    \"\"\"The Entra Id end-point for retrieving the PostgreSQL authentication token.\"\"\"\n\n    @property\n    def token(self) -&gt; SecretStr:\n        \"\"\"\n        Returns a token to be used as the password for connecting to PostgreSQL.\n        \"\"\"\n        os.environ[\"AZURE_TENANT_ID\"] = str(self.tenant_id)\n        os.environ[\"AZURE_CLIENT_ID\"] = self.service_principal_id\n        os.environ[\"AZURE_CLIENT_SECRET\"] = self.client_secret.get_secret_value()\n        os.environ[\"AZURE_AUTHORITY_HOST\"] = str(self.authority_host)\n\n        credential = EnvironmentCredential()\n        token = credential.get_token(str(self.token_host))\n\n        return SecretStr(secret_value=token.token)\n</code></pre>"},{"location":"source_code/model/connection/postgresql/service_principal.html#model.connection.postgresql.service_principal.ServicePrincipal.authority_host","title":"authority_host  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>authority_host: pydantic.HttpUrl = pydantic.Field(\n    default=\"https://login.microsoftonline.com\"\n)\n</code></pre> <p>The authority host for authentication.</p>"},{"location":"source_code/model/connection/postgresql/service_principal.html#model.connection.postgresql.service_principal.ServicePrincipal.client_secret","title":"client_secret  <code>instance-attribute</code>","text":"<pre><code>client_secret: pydantic.SecretStr\n</code></pre> <p>The client secret to fetch a PostgreSQL token from Entra Id.</p>"},{"location":"source_code/model/connection/postgresql/service_principal.html#model.connection.postgresql.service_principal.ServicePrincipal.database","title":"database  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>database: str = pydantic.Field(default='postgres')\n</code></pre> <p>The name of the database.</p>"},{"location":"source_code/model/connection/postgresql/service_principal.html#model.connection.postgresql.service_principal.ServicePrincipal.host","title":"host  <code>instance-attribute</code>","text":"<pre><code>host: str\n</code></pre> <p>The url for connecting to the PostgreSQL instance.</p>"},{"location":"source_code/model/connection/postgresql/service_principal.html#model.connection.postgresql.service_principal.ServicePrincipal.port","title":"port  <code>instance-attribute</code>","text":"<pre><code>port: int\n</code></pre> <p>The port for connecting to the PostgreSQL instance.</p>"},{"location":"source_code/model/connection/postgresql/service_principal.html#model.connection.postgresql.service_principal.ServicePrincipal.service_principal_id","title":"service_principal_id  <code>instance-attribute</code>","text":"<pre><code>service_principal_id: str\n</code></pre> <p>The service principal object id.</p>"},{"location":"source_code/model/connection/postgresql/service_principal.html#model.connection.postgresql.service_principal.ServicePrincipal.tenant_id","title":"tenant_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tenant_id: pydantic.UUID1 = pydantic.Field(\n    default=\"e17e2402-2a40-42ce-ad75-5848b8d4f6b6\"\n)\n</code></pre> <p>The tenant for authentication.</p>"},{"location":"source_code/model/connection/postgresql/service_principal.html#model.connection.postgresql.service_principal.ServicePrincipal.token","title":"token  <code>property</code>","text":"<pre><code>token: pydantic.SecretStr\n</code></pre> <p>Returns a token to be used as the password for connecting to PostgreSQL.</p>"},{"location":"source_code/model/connection/postgresql/service_principal.html#model.connection.postgresql.service_principal.ServicePrincipal.token_host","title":"token_host  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>token_host: pydantic.HttpUrl = pydantic.Field(\n    default=\"https://ossrdbms-aad.database.windows.net/.default\"\n)\n</code></pre> <p>The Entra Id end-point for retrieving the PostgreSQL authentication token.</p>"},{"location":"source_code/model/connection/postgresql/user.html","title":"user","text":""},{"location":"source_code/model/connection/postgresql/user.html#model.connection.postgresql.user.User","title":"User","text":"<p>             Bases: <code>pydantic.BaseModel</code></p> <p>Information to connect to PostgreSQL using PostgreSQL password authentication.</p> Source code in <code>model/connection/postgresql/user.py</code> <pre><code>class User(BaseModel):\n    \"\"\"\n    Information to connect to PostgreSQL using PostgreSQL password authentication.\n    \"\"\"\n\n    host: str\n    \"\"\"The url for connecting to the PostgreSQL instance.\"\"\"\n\n    port: int\n    \"\"\"The port for connecting to the PostgreSQL instance.\"\"\"\n\n    username: str\n    \"\"\"The PostgreSQL user name.\"\"\"\n\n    password: SecretStr\n    \"\"\"The PostgreSQL password.\"\"\"\n\n    database: str = Field(default=\"postgres\")\n    \"\"\"The name of the database.\"\"\"\n</code></pre>"},{"location":"source_code/model/connection/postgresql/user.html#model.connection.postgresql.user.User.database","title":"database  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>database: str = pydantic.Field(default='postgres')\n</code></pre> <p>The name of the database.</p>"},{"location":"source_code/model/connection/postgresql/user.html#model.connection.postgresql.user.User.host","title":"host  <code>instance-attribute</code>","text":"<pre><code>host: str\n</code></pre> <p>The url for connecting to the PostgreSQL instance.</p>"},{"location":"source_code/model/connection/postgresql/user.html#model.connection.postgresql.user.User.password","title":"password  <code>instance-attribute</code>","text":"<pre><code>password: pydantic.SecretStr\n</code></pre> <p>The PostgreSQL password.</p>"},{"location":"source_code/model/connection/postgresql/user.html#model.connection.postgresql.user.User.port","title":"port  <code>instance-attribute</code>","text":"<pre><code>port: int\n</code></pre> <p>The port for connecting to the PostgreSQL instance.</p>"},{"location":"source_code/model/connection/postgresql/user.html#model.connection.postgresql.user.User.username","title":"username  <code>instance-attribute</code>","text":"<pre><code>username: str\n</code></pre> <p>The PostgreSQL user name.</p>"},{"location":"source_code/repository/file_manager/file_manager.html","title":"file_manager","text":""},{"location":"source_code/repository/file_manager/file_manager.html#repository.file_manager.file_manager.FileManager","title":"FileManager","text":"<p>             Bases: <code>state_machine.AbstractRepository</code></p> <p>File manipulations.</p> Source code in <code>repository/file_manager/file_manager.py</code> <pre><code>class FileManager(AbstractRepository):\n    \"\"\"\n    File manipulations.\n    \"\"\"\n\n    @classmethod\n    def execute(cls, function: Callable, *args, **kwargs) -&gt; Any:\n        \"\"\"\n        Executes a file management operation.\n        \"\"\"\n        start_time = datetime.now(UTC)\n        cls.logger.debug(f\"  {function.__name__} {args} {kwargs} - Started\")\n\n        results = function(*args, **kwargs)\n\n        end_time = datetime.now(UTC)\n        cls.logger.debug(\n            f\"  {function.__name__} {args} {kwargs} - Completed - Runtime: {end_time - start_time}\"\n        )\n\n        return results\n\n    @classmethod\n    def all_files_in_directory(cls, *, path) -&gt; list[str]:\n        \"\"\"\n        Recursively walks a directory and compiles a list of all of the files found.\n        \"\"\"\n        ret = []\n        for root, _, files in cls.execute(os.walk, path):\n            for file_name in files:\n                ret.append(os.path.join(root, file_name))\n        return ret\n\n    @classmethod\n    def copy(cls, *, from_path: str, to_path: str):\n        \"\"\"Copy file from *from_path* to *to_path*.\"\"\"\n        cls.execute(copy2, from_path, to_path)\n\n    @classmethod\n    def exists(cls, *, path: str) -&gt; bool:\n        \"\"\"Checks for the existence of *path* in the filesystem.\"\"\"\n        return cls.execute(os.path.exists, path)\n\n    @classmethod\n    def make_dir_if_not_exists(cls, *, path: str):\n        \"\"\"Creates the full directory *path* if it does not already exist.\"\"\"\n        cls.execute(os.makedirs, path, exist_ok=True)\n\n    @classmethod\n    def move(cls, *, from_path: str, to_path: str):\n        \"\"\"Moves file from *from_path* to *to_path*.\"\"\"\n        cls.execute(move, from_path, to_path)\n\n    @classmethod\n    def remove_directory_if_exists(cls, *, path: str):\n        \"\"\"\n        Remove a file if it exists, otherwise fo nothing.\n        \"\"\"\n        if cls.execute(os.path.exists, path):\n            cls.execute(os.rmdir, path)\n\n    @classmethod\n    def remove_file_if_exists(cls, *, path: str):\n        \"\"\"\n        Remove a file if it exists, otherwise do nothing.\n        \"\"\"\n        if cls.execute(os.path.exists, path):\n            cls.execute(os.remove, path)\n\n    @classmethod\n    def modification_time(cls, *, path: str) -&gt; datetime:\n        \"\"\"Returns the modification date for the file in *path*.\"\"\"\n        return datetime.fromtimestamp(cls.execute(os.path.getmtime, path))\n</code></pre>"},{"location":"source_code/repository/file_manager/file_manager.html#repository.file_manager.file_manager.FileManager.all_files_in_directory","title":"all_files_in_directory  <code>classmethod</code>","text":"<pre><code>all_files_in_directory(*, path) -&gt; list[str]\n</code></pre> <p>Recursively walks a directory and compiles a list of all of the files found.</p> Source code in <code>repository/file_manager/file_manager.py</code> <pre><code>@classmethod\ndef all_files_in_directory(cls, *, path) -&gt; list[str]:\n    \"\"\"\n    Recursively walks a directory and compiles a list of all of the files found.\n    \"\"\"\n    ret = []\n    for root, _, files in cls.execute(os.walk, path):\n        for file_name in files:\n            ret.append(os.path.join(root, file_name))\n    return ret\n</code></pre>"},{"location":"source_code/repository/file_manager/file_manager.html#repository.file_manager.file_manager.FileManager.copy","title":"copy  <code>classmethod</code>","text":"<pre><code>copy(*, from_path: str, to_path: str)\n</code></pre> <p>Copy file from from_path to to_path.</p> Source code in <code>repository/file_manager/file_manager.py</code> <pre><code>@classmethod\ndef copy(cls, *, from_path: str, to_path: str):\n    \"\"\"Copy file from *from_path* to *to_path*.\"\"\"\n    cls.execute(copy2, from_path, to_path)\n</code></pre>"},{"location":"source_code/repository/file_manager/file_manager.html#repository.file_manager.file_manager.FileManager.execute","title":"execute  <code>classmethod</code>","text":"<pre><code>execute(function: Callable, *args, **kwargs) -&gt; Any\n</code></pre> <p>Executes a file management operation.</p> Source code in <code>repository/file_manager/file_manager.py</code> <pre><code>@classmethod\ndef execute(cls, function: Callable, *args, **kwargs) -&gt; Any:\n    \"\"\"\n    Executes a file management operation.\n    \"\"\"\n    start_time = datetime.now(UTC)\n    cls.logger.debug(f\"  {function.__name__} {args} {kwargs} - Started\")\n\n    results = function(*args, **kwargs)\n\n    end_time = datetime.now(UTC)\n    cls.logger.debug(\n        f\"  {function.__name__} {args} {kwargs} - Completed - Runtime: {end_time - start_time}\"\n    )\n\n    return results\n</code></pre>"},{"location":"source_code/repository/file_manager/file_manager.html#repository.file_manager.file_manager.FileManager.exists","title":"exists  <code>classmethod</code>","text":"<pre><code>exists(*, path: str) -&gt; bool\n</code></pre> <p>Checks for the existence of path in the filesystem.</p> Source code in <code>repository/file_manager/file_manager.py</code> <pre><code>@classmethod\ndef exists(cls, *, path: str) -&gt; bool:\n    \"\"\"Checks for the existence of *path* in the filesystem.\"\"\"\n    return cls.execute(os.path.exists, path)\n</code></pre>"},{"location":"source_code/repository/file_manager/file_manager.html#repository.file_manager.file_manager.FileManager.make_dir_if_not_exists","title":"make_dir_if_not_exists  <code>classmethod</code>","text":"<pre><code>make_dir_if_not_exists(*, path: str)\n</code></pre> <p>Creates the full directory path if it does not already exist.</p> Source code in <code>repository/file_manager/file_manager.py</code> <pre><code>@classmethod\ndef make_dir_if_not_exists(cls, *, path: str):\n    \"\"\"Creates the full directory *path* if it does not already exist.\"\"\"\n    cls.execute(os.makedirs, path, exist_ok=True)\n</code></pre>"},{"location":"source_code/repository/file_manager/file_manager.html#repository.file_manager.file_manager.FileManager.modification_time","title":"modification_time  <code>classmethod</code>","text":"<pre><code>modification_time(*, path: str) -&gt; datetime\n</code></pre> <p>Returns the modification date for the file in path.</p> Source code in <code>repository/file_manager/file_manager.py</code> <pre><code>@classmethod\ndef modification_time(cls, *, path: str) -&gt; datetime:\n    \"\"\"Returns the modification date for the file in *path*.\"\"\"\n    return datetime.fromtimestamp(cls.execute(os.path.getmtime, path))\n</code></pre>"},{"location":"source_code/repository/file_manager/file_manager.html#repository.file_manager.file_manager.FileManager.move","title":"move  <code>classmethod</code>","text":"<pre><code>move(*, from_path: str, to_path: str)\n</code></pre> <p>Moves file from from_path to to_path.</p> Source code in <code>repository/file_manager/file_manager.py</code> <pre><code>@classmethod\ndef move(cls, *, from_path: str, to_path: str):\n    \"\"\"Moves file from *from_path* to *to_path*.\"\"\"\n    cls.execute(move, from_path, to_path)\n</code></pre>"},{"location":"source_code/repository/file_manager/file_manager.html#repository.file_manager.file_manager.FileManager.remove_directory_if_exists","title":"remove_directory_if_exists  <code>classmethod</code>","text":"<pre><code>remove_directory_if_exists(*, path: str)\n</code></pre> <p>Remove a file if it exists, otherwise fo nothing.</p> Source code in <code>repository/file_manager/file_manager.py</code> <pre><code>@classmethod\ndef remove_directory_if_exists(cls, *, path: str):\n    \"\"\"\n    Remove a file if it exists, otherwise fo nothing.\n    \"\"\"\n    if cls.execute(os.path.exists, path):\n        cls.execute(os.rmdir, path)\n</code></pre>"},{"location":"source_code/repository/file_manager/file_manager.html#repository.file_manager.file_manager.FileManager.remove_file_if_exists","title":"remove_file_if_exists  <code>classmethod</code>","text":"<pre><code>remove_file_if_exists(*, path: str)\n</code></pre> <p>Remove a file if it exists, otherwise do nothing.</p> Source code in <code>repository/file_manager/file_manager.py</code> <pre><code>@classmethod\ndef remove_file_if_exists(cls, *, path: str):\n    \"\"\"\n    Remove a file if it exists, otherwise do nothing.\n    \"\"\"\n    if cls.execute(os.path.exists, path):\n        cls.execute(os.remove, path)\n</code></pre>"},{"location":"source_code/repository/gpg/gpg.html","title":"gpg","text":""},{"location":"source_code/repository/gpg/gpg.html#repository.gpg.gpg.Gpg","title":"Gpg","text":"<p>             Bases: <code>state_machine.AbstractRepository</code></p> <p>Interactions with gpg.</p> Source code in <code>repository/gpg/gpg.py</code> <pre><code>class Gpg(AbstractRepository):\n    \"\"\"\n    Interactions with gpg.\n    \"\"\"\n\n    @classmethod\n    def execute(cls, function: Callable, *args, **kwargs):\n        \"\"\"Executes the gpg action.\"\"\"\n        start_time = datetime.now(UTC)\n        cls.logger.debug(f\"  {function.__name__} - Started\")\n\n        results = function(*args, **kwargs)\n\n        end_time = datetime.now(UTC)\n        cls.logger.debug(\n            f\"  {function.__name__} - Completed - Runtime: {end_time - start_time}\"\n        )\n\n        return results\n\n    @classmethod\n    def decrypt(cls, *, from_file: str, to_file: str, passphrase: SecretStr):\n        \"\"\"\n        Decrypt file *from_file* to *to_file*.\n        \"\"\"\n        gpg = GPG(verbose=True)\n        with open(from_file, \"rb\") as file_in:\n            results = cls.execute(\n                gpg.decrypt_file,\n                file_in,\n                passphrase=passphrase.get_secret_value(),\n                output=to_file,\n                always_trust=True,\n            )\n            if not results.ok:\n                raise Exception(f\"encryption failed: {results.message}\")\n\n    @classmethod\n    def encrypt(cls, *, key_name: str, from_file: str, to_file: str):\n        \"\"\"\n        Encrypt file *from_file* to *to_file* using the public key *key_name*.\n        \"\"\"\n        gpg = GPG()\n        with open(from_file, \"rb\") as file_in:\n            results = cls.execute(gpg.encrypt_file, file_in, key_name, output=to_file)\n        if not results.ok:\n            raise Exception(f\"encryption failed: {results}\")\n\n    @classmethod\n    def list_public_keys(cls) -&gt; list[GpgKeyModel]:\n        \"\"\"\n        Retrieve a list of the public keys.\n        \"\"\"\n        gpg = GPG()\n        return [GpgKeyModel(**record) for record in cls.execute(gpg.list_keys)]\n\n    @classmethod\n    def list_private_keys(cls) -&gt; list[GpgKeyModel]:\n        \"\"\"\n        Retrieve a list of the private keys.\n        \"\"\"\n        gpg = GPG()\n        return [GpgKeyModel(**record) for record in cls.execute(gpg.list_keys, True)]\n\n    @classmethod\n    def create_key(cls, *, key_name: str, passphrase: SecretStr) -&gt; GenKey:\n        \"\"\"\n        Create private and public keys.\n        \"\"\"\n        gpg = GPG()\n        input_data = gpg.gen_key_input(\n            name_real=key_name,\n            passphrase=passphrase.get_secret_value(),\n            name_email=f\"{key_name}@finastra.com\",\n        )\n        return cls.execute(gpg.gen_key, input_data)\n\n    @classmethod\n    def delete_public_key(cls, *, key_name: str):\n        \"\"\"\n        Delete a public key.\n        \"\"\"\n        finger_prints = [\n            key.fingerprint\n            for key in cls.list_public_keys()\n            if key.uids[0].split(\" \")[0] == key_name\n        ]\n        if len(finger_prints) == 0:\n            raise Exception(f\"{key_name} not found\")\n        elif len(finger_prints) == 1:\n            gpg = GPG()\n            cls.execute(gpg.delete_keys, finger_prints[0])\n        else:\n            raise Exception(f\"multiple {key_name} found\")\n\n    @classmethod\n    def delete_private_key(cls, *, key_name: str, passphrase: SecretStr):\n        \"\"\"\n        Delete a private key.\n        \"\"\"\n        finger_prints = [\n            key.fingerprint\n            for key in cls.list_public_keys()\n            if key.uids[0].split(\" \")[0] == key_name\n        ]\n        if len(finger_prints) == 0:\n            raise Exception(f\"{key_name} not found\")\n        elif len(finger_prints) == 1:\n            gpg = GPG()\n            cls.execute(\n                gpg.delete_keys,\n                finger_prints[0],\n                secret=True,\n                passphrase=passphrase.get_secret_value(),\n            )\n        else:\n            raise Exception(f\"multiple {key_name} found\")\n\n    @classmethod\n    def get_public_key(cls, *, key_name: str) -&gt; str:\n        \"\"\"\n        Retrieve the base64 definition of the public key.\n        \"\"\"\n        gpg = GPG()\n        return cls.execute(gpg.export_keys, key_name)\n\n    @classmethod\n    def get_private_key(cls, *, key_name: str, passphrase: SecretStr) -&gt; SecretStr:\n        \"\"\"\n        Retrieve the base64 definition of the private key.\n        \"\"\"\n        gpg = GPG()\n        return SecretStr(\n            secret_value=cls.execute(\n                gpg.export_keys,\n                key_name,\n                secret=True,\n                passphrase=passphrase.get_secret_value(),\n            )\n        )\n\n    @classmethod\n    def import_public_key(cls, *, base64: str):\n        \"\"\"\n        Install a public key.\n        \"\"\"\n        gpg = GPG()\n        result = cls.execute(gpg.import_keys, base64)\n        if result.count == 0:\n            raise Exception(\"No keys imported\")\n\n    @classmethod\n    def import_private_key(cls, *, base64: SecretStr, passphrase: SecretStr):\n        \"\"\"\n        Install a public key.\n        \"\"\"\n        gpg = GPG()\n        result = cls.execute(\n            gpg.import_keys,\n            base64.get_secret_value(),\n            passphrase=passphrase.get_secret_value(),\n        )\n        if result.count == 0:\n            raise Exception(\"No keys imported\")\n\n    @classmethod\n    def private_key_exists(cls, *, key_name: str) -&gt; bool:\n        \"\"\"Check whether the private key is installed.\"\"\"\n        finger_prints = [\n            key.fingerprint\n            for key in cls.list_private_keys()\n            if key.uids[0].split(\" \")[0] == key_name\n        ]\n        if len(finger_prints) == 0:\n            return False\n        else:\n            return True\n\n    @classmethod\n    def public_key_exists(cls, *, key_name: str) -&gt; bool:\n        \"\"\"Check whether the public key is installed.\"\"\"\n        finger_prints = [\n            key.fingerprint\n            for key in cls.list_public_keys()\n            if key.uids[0].split(\" \")[0] == key_name\n        ]\n        if len(finger_prints) == 0:\n            return False\n        else:\n            return True\n\n    @classmethod\n    def trust_key(cls, *, key_name: str, trust_level: str = \"TRUST_ULTIMATE\"):\n        \"\"\"\n        Trust a public key.\n        \"\"\"\n        finger_prints = [\n            key.fingerprint\n            for key in cls.list_public_keys()\n            if key.uids[0].split(\" \")[0] == key_name\n        ]\n        if len(finger_prints) == 0:\n            raise Exception(f\"{key_name} not found\")\n        elif len(finger_prints) == 1:\n            gpg = GPG()\n            cls.execute(gpg.trust_keys, finger_prints[0], trust_level)\n        else:\n            raise Exception(f\"multiple {key_name} found\")\n</code></pre>"},{"location":"source_code/repository/gpg/gpg.html#repository.gpg.gpg.Gpg.create_key","title":"create_key  <code>classmethod</code>","text":"<pre><code>create_key(\n    *, key_name: str, passphrase: SecretStr\n) -&gt; GenKey\n</code></pre> <p>Create private and public keys.</p> Source code in <code>repository/gpg/gpg.py</code> <pre><code>@classmethod\ndef create_key(cls, *, key_name: str, passphrase: SecretStr) -&gt; GenKey:\n    \"\"\"\n    Create private and public keys.\n    \"\"\"\n    gpg = GPG()\n    input_data = gpg.gen_key_input(\n        name_real=key_name,\n        passphrase=passphrase.get_secret_value(),\n        name_email=f\"{key_name}@finastra.com\",\n    )\n    return cls.execute(gpg.gen_key, input_data)\n</code></pre>"},{"location":"source_code/repository/gpg/gpg.html#repository.gpg.gpg.Gpg.decrypt","title":"decrypt  <code>classmethod</code>","text":"<pre><code>decrypt(\n    *, from_file: str, to_file: str, passphrase: SecretStr\n)\n</code></pre> <p>Decrypt file from_file to to_file.</p> Source code in <code>repository/gpg/gpg.py</code> <pre><code>@classmethod\ndef decrypt(cls, *, from_file: str, to_file: str, passphrase: SecretStr):\n    \"\"\"\n    Decrypt file *from_file* to *to_file*.\n    \"\"\"\n    gpg = GPG(verbose=True)\n    with open(from_file, \"rb\") as file_in:\n        results = cls.execute(\n            gpg.decrypt_file,\n            file_in,\n            passphrase=passphrase.get_secret_value(),\n            output=to_file,\n            always_trust=True,\n        )\n        if not results.ok:\n            raise Exception(f\"encryption failed: {results.message}\")\n</code></pre>"},{"location":"source_code/repository/gpg/gpg.html#repository.gpg.gpg.Gpg.delete_private_key","title":"delete_private_key  <code>classmethod</code>","text":"<pre><code>delete_private_key(*, key_name: str, passphrase: SecretStr)\n</code></pre> <p>Delete a private key.</p> Source code in <code>repository/gpg/gpg.py</code> <pre><code>@classmethod\ndef delete_private_key(cls, *, key_name: str, passphrase: SecretStr):\n    \"\"\"\n    Delete a private key.\n    \"\"\"\n    finger_prints = [\n        key.fingerprint\n        for key in cls.list_public_keys()\n        if key.uids[0].split(\" \")[0] == key_name\n    ]\n    if len(finger_prints) == 0:\n        raise Exception(f\"{key_name} not found\")\n    elif len(finger_prints) == 1:\n        gpg = GPG()\n        cls.execute(\n            gpg.delete_keys,\n            finger_prints[0],\n            secret=True,\n            passphrase=passphrase.get_secret_value(),\n        )\n    else:\n        raise Exception(f\"multiple {key_name} found\")\n</code></pre>"},{"location":"source_code/repository/gpg/gpg.html#repository.gpg.gpg.Gpg.delete_public_key","title":"delete_public_key  <code>classmethod</code>","text":"<pre><code>delete_public_key(*, key_name: str)\n</code></pre> <p>Delete a public key.</p> Source code in <code>repository/gpg/gpg.py</code> <pre><code>@classmethod\ndef delete_public_key(cls, *, key_name: str):\n    \"\"\"\n    Delete a public key.\n    \"\"\"\n    finger_prints = [\n        key.fingerprint\n        for key in cls.list_public_keys()\n        if key.uids[0].split(\" \")[0] == key_name\n    ]\n    if len(finger_prints) == 0:\n        raise Exception(f\"{key_name} not found\")\n    elif len(finger_prints) == 1:\n        gpg = GPG()\n        cls.execute(gpg.delete_keys, finger_prints[0])\n    else:\n        raise Exception(f\"multiple {key_name} found\")\n</code></pre>"},{"location":"source_code/repository/gpg/gpg.html#repository.gpg.gpg.Gpg.encrypt","title":"encrypt  <code>classmethod</code>","text":"<pre><code>encrypt(*, key_name: str, from_file: str, to_file: str)\n</code></pre> <p>Encrypt file from_file to to_file using the public key key_name.</p> Source code in <code>repository/gpg/gpg.py</code> <pre><code>@classmethod\ndef encrypt(cls, *, key_name: str, from_file: str, to_file: str):\n    \"\"\"\n    Encrypt file *from_file* to *to_file* using the public key *key_name*.\n    \"\"\"\n    gpg = GPG()\n    with open(from_file, \"rb\") as file_in:\n        results = cls.execute(gpg.encrypt_file, file_in, key_name, output=to_file)\n    if not results.ok:\n        raise Exception(f\"encryption failed: {results}\")\n</code></pre>"},{"location":"source_code/repository/gpg/gpg.html#repository.gpg.gpg.Gpg.execute","title":"execute  <code>classmethod</code>","text":"<pre><code>execute(function: Callable, *args, **kwargs)\n</code></pre> <p>Executes the gpg action.</p> Source code in <code>repository/gpg/gpg.py</code> <pre><code>@classmethod\ndef execute(cls, function: Callable, *args, **kwargs):\n    \"\"\"Executes the gpg action.\"\"\"\n    start_time = datetime.now(UTC)\n    cls.logger.debug(f\"  {function.__name__} - Started\")\n\n    results = function(*args, **kwargs)\n\n    end_time = datetime.now(UTC)\n    cls.logger.debug(\n        f\"  {function.__name__} - Completed - Runtime: {end_time - start_time}\"\n    )\n\n    return results\n</code></pre>"},{"location":"source_code/repository/gpg/gpg.html#repository.gpg.gpg.Gpg.get_private_key","title":"get_private_key  <code>classmethod</code>","text":"<pre><code>get_private_key(\n    *, key_name: str, passphrase: SecretStr\n) -&gt; SecretStr\n</code></pre> <p>Retrieve the base64 definition of the private key.</p> Source code in <code>repository/gpg/gpg.py</code> <pre><code>@classmethod\ndef get_private_key(cls, *, key_name: str, passphrase: SecretStr) -&gt; SecretStr:\n    \"\"\"\n    Retrieve the base64 definition of the private key.\n    \"\"\"\n    gpg = GPG()\n    return SecretStr(\n        secret_value=cls.execute(\n            gpg.export_keys,\n            key_name,\n            secret=True,\n            passphrase=passphrase.get_secret_value(),\n        )\n    )\n</code></pre>"},{"location":"source_code/repository/gpg/gpg.html#repository.gpg.gpg.Gpg.get_public_key","title":"get_public_key  <code>classmethod</code>","text":"<pre><code>get_public_key(*, key_name: str) -&gt; str\n</code></pre> <p>Retrieve the base64 definition of the public key.</p> Source code in <code>repository/gpg/gpg.py</code> <pre><code>@classmethod\ndef get_public_key(cls, *, key_name: str) -&gt; str:\n    \"\"\"\n    Retrieve the base64 definition of the public key.\n    \"\"\"\n    gpg = GPG()\n    return cls.execute(gpg.export_keys, key_name)\n</code></pre>"},{"location":"source_code/repository/gpg/gpg.html#repository.gpg.gpg.Gpg.import_private_key","title":"import_private_key  <code>classmethod</code>","text":"<pre><code>import_private_key(\n    *, base64: SecretStr, passphrase: SecretStr\n)\n</code></pre> <p>Install a public key.</p> Source code in <code>repository/gpg/gpg.py</code> <pre><code>@classmethod\ndef import_private_key(cls, *, base64: SecretStr, passphrase: SecretStr):\n    \"\"\"\n    Install a public key.\n    \"\"\"\n    gpg = GPG()\n    result = cls.execute(\n        gpg.import_keys,\n        base64.get_secret_value(),\n        passphrase=passphrase.get_secret_value(),\n    )\n    if result.count == 0:\n        raise Exception(\"No keys imported\")\n</code></pre>"},{"location":"source_code/repository/gpg/gpg.html#repository.gpg.gpg.Gpg.import_public_key","title":"import_public_key  <code>classmethod</code>","text":"<pre><code>import_public_key(*, base64: str)\n</code></pre> <p>Install a public key.</p> Source code in <code>repository/gpg/gpg.py</code> <pre><code>@classmethod\ndef import_public_key(cls, *, base64: str):\n    \"\"\"\n    Install a public key.\n    \"\"\"\n    gpg = GPG()\n    result = cls.execute(gpg.import_keys, base64)\n    if result.count == 0:\n        raise Exception(\"No keys imported\")\n</code></pre>"},{"location":"source_code/repository/gpg/gpg.html#repository.gpg.gpg.Gpg.list_private_keys","title":"list_private_keys  <code>classmethod</code>","text":"<pre><code>list_private_keys() -&gt; list[GpgKeyModel]\n</code></pre> <p>Retrieve a list of the private keys.</p> Source code in <code>repository/gpg/gpg.py</code> <pre><code>@classmethod\ndef list_private_keys(cls) -&gt; list[GpgKeyModel]:\n    \"\"\"\n    Retrieve a list of the private keys.\n    \"\"\"\n    gpg = GPG()\n    return [GpgKeyModel(**record) for record in cls.execute(gpg.list_keys, True)]\n</code></pre>"},{"location":"source_code/repository/gpg/gpg.html#repository.gpg.gpg.Gpg.list_public_keys","title":"list_public_keys  <code>classmethod</code>","text":"<pre><code>list_public_keys() -&gt; list[GpgKeyModel]\n</code></pre> <p>Retrieve a list of the public keys.</p> Source code in <code>repository/gpg/gpg.py</code> <pre><code>@classmethod\ndef list_public_keys(cls) -&gt; list[GpgKeyModel]:\n    \"\"\"\n    Retrieve a list of the public keys.\n    \"\"\"\n    gpg = GPG()\n    return [GpgKeyModel(**record) for record in cls.execute(gpg.list_keys)]\n</code></pre>"},{"location":"source_code/repository/gpg/gpg.html#repository.gpg.gpg.Gpg.private_key_exists","title":"private_key_exists  <code>classmethod</code>","text":"<pre><code>private_key_exists(*, key_name: str) -&gt; bool\n</code></pre> <p>Check whether the private key is installed.</p> Source code in <code>repository/gpg/gpg.py</code> <pre><code>@classmethod\ndef private_key_exists(cls, *, key_name: str) -&gt; bool:\n    \"\"\"Check whether the private key is installed.\"\"\"\n    finger_prints = [\n        key.fingerprint\n        for key in cls.list_private_keys()\n        if key.uids[0].split(\" \")[0] == key_name\n    ]\n    if len(finger_prints) == 0:\n        return False\n    else:\n        return True\n</code></pre>"},{"location":"source_code/repository/gpg/gpg.html#repository.gpg.gpg.Gpg.public_key_exists","title":"public_key_exists  <code>classmethod</code>","text":"<pre><code>public_key_exists(*, key_name: str) -&gt; bool\n</code></pre> <p>Check whether the public key is installed.</p> Source code in <code>repository/gpg/gpg.py</code> <pre><code>@classmethod\ndef public_key_exists(cls, *, key_name: str) -&gt; bool:\n    \"\"\"Check whether the public key is installed.\"\"\"\n    finger_prints = [\n        key.fingerprint\n        for key in cls.list_public_keys()\n        if key.uids[0].split(\" \")[0] == key_name\n    ]\n    if len(finger_prints) == 0:\n        return False\n    else:\n        return True\n</code></pre>"},{"location":"source_code/repository/gpg/gpg.html#repository.gpg.gpg.Gpg.trust_key","title":"trust_key  <code>classmethod</code>","text":"<pre><code>trust_key(\n    *, key_name: str, trust_level: str = \"TRUST_ULTIMATE\"\n)\n</code></pre> <p>Trust a public key.</p> Source code in <code>repository/gpg/gpg.py</code> <pre><code>@classmethod\ndef trust_key(cls, *, key_name: str, trust_level: str = \"TRUST_ULTIMATE\"):\n    \"\"\"\n    Trust a public key.\n    \"\"\"\n    finger_prints = [\n        key.fingerprint\n        for key in cls.list_public_keys()\n        if key.uids[0].split(\" \")[0] == key_name\n    ]\n    if len(finger_prints) == 0:\n        raise Exception(f\"{key_name} not found\")\n    elif len(finger_prints) == 1:\n        gpg = GPG()\n        cls.execute(gpg.trust_keys, finger_prints[0], trust_level)\n    else:\n        raise Exception(f\"multiple {key_name} found\")\n</code></pre>"},{"location":"source_code/repository/gpg/gpg_key_model.html","title":"gpg_key_model","text":""},{"location":"source_code/repository/key_vault/backup_config.html","title":"backup_config","text":""},{"location":"source_code/repository/key_vault/backup_config.html#repository.key_vault.backup_config.BackupConfig","title":"BackupConfig","text":"<p>             Bases: <code>state_machine.AbstractRepository</code></p> <p>Provides access to the client specific configurational information stored in Azure Key Vault.</p> Source code in <code>repository/key_vault/backup_config.py</code> <pre><code>class BackupConfig(AbstractRepository):\n    \"\"\"\n    Provides access to the client specific configurational information stored in Azure Key Vault.\n    \"\"\"\n\n    def __init__(self, logger: Logger, client: SecretClient):\n        self.logger = logger\n        self.client = client\n\n    def execute(self, *, secret_name: str) -&gt; str:\n        start_time = datetime.now(UTC)\n        self.logger.debug(\n            f\"  key vault secret {secret_name} from {self.client.vault_url} - Started\"\n        )\n\n        value = self.client.get_secret(secret_name).value\n        if value is None:\n            raise Exception(f\"{secret_name} not defined in key vault\")\n\n        end_time = datetime.now(UTC)\n        self.logger.debug(\n            f\"  key vault secret {secret_name} from {self.client.vault_url} - Completed - Runtime: {end_time - start_time}\"\n        )\n\n        return value\n\n    @property\n    def client_name(self) -&gt; str:\n        \"\"\"The client name.\"\"\"\n        return self.execute(secret_name=backup_config.BackupConfig.CLIENT_NAME.value)\n</code></pre>"},{"location":"source_code/repository/key_vault/backup_config.html#repository.key_vault.backup_config.BackupConfig.client_name","title":"client_name  <code>property</code>","text":"<pre><code>client_name: str\n</code></pre> <p>The client name.</p>"},{"location":"source_code/repository/key_vault/backup_config_model.html","title":"backup_config_model","text":""},{"location":"source_code/repository/key_vault/backup_config_model.html#repository.key_vault.backup_config_model.BackupConfigModel","title":"BackupConfigModel","text":"<p>             Bases: <code>pydantic.BaseModel</code></p> <p>Connection and encryption information for performing backups.</p> Source code in <code>repository/key_vault/backup_config_model.py</code> <pre><code>class BackupConfigModel(BaseModel):\n    \"\"\"Connection and encryption information for performing backups.\"\"\"\n\n    client_name: str = Field(frozen=True)\n    \"\"\"The unique identifier for the PostgreSQL instance being backed up.\"\"\"\n\n    @classmethod\n    def from_keyvault(cls, *, logger: Logger, connection_model: ServicePrincipal):\n        \"\"\"Populates the model from a key vault.\"\"\"\n        KeyVault.logger = logger\n        client = KeyVault.execute(connection_model=connection_model)\n        backup_config = BackupConfig(logger=logger, client=client)\n        return cls(\n            client_name=backup_config.client_name,\n        )\n</code></pre>"},{"location":"source_code/repository/key_vault/backup_config_model.html#repository.key_vault.backup_config_model.BackupConfigModel.client_name","title":"client_name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>client_name: str = pydantic.Field(frozen=True)\n</code></pre> <p>The unique identifier for the PostgreSQL instance being backed up.</p>"},{"location":"source_code/repository/key_vault/backup_config_model.html#repository.key_vault.backup_config_model.BackupConfigModel.from_keyvault","title":"from_keyvault  <code>classmethod</code>","text":"<pre><code>from_keyvault(\n    *, logger: Logger, connection_model: ServicePrincipal\n)\n</code></pre> <p>Populates the model from a key vault.</p> Source code in <code>repository/key_vault/backup_config_model.py</code> <pre><code>@classmethod\ndef from_keyvault(cls, *, logger: Logger, connection_model: ServicePrincipal):\n    \"\"\"Populates the model from a key vault.\"\"\"\n    KeyVault.logger = logger\n    client = KeyVault.execute(connection_model=connection_model)\n    backup_config = BackupConfig(logger=logger, client=client)\n    return cls(\n        client_name=backup_config.client_name,\n    )\n</code></pre>"},{"location":"source_code/repository/key_vault/key_vault.html","title":"key_vault","text":""},{"location":"source_code/repository/key_vault/key_vault.html#repository.key_vault.key_vault.KeyVault","title":"KeyVault","text":"<p>             Bases: <code>state_machine.AbstractRepository</code></p> <p>Interactions with Azure Key Vault.</p> Source code in <code>repository/key_vault/key_vault.py</code> <pre><code>class KeyVault(AbstractRepository):\n    \"\"\"\n    Interactions with Azure Key Vault.\n    \"\"\"\n\n    @classmethod\n    def execute(\n        cls,\n        *,\n        connection_model: ServicePrincipal,\n    ) -&gt; SecretClient:\n        start_time = datetime.now(UTC)\n        cls.logger.debug(\n            f\"  key vault client {connection_model.keyvault_host} - Started\"\n        )\n\n        results = connection_model.client\n\n        end_time = datetime.now(UTC)\n        cls.logger.debug(\n            f\"  key vault client {connection_model.keyvault_host} - Completed - Runtime: {end_time - start_time}\"\n        )\n\n        return results\n</code></pre>"},{"location":"source_code/repository/key_vault/restore_config.html","title":"restore_config","text":""},{"location":"source_code/repository/key_vault/restore_config.html#repository.key_vault.restore_config.RestoreConfig","title":"RestoreConfig","text":"<p>             Bases: <code>state_machine.AbstractRepository</code></p> <p>Provides access to the client specific configurational information stored in Azure Key Vault.</p> Source code in <code>repository/key_vault/restore_config.py</code> <pre><code>class RestoreConfig(AbstractRepository):\n    \"\"\"\n    Provides access to the client specific configurational information stored in Azure Key Vault.\n    \"\"\"\n\n    def __init__(self, *, logger: Logger, client_name: str, client: SecretClient):\n        self.logger = logger\n        self.client = client\n        self.client_name = client_name\n\n    def execute(self, *, secret_name: str) -&gt; str:\n        start_time = datetime.now(UTC)\n        self.logger.debug(\n            f\"  key vault secret {secret_name} from {self.client.vault_url} - Started\"\n        )\n\n        value = self.client.get_secret(secret_name).value\n        if value is None:\n            raise Exception(f\"{secret_name} not defined in key vault\")\n\n        end_time = datetime.now(UTC)\n        self.logger.debug(\n            f\"  key vault secret {secret_name} from {self.client.vault_url} - Completed - Runtime: {end_time - start_time}\"\n        )\n\n        return value\n\n    @property\n    def backup_config_host(self) -&gt; str:\n        \"\"\"The host of the key vault used for the backup config. Used to list secrets.\"\"\"\n        return self.execute(\n            secret_name=restore_config.RestoreConfig.BACKUP_CONFIG_HOST.value\n        )\n</code></pre>"},{"location":"source_code/repository/key_vault/restore_config.html#repository.key_vault.restore_config.RestoreConfig.backup_config_host","title":"backup_config_host  <code>property</code>","text":"<pre><code>backup_config_host: str\n</code></pre> <p>The host of the key vault used for the backup config. Used to list secrets.</p>"},{"location":"source_code/repository/key_vault/restore_config_model.html","title":"restore_config_model","text":""},{"location":"source_code/repository/key_vault/restore_config_model.html#repository.key_vault.restore_config_model.RestoreConfigModel","title":"RestoreConfigModel","text":"<p>             Bases: <code>pydantic.BaseModel</code></p> <p>Connection and encryption information for performing restorations.</p> Source code in <code>repository/key_vault/restore_config_model.py</code> <pre><code>class RestoreConfigModel(BaseModel):\n    \"\"\"Connection and encryption information for performing restorations.\"\"\"\n\n    backup_config_host: str = Field(frozen=True)\n    \"\"\"The host of the key vault used for the backup config. Used to list secrets.\"\"\"\n\n    @classmethod\n    def from_keyvault(\n        cls, *, logger: Logger, client_name: str, connection_model: ServicePrincipal\n    ):\n        \"\"\"Populates the model from a key vault.\"\"\"\n        KeyVault.logger = logger\n        client = KeyVault.execute(connection_model=connection_model)\n        restore_config = RestoreConfig(\n            logger=logger, client_name=client_name, client=client\n        )\n        return cls(\n            backup_config_host=restore_config.backup_config_host,\n        )\n</code></pre>"},{"location":"source_code/repository/key_vault/restore_config_model.html#repository.key_vault.restore_config_model.RestoreConfigModel.backup_config_host","title":"backup_config_host  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>backup_config_host: str = pydantic.Field(frozen=True)\n</code></pre> <p>The host of the key vault used for the backup config. Used to list secrets.</p>"},{"location":"source_code/repository/key_vault/restore_config_model.html#repository.key_vault.restore_config_model.RestoreConfigModel.from_keyvault","title":"from_keyvault  <code>classmethod</code>","text":"<pre><code>from_keyvault(\n    *,\n    logger: Logger,\n    client_name: str,\n    connection_model: ServicePrincipal\n)\n</code></pre> <p>Populates the model from a key vault.</p> Source code in <code>repository/key_vault/restore_config_model.py</code> <pre><code>@classmethod\ndef from_keyvault(\n    cls, *, logger: Logger, client_name: str, connection_model: ServicePrincipal\n):\n    \"\"\"Populates the model from a key vault.\"\"\"\n    KeyVault.logger = logger\n    client = KeyVault.execute(connection_model=connection_model)\n    restore_config = RestoreConfig(\n        logger=logger, client_name=client_name, client=client\n    )\n    return cls(\n        backup_config_host=restore_config.backup_config_host,\n    )\n</code></pre>"},{"location":"source_code/repository/process/process.html","title":"process","text":""},{"location":"source_code/repository/process/process.html#repository.process.process.Process","title":"Process","text":"<p>             Bases: <code>state_machine.AbstractRepository</code></p> <p>Process related things (print, input, exit...) to allow mocking.</p> Source code in <code>repository/process/process.py</code> <pre><code>class Process(AbstractRepository):\n    \"\"\"\n    Process related things (print, input, exit...) to allow mocking.\n    \"\"\"\n\n    @classmethod\n    def execute(cls, function: Callable, *args, **kwargs) -&gt; Any:\n        start_time = datetime.now(UTC)\n        cls.logger.debug(f\"  {cls.__name__} - Started\")\n\n        result = function(*args, **kwargs)\n\n        end_time = datetime.now(UTC)\n        cls.logger.debug(\n            f\"  {cls.__name__} - Completed - Runtime: {end_time - start_time}\"\n        )\n\n        return result\n\n    @classmethod\n    def exit(cls, *, result: int):\n        \"\"\"\n        Exits the process with the value in _result_.\n        \"\"\"\n        cls.logger.debug(f\"Exiting with {result}\")\n        exit(result)\n\n    @classmethod\n    def input(cls, *, prompt: str) -&gt; str:\n        \"\"\"\n        Input from the command line.\n        \"\"\"\n        return cls.execute(input, prompt)\n\n    @classmethod\n    def password(cls, *, prompt: str) -&gt; str:\n        \"\"\"\n        Hidden input from the command line.\n        \"\"\"\n        return cls.execute(getpass, prompt)\n\n    @classmethod\n    def write_to_stderr(cls, *, content: str):\n        \"\"\"\n        Outputs to stderr.\n        \"\"\"\n        cls.execute(print, content, file=sys.stderr)\n\n    @classmethod\n    def write_to_stdout(cls, *, content: str):\n        \"\"\"\n        Outputs to stdout.\n        \"\"\"\n        cls.execute(print, content)\n</code></pre>"},{"location":"source_code/repository/process/process.html#repository.process.process.Process.exit","title":"exit  <code>classmethod</code>","text":"<pre><code>exit(*, result: int)\n</code></pre> <p>Exits the process with the value in result.</p> Source code in <code>repository/process/process.py</code> <pre><code>@classmethod\ndef exit(cls, *, result: int):\n    \"\"\"\n    Exits the process with the value in _result_.\n    \"\"\"\n    cls.logger.debug(f\"Exiting with {result}\")\n    exit(result)\n</code></pre>"},{"location":"source_code/repository/process/process.html#repository.process.process.Process.input","title":"input  <code>classmethod</code>","text":"<pre><code>input(*, prompt: str) -&gt; str\n</code></pre> <p>Input from the command line.</p> Source code in <code>repository/process/process.py</code> <pre><code>@classmethod\ndef input(cls, *, prompt: str) -&gt; str:\n    \"\"\"\n    Input from the command line.\n    \"\"\"\n    return cls.execute(input, prompt)\n</code></pre>"},{"location":"source_code/repository/process/process.html#repository.process.process.Process.password","title":"password  <code>classmethod</code>","text":"<pre><code>password(*, prompt: str) -&gt; str\n</code></pre> <p>Hidden input from the command line.</p> Source code in <code>repository/process/process.py</code> <pre><code>@classmethod\ndef password(cls, *, prompt: str) -&gt; str:\n    \"\"\"\n    Hidden input from the command line.\n    \"\"\"\n    return cls.execute(getpass, prompt)\n</code></pre>"},{"location":"source_code/repository/process/process.html#repository.process.process.Process.write_to_stderr","title":"write_to_stderr  <code>classmethod</code>","text":"<pre><code>write_to_stderr(*, content: str)\n</code></pre> <p>Outputs to stderr.</p> Source code in <code>repository/process/process.py</code> <pre><code>@classmethod\ndef write_to_stderr(cls, *, content: str):\n    \"\"\"\n    Outputs to stderr.\n    \"\"\"\n    cls.execute(print, content, file=sys.stderr)\n</code></pre>"},{"location":"source_code/repository/process/process.html#repository.process.process.Process.write_to_stdout","title":"write_to_stdout  <code>classmethod</code>","text":"<pre><code>write_to_stdout(*, content: str)\n</code></pre> <p>Outputs to stdout.</p> Source code in <code>repository/process/process.py</code> <pre><code>@classmethod\ndef write_to_stdout(cls, *, content: str):\n    \"\"\"\n    Outputs to stdout.\n    \"\"\"\n    cls.execute(print, content)\n</code></pre>"},{"location":"source_code/repository/shell/command.html","title":"command","text":""},{"location":"source_code/repository/shell/command.html#repository.shell.command.Command","title":"Command","text":"<p>             Bases: <code>state_machine.AbstractRepository</code></p> <p>Base class for executing command line actions.</p> Source code in <code>repository/shell/command.py</code> <pre><code>class Command(AbstractRepository):\n    \"\"\"\n    Base class for executing command line actions.\n    \"\"\"\n\n    @classmethod\n    def execute(\n        cls,\n        *,\n        command: SpaceDelimited,\n        cwd: Optional[str] = None,\n        env: _Environ = environ,\n        start_new_session: bool = False,\n        input: Optional[str] = None,\n    ) -&gt; subprocess.CompletedProcess[str]:\n        \"\"\"\n        Executes the command line action.\n\n        raises:\n            Exception: If exit code is not zero.\n        \"\"\"\n        start_time = datetime.now(UTC)\n        cls.logger.debug(f\"  {command} - Started\")\n\n        result = subprocess.run(\n            command.get_secret_value(),\n            capture_output=True,\n            env=env,\n            cwd=cwd,\n            text=True,\n            start_new_session=start_new_session,\n            input=input,\n        )\n\n        end_time = datetime.now(UTC)\n        if result.returncode != 0:\n            cls.logger.debug(\n                f\"  {command} - Error: {result.returncode} - Runtime: {end_time - start_time}\"\n            )\n            raise Exception(result.stderr)\n\n        cls.logger.debug(f\"  {command} - Completed - Runtime: {end_time - start_time}\")\n\n        return result\n</code></pre>"},{"location":"source_code/repository/shell/command.html#repository.shell.command.Command.execute","title":"execute  <code>classmethod</code>","text":"<pre><code>execute(\n    *,\n    command: SpaceDelimited,\n    cwd: Optional[str] = None,\n    env: _Environ = environ,\n    start_new_session: bool = False,\n    input: Optional[str] = None\n) -&gt; subprocess.CompletedProcess[str]\n</code></pre> <p>Executes the command line action.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If exit code is not zero.</p> Source code in <code>repository/shell/command.py</code> <pre><code>@classmethod\ndef execute(\n    cls,\n    *,\n    command: SpaceDelimited,\n    cwd: Optional[str] = None,\n    env: _Environ = environ,\n    start_new_session: bool = False,\n    input: Optional[str] = None,\n) -&gt; subprocess.CompletedProcess[str]:\n    \"\"\"\n    Executes the command line action.\n\n    raises:\n        Exception: If exit code is not zero.\n    \"\"\"\n    start_time = datetime.now(UTC)\n    cls.logger.debug(f\"  {command} - Started\")\n\n    result = subprocess.run(\n        command.get_secret_value(),\n        capture_output=True,\n        env=env,\n        cwd=cwd,\n        text=True,\n        start_new_session=start_new_session,\n        input=input,\n    )\n\n    end_time = datetime.now(UTC)\n    if result.returncode != 0:\n        cls.logger.debug(\n            f\"  {command} - Error: {result.returncode} - Runtime: {end_time - start_time}\"\n        )\n        raise Exception(result.stderr)\n\n    cls.logger.debug(f\"  {command} - Completed - Runtime: {end_time - start_time}\")\n\n    return result\n</code></pre>"},{"location":"source_code/repository/shell/file_system.html","title":"file_system","text":""},{"location":"source_code/repository/shell/file_system.html#repository.shell.file_system.FileSystem","title":"FileSystem","text":"<p>             Bases: <code>repository.shell.command.Command</code></p> <p>Commonly used file system commands.</p> Source code in <code>repository/shell/file_system.py</code> <pre><code>class FileSystem(Command):\n    \"\"\"\n    Commonly used file system commands.\n    \"\"\"\n\n    @classmethod\n    def chown(cls, *, path: str, user: str, group: str):\n        \"\"\"\n        Change ownership of *path* for *user*:*group*.\n\n        raises:\n            Exception: If exit code is not zero.\n        \"\"\"\n        command = SpaceDelimited(\n            line=(\"sudo\", \"-S\", \"chown\", \"-R\", f\"{user}:{group}\", path)\n        )\n\n        cls.execute(command=command)\n\n    @classmethod\n    def is_mounted(cls, *, path: str) -&gt; bool:\n        \"\"\"\n        Determine whether the path is mounted to a file share.\n\n        raises:\n            Exception: If exit code is not zero.\n        \"\"\"\n        command = SpaceDelimited(line=(\"findmnt\", \"-T\", path))\n\n        result = cls.execute(command=command)\n\n        lines = result.stdout.split(\"\\n\")\n        source_start = lines[0].find(\"SOURCE\")\n\n        return lines[1][source_start:].startswith(\"//\")\n\n    @classmethod\n    def mount_storage(\n        cls,\n        *,\n        unc: str,\n        mount_path: str,\n        account_name: str,\n        account_key: SecretStr,\n        user_id: str,\n        actimeo: int = 30,\n    ):\n        \"\"\"\n        Mount a file share on a storage account.\n\n        raises:\n            Exception: If exit code is not zero.\n        \"\"\"\n        command = SpaceDelimited(\n            line=(\n                \"sudo\",\n                \"-S\",\n                \"mount\",\n                \"-t\",\n                \"cifs\",\n                unc,\n                mount_path,\n                \"-o\",\n                CommaDelimited(\n                    line=(\n                        EqualDelimited(left=\"username\", right=account_name),\n                        EqualDelimited(left=\"password\", right=account_key),\n                        \"serverino\",\n                        \"nosharesock\",\n                        EqualDelimited(left=\"actimeo\", right=str(actimeo)),\n                        \"mfsymlinks\",\n                        EqualDelimited(left=\"uid\", right=user_id),\n                        EqualDelimited(left=\"gid\", right=user_id),\n                    )\n                ),\n            )\n        )\n\n        cls.execute(command=command)\n\n    @classmethod\n    def unmount_storage(cls, *, mount_path: str):\n        \"\"\"\n        Unmount a storage account.\n\n        raises:\n            Exception: If exit code is not zero.\n        \"\"\"\n        command = SpaceDelimited(line=(\"sudo\", \"-S\", \"umount\", \"-l\", mount_path))\n\n        cls.execute(command=command)\n\n    @classmethod\n    def user_id(cls) -&gt; str:\n        \"\"\"\n        Fetch the id of the current user.\n\n        raises:\n            Exception: If exit code is not zero.\n        \"\"\"\n        command = SpaceDelimited(line=(\"id\", \"-u\"))\n\n        result = cls.execute(command=command)\n\n        return result.stdout.strip()\n\n    @classmethod\n    def what_is_mounted(cls, *, path: str) -&gt; str:\n        \"\"\"\n        Report what a path is mounted to.\n\n        raises:\n            Exception: If exit code is not zero.\n        \"\"\"\n        command = SpaceDelimited(line=(\"findmnt\", \"-T\", path))\n\n        result = cls.execute(command=command)\n\n        lines = result.stdout.split(\"\\n\")\n        source_start = lines[0].find(\"SOURCE\")\n        source_end = lines[0].find(\"FSTYPE\")\n\n        return lines[1][source_start:source_end].strip()\n</code></pre>"},{"location":"source_code/repository/shell/file_system.html#repository.shell.file_system.FileSystem.chown","title":"chown  <code>classmethod</code>","text":"<pre><code>chown(*, path: str, user: str, group: str)\n</code></pre> <p>Change ownership of path for user:group.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If exit code is not zero.</p> Source code in <code>repository/shell/file_system.py</code> <pre><code>@classmethod\ndef chown(cls, *, path: str, user: str, group: str):\n    \"\"\"\n    Change ownership of *path* for *user*:*group*.\n\n    raises:\n        Exception: If exit code is not zero.\n    \"\"\"\n    command = SpaceDelimited(\n        line=(\"sudo\", \"-S\", \"chown\", \"-R\", f\"{user}:{group}\", path)\n    )\n\n    cls.execute(command=command)\n</code></pre>"},{"location":"source_code/repository/shell/file_system.html#repository.shell.file_system.FileSystem.is_mounted","title":"is_mounted  <code>classmethod</code>","text":"<pre><code>is_mounted(*, path: str) -&gt; bool\n</code></pre> <p>Determine whether the path is mounted to a file share.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If exit code is not zero.</p> Source code in <code>repository/shell/file_system.py</code> <pre><code>@classmethod\ndef is_mounted(cls, *, path: str) -&gt; bool:\n    \"\"\"\n    Determine whether the path is mounted to a file share.\n\n    raises:\n        Exception: If exit code is not zero.\n    \"\"\"\n    command = SpaceDelimited(line=(\"findmnt\", \"-T\", path))\n\n    result = cls.execute(command=command)\n\n    lines = result.stdout.split(\"\\n\")\n    source_start = lines[0].find(\"SOURCE\")\n\n    return lines[1][source_start:].startswith(\"//\")\n</code></pre>"},{"location":"source_code/repository/shell/file_system.html#repository.shell.file_system.FileSystem.mount_storage","title":"mount_storage  <code>classmethod</code>","text":"<pre><code>mount_storage(\n    *,\n    unc: str,\n    mount_path: str,\n    account_name: str,\n    account_key: SecretStr,\n    user_id: str,\n    actimeo: int = 30\n)\n</code></pre> <p>Mount a file share on a storage account.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If exit code is not zero.</p> Source code in <code>repository/shell/file_system.py</code> <pre><code>@classmethod\ndef mount_storage(\n    cls,\n    *,\n    unc: str,\n    mount_path: str,\n    account_name: str,\n    account_key: SecretStr,\n    user_id: str,\n    actimeo: int = 30,\n):\n    \"\"\"\n    Mount a file share on a storage account.\n\n    raises:\n        Exception: If exit code is not zero.\n    \"\"\"\n    command = SpaceDelimited(\n        line=(\n            \"sudo\",\n            \"-S\",\n            \"mount\",\n            \"-t\",\n            \"cifs\",\n            unc,\n            mount_path,\n            \"-o\",\n            CommaDelimited(\n                line=(\n                    EqualDelimited(left=\"username\", right=account_name),\n                    EqualDelimited(left=\"password\", right=account_key),\n                    \"serverino\",\n                    \"nosharesock\",\n                    EqualDelimited(left=\"actimeo\", right=str(actimeo)),\n                    \"mfsymlinks\",\n                    EqualDelimited(left=\"uid\", right=user_id),\n                    EqualDelimited(left=\"gid\", right=user_id),\n                )\n            ),\n        )\n    )\n\n    cls.execute(command=command)\n</code></pre>"},{"location":"source_code/repository/shell/file_system.html#repository.shell.file_system.FileSystem.unmount_storage","title":"unmount_storage  <code>classmethod</code>","text":"<pre><code>unmount_storage(*, mount_path: str)\n</code></pre> <p>Unmount a storage account.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If exit code is not zero.</p> Source code in <code>repository/shell/file_system.py</code> <pre><code>@classmethod\ndef unmount_storage(cls, *, mount_path: str):\n    \"\"\"\n    Unmount a storage account.\n\n    raises:\n        Exception: If exit code is not zero.\n    \"\"\"\n    command = SpaceDelimited(line=(\"sudo\", \"-S\", \"umount\", \"-l\", mount_path))\n\n    cls.execute(command=command)\n</code></pre>"},{"location":"source_code/repository/shell/file_system.html#repository.shell.file_system.FileSystem.user_id","title":"user_id  <code>classmethod</code>","text":"<pre><code>user_id() -&gt; str\n</code></pre> <p>Fetch the id of the current user.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If exit code is not zero.</p> Source code in <code>repository/shell/file_system.py</code> <pre><code>@classmethod\ndef user_id(cls) -&gt; str:\n    \"\"\"\n    Fetch the id of the current user.\n\n    raises:\n        Exception: If exit code is not zero.\n    \"\"\"\n    command = SpaceDelimited(line=(\"id\", \"-u\"))\n\n    result = cls.execute(command=command)\n\n    return result.stdout.strip()\n</code></pre>"},{"location":"source_code/repository/shell/file_system.html#repository.shell.file_system.FileSystem.what_is_mounted","title":"what_is_mounted  <code>classmethod</code>","text":"<pre><code>what_is_mounted(*, path: str) -&gt; str\n</code></pre> <p>Report what a path is mounted to.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If exit code is not zero.</p> Source code in <code>repository/shell/file_system.py</code> <pre><code>@classmethod\ndef what_is_mounted(cls, *, path: str) -&gt; str:\n    \"\"\"\n    Report what a path is mounted to.\n\n    raises:\n        Exception: If exit code is not zero.\n    \"\"\"\n    command = SpaceDelimited(line=(\"findmnt\", \"-T\", path))\n\n    result = cls.execute(command=command)\n\n    lines = result.stdout.split(\"\\n\")\n    source_start = lines[0].find(\"SOURCE\")\n    source_end = lines[0].find(\"FSTYPE\")\n\n    return lines[1][source_start:source_end].strip()\n</code></pre>"},{"location":"source_code/repository/shell/pg_dump.html","title":"pg_dump","text":""},{"location":"source_code/repository/shell/pg_dump.html#repository.shell.pg_dump.PgDump","title":"PgDump","text":"<p>             Bases: <code>repository.shell.command.Command</code></p> <p>Interacting with pg_dump.</p> Source code in <code>repository/shell/pg_dump.py</code> <pre><code>class PgDump(Command):\n    \"\"\"\n    Interacting with pg_dump.\n    \"\"\"\n\n    @classmethod\n    def dump_data(cls, *, connection_model: ServicePrincipal, path: str):\n        \"\"\"\n        Pulls a SQL rendering of the data in the database to path.\n\n        raises:\n            Exception: If exit code is not zero.\n        \"\"\"\n        command = SpaceDelimited(\n            line=(\n                \"pg_dump\",\n                \"-h\",\n                connection_model.host,\n                \"-p\",\n                str(connection_model.port),\n                \"-U\",\n                connection_model.service_principal_id,\n                \"--no-owner\",\n                \"--data-only\",\n                connection_model.database,\n                \"--file\",\n                path,\n            )\n        )\n\n        cls.execute(command=command, connection_model=connection_model)\n\n    @classmethod\n    def dump_roles(cls, *, connection_model: ServicePrincipal, path: str):\n        \"\"\"\n        Pulls a SQL rendering of the roles in the database to path.\n\n        raises:\n            Exception: If exit code is not zero.\n        \"\"\"\n        command = SpaceDelimited(\n            line=(\n                \"pg_dumpall\",\n                \"-h\",\n                connection_model.host,\n                \"-p\",\n                str(connection_model.port),\n                \"-U\",\n                connection_model.service_principal_id,\n                \"--quote-all-identifiers\",\n                \"--no-role-passwords\",\n                \"--roles-only\",\n                \"--file\",\n                path,\n            )\n        )\n\n        cls.execute(command=command, connection_model=connection_model)\n\n    @classmethod\n    def dump_schema(cls, *, connection_model: ServicePrincipal, path: str):\n        \"\"\"\n        Pulls a SQL rendering of the schema for the database to path.  Ownership is not backed up.\n\n        raises:\n            Exception: If exit code is not zero.\n        \"\"\"\n        command = SpaceDelimited(\n            line=(\n                \"pg_dump\",\n                \"-h\",\n                connection_model.host,\n                \"-p\",\n                str(connection_model.port),\n                \"-U\",\n                connection_model.service_principal_id,\n                \"--no-owner\",\n                \"--schema-only\",\n                connection_model.database,\n                \"--file\",\n                path,\n            )\n        )\n\n        cls.execute(command=command, connection_model=connection_model)\n\n    @classmethod\n    def execute(cls, *, command: SpaceDelimited, connection_model: ServicePrincipal):\n        \"\"\"\n        Executes a pg_dump statement.\n        \"\"\"\n        env = os.environ\n        env[\"PGSSLMODE\"] = \"require\"\n        env[\"PGPASSWORD\"] = connection_model.token.get_secret_value()\n\n        super().execute(\n            command=command,\n            env=env,\n        )\n</code></pre>"},{"location":"source_code/repository/shell/pg_dump.html#repository.shell.pg_dump.PgDump.dump_data","title":"dump_data  <code>classmethod</code>","text":"<pre><code>dump_data(*, connection_model: ServicePrincipal, path: str)\n</code></pre> <p>Pulls a SQL rendering of the data in the database to path.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If exit code is not zero.</p> Source code in <code>repository/shell/pg_dump.py</code> <pre><code>@classmethod\ndef dump_data(cls, *, connection_model: ServicePrincipal, path: str):\n    \"\"\"\n    Pulls a SQL rendering of the data in the database to path.\n\n    raises:\n        Exception: If exit code is not zero.\n    \"\"\"\n    command = SpaceDelimited(\n        line=(\n            \"pg_dump\",\n            \"-h\",\n            connection_model.host,\n            \"-p\",\n            str(connection_model.port),\n            \"-U\",\n            connection_model.service_principal_id,\n            \"--no-owner\",\n            \"--data-only\",\n            connection_model.database,\n            \"--file\",\n            path,\n        )\n    )\n\n    cls.execute(command=command, connection_model=connection_model)\n</code></pre>"},{"location":"source_code/repository/shell/pg_dump.html#repository.shell.pg_dump.PgDump.dump_roles","title":"dump_roles  <code>classmethod</code>","text":"<pre><code>dump_roles(\n    *, connection_model: ServicePrincipal, path: str\n)\n</code></pre> <p>Pulls a SQL rendering of the roles in the database to path.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If exit code is not zero.</p> Source code in <code>repository/shell/pg_dump.py</code> <pre><code>@classmethod\ndef dump_roles(cls, *, connection_model: ServicePrincipal, path: str):\n    \"\"\"\n    Pulls a SQL rendering of the roles in the database to path.\n\n    raises:\n        Exception: If exit code is not zero.\n    \"\"\"\n    command = SpaceDelimited(\n        line=(\n            \"pg_dumpall\",\n            \"-h\",\n            connection_model.host,\n            \"-p\",\n            str(connection_model.port),\n            \"-U\",\n            connection_model.service_principal_id,\n            \"--quote-all-identifiers\",\n            \"--no-role-passwords\",\n            \"--roles-only\",\n            \"--file\",\n            path,\n        )\n    )\n\n    cls.execute(command=command, connection_model=connection_model)\n</code></pre>"},{"location":"source_code/repository/shell/pg_dump.html#repository.shell.pg_dump.PgDump.dump_schema","title":"dump_schema  <code>classmethod</code>","text":"<pre><code>dump_schema(\n    *, connection_model: ServicePrincipal, path: str\n)\n</code></pre> <p>Pulls a SQL rendering of the schema for the database to path.  Ownership is not backed up.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If exit code is not zero.</p> Source code in <code>repository/shell/pg_dump.py</code> <pre><code>@classmethod\ndef dump_schema(cls, *, connection_model: ServicePrincipal, path: str):\n    \"\"\"\n    Pulls a SQL rendering of the schema for the database to path.  Ownership is not backed up.\n\n    raises:\n        Exception: If exit code is not zero.\n    \"\"\"\n    command = SpaceDelimited(\n        line=(\n            \"pg_dump\",\n            \"-h\",\n            connection_model.host,\n            \"-p\",\n            str(connection_model.port),\n            \"-U\",\n            connection_model.service_principal_id,\n            \"--no-owner\",\n            \"--schema-only\",\n            connection_model.database,\n            \"--file\",\n            path,\n        )\n    )\n\n    cls.execute(command=command, connection_model=connection_model)\n</code></pre>"},{"location":"source_code/repository/shell/pg_dump.html#repository.shell.pg_dump.PgDump.execute","title":"execute  <code>classmethod</code>","text":"<pre><code>execute(\n    *,\n    command: SpaceDelimited,\n    connection_model: ServicePrincipal\n)\n</code></pre> <p>Executes a pg_dump statement.</p> Source code in <code>repository/shell/pg_dump.py</code> <pre><code>@classmethod\ndef execute(cls, *, command: SpaceDelimited, connection_model: ServicePrincipal):\n    \"\"\"\n    Executes a pg_dump statement.\n    \"\"\"\n    env = os.environ\n    env[\"PGSSLMODE\"] = \"require\"\n    env[\"PGPASSWORD\"] = connection_model.token.get_secret_value()\n\n    super().execute(\n        command=command,\n        env=env,\n    )\n</code></pre>"},{"location":"source_code/repository/shell/psql.html","title":"psql","text":""},{"location":"source_code/repository/shell/psql.html#repository.shell.psql.Psql","title":"Psql","text":"<p>             Bases: <code>repository.shell.command.Command</code></p> <p>Interactions with psql.</p> Source code in <code>repository/shell/psql.py</code> <pre><code>class Psql(Command):\n    \"\"\"\n    Interactions with psql.\n    \"\"\"\n\n    @classmethod\n    def execute(\n        cls,\n        *,\n        command: SpaceDelimited,\n        connection_model: User,\n    ):\n        \"\"\"\n        Executes a psql action.\n        \"\"\"\n        env = os.environ\n        env[\"PGSSLMODE\"] = \"require\"\n\n        super().execute(\n            command=command,\n            env=env,\n            start_new_session=True,\n            input=connection_model.password.get_secret_value(),\n        )\n\n    @classmethod\n    def restore(cls, *, connection_model: User, path: str):\n        \"\"\"\n        Restores a SQL rendering of a PostgreSQL backup.  Sets PGSSLMODE to \"require\".  Password is provided by automating the\n        response the \"Password:\" challenge prompt.\n\n        raises:\n            Exception: If exit code is not zero.\n        \"\"\"\n        command = SpaceDelimited(\n            line=(\n                \"psql\",\n                \"-h\",\n                connection_model.host,\n                \"-p\",\n                str(connection_model.port),\n                \"-U\",\n                connection_model.username,\n                \"-d\",\n                connection_model.database,\n                \"--file\",\n                path,\n            )\n        )\n\n        cls.execute(command=command, connection_model=connection_model)\n</code></pre>"},{"location":"source_code/repository/shell/psql.html#repository.shell.psql.Psql.execute","title":"execute  <code>classmethod</code>","text":"<pre><code>execute(*, command: SpaceDelimited, connection_model: User)\n</code></pre> <p>Executes a psql action.</p> Source code in <code>repository/shell/psql.py</code> <pre><code>@classmethod\ndef execute(\n    cls,\n    *,\n    command: SpaceDelimited,\n    connection_model: User,\n):\n    \"\"\"\n    Executes a psql action.\n    \"\"\"\n    env = os.environ\n    env[\"PGSSLMODE\"] = \"require\"\n\n    super().execute(\n        command=command,\n        env=env,\n        start_new_session=True,\n        input=connection_model.password.get_secret_value(),\n    )\n</code></pre>"},{"location":"source_code/repository/shell/psql.html#repository.shell.psql.Psql.restore","title":"restore  <code>classmethod</code>","text":"<pre><code>restore(*, connection_model: User, path: str)\n</code></pre> <p>Restores a SQL rendering of a PostgreSQL backup.  Sets PGSSLMODE to \"require\".  Password is provided by automating the response the \"Password:\" challenge prompt.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If exit code is not zero.</p> Source code in <code>repository/shell/psql.py</code> <pre><code>@classmethod\ndef restore(cls, *, connection_model: User, path: str):\n    \"\"\"\n    Restores a SQL rendering of a PostgreSQL backup.  Sets PGSSLMODE to \"require\".  Password is provided by automating the\n    response the \"Password:\" challenge prompt.\n\n    raises:\n        Exception: If exit code is not zero.\n    \"\"\"\n    command = SpaceDelimited(\n        line=(\n            \"psql\",\n            \"-h\",\n            connection_model.host,\n            \"-p\",\n            str(connection_model.port),\n            \"-U\",\n            connection_model.username,\n            \"-d\",\n            connection_model.database,\n            \"--file\",\n            path,\n        )\n    )\n\n    cls.execute(command=command, connection_model=connection_model)\n</code></pre>"},{"location":"source_code/repository/shell/tar.html","title":"tar","text":""},{"location":"source_code/repository/shell/tar.html#repository.shell.tar.Tar","title":"Tar","text":"<p>             Bases: <code>repository.shell.command.Command</code></p> <p>Interations with tar.</p> Source code in <code>repository/shell/tar.py</code> <pre><code>class Tar(Command):\n    \"\"\"\n    Interations with tar.\n    \"\"\"\n\n    @classmethod\n    def cjf_with_removal(\n        cls, *, directory_to_run_in: str, directory_to_tar: str, tarball: str\n    ):\n        \"\"\"\n        Tars the directory specified by *directory_to_tar* located in *directory_to_run_in* to the tarball specified by *tarball*.\n        Uses bzip compression and removes *directory_to_tar* when complete.  Runs in the working directory specified by\n        *directory_to_run_in*.\n\n        raises:\n            Exception: If exit code is not zero.\n        \"\"\"\n        command = SpaceDelimited(\n            line=(\"tar\", \"-cjf\", directory_to_tar, tarball, \"--remove-files\")\n        )\n\n        cls.execute(command=command, cwd=directory_to_run_in)\n\n    @classmethod\n    def xjf(cls, *, tarball: str, path: str):\n        \"\"\"\n        Untars the tarball specified by *file_name* to the location specified by *path*.  Expects a tarball with bzip compression.\n\n        raises:\n            Exception: If exit code is not zero.\n        \"\"\"\n        command = SpaceDelimited(line=(\"tar\", \"-xjf\", tarball, \"-C\", path))\n\n        cls.execute(command=command)\n</code></pre>"},{"location":"source_code/repository/shell/tar.html#repository.shell.tar.Tar.cjf_with_removal","title":"cjf_with_removal  <code>classmethod</code>","text":"<pre><code>cjf_with_removal(\n    *,\n    directory_to_run_in: str,\n    directory_to_tar: str,\n    tarball: str\n)\n</code></pre> <p>Tars the directory specified by directory_to_tar located in directory_to_run_in to the tarball specified by tarball. Uses bzip compression and removes directory_to_tar when complete.  Runs in the working directory specified by directory_to_run_in.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If exit code is not zero.</p> Source code in <code>repository/shell/tar.py</code> <pre><code>@classmethod\ndef cjf_with_removal(\n    cls, *, directory_to_run_in: str, directory_to_tar: str, tarball: str\n):\n    \"\"\"\n    Tars the directory specified by *directory_to_tar* located in *directory_to_run_in* to the tarball specified by *tarball*.\n    Uses bzip compression and removes *directory_to_tar* when complete.  Runs in the working directory specified by\n    *directory_to_run_in*.\n\n    raises:\n        Exception: If exit code is not zero.\n    \"\"\"\n    command = SpaceDelimited(\n        line=(\"tar\", \"-cjf\", directory_to_tar, tarball, \"--remove-files\")\n    )\n\n    cls.execute(command=command, cwd=directory_to_run_in)\n</code></pre>"},{"location":"source_code/repository/shell/tar.html#repository.shell.tar.Tar.xjf","title":"xjf  <code>classmethod</code>","text":"<pre><code>xjf(*, tarball: str, path: str)\n</code></pre> <p>Untars the tarball specified by file_name to the location specified by path.  Expects a tarball with bzip compression.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If exit code is not zero.</p> Source code in <code>repository/shell/tar.py</code> <pre><code>@classmethod\ndef xjf(cls, *, tarball: str, path: str):\n    \"\"\"\n    Untars the tarball specified by *file_name* to the location specified by *path*.  Expects a tarball with bzip compression.\n\n    raises:\n        Exception: If exit code is not zero.\n    \"\"\"\n    command = SpaceDelimited(line=(\"tar\", \"-xjf\", tarball, \"-C\", path))\n\n    cls.execute(command=command)\n</code></pre>"},{"location":"source_code/repository/shell/az/ad.html","title":"ad","text":""},{"location":"source_code/repository/shell/az/ad.html#repository.shell.az.ad.Ad","title":"Ad","text":"<p>             Bases: <code>repository.shell.az.az.Az</code></p> <p>Interacting with Entra Id.</p> Source code in <code>repository/shell/az/ad.py</code> <pre><code>class Ad(Az):\n    \"\"\"\n    Interacting with Entra Id.\n    \"\"\"\n\n    @classmethod\n    def app_credential_reset(\n        cls, *, application_id: str, name: str, end_date: datetime\n    ) -&gt; SecretStr:\n        \"\"\"\n        Resets the client secret for a service principal.\n\n        raises:\n            Exception: If exit code is not zero.\n        \"\"\"\n        command = SpaceDelimited(\n            line=(\n                \"az\",\n                \"ad\",\n                \"app\",\n                \"credential\",\n                \"reset\",\n                \"--id\",\n                application_id,\n                \"--display-name\",\n                name,\n                \"--end-date\",\n                end_date.strftime(\"%Y-%m-%dT%H:%M:%S+00:00\"),\n            )\n        )\n\n        return SecretStr(secret_value=cls.execute(command=command)[\"password\"])\n\n    @classmethod\n    def sp_list(\n        cls, *, service_principal_name: str\n    ) -&gt; dict:\n        \"\"\"\n        Returns the definition information for a service principal.\n        \"\"\"\n        command = SpaceDelimited(\n            line=(\n                \"az\",\n                \"ad\",\n                \"sp\",\n                \"list\",\n                \"--display-name\",\n                service_principal_name\n            ),\n        )\n        results = cls.execute(command=command)\n\n        return {\n            \"application_id\": results[0][\"appId\"],\n            \"object_id\": results[0][\"id\"],\n        }\n</code></pre>"},{"location":"source_code/repository/shell/az/ad.html#repository.shell.az.ad.Ad.app_credential_reset","title":"app_credential_reset  <code>classmethod</code>","text":"<pre><code>app_credential_reset(\n    *, application_id: str, name: str, end_date: datetime\n) -&gt; SecretStr\n</code></pre> <p>Resets the client secret for a service principal.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If exit code is not zero.</p> Source code in <code>repository/shell/az/ad.py</code> <pre><code>@classmethod\ndef app_credential_reset(\n    cls, *, application_id: str, name: str, end_date: datetime\n) -&gt; SecretStr:\n    \"\"\"\n    Resets the client secret for a service principal.\n\n    raises:\n        Exception: If exit code is not zero.\n    \"\"\"\n    command = SpaceDelimited(\n        line=(\n            \"az\",\n            \"ad\",\n            \"app\",\n            \"credential\",\n            \"reset\",\n            \"--id\",\n            application_id,\n            \"--display-name\",\n            name,\n            \"--end-date\",\n            end_date.strftime(\"%Y-%m-%dT%H:%M:%S+00:00\"),\n        )\n    )\n\n    return SecretStr(secret_value=cls.execute(command=command)[\"password\"])\n</code></pre>"},{"location":"source_code/repository/shell/az/ad.html#repository.shell.az.ad.Ad.sp_list","title":"sp_list  <code>classmethod</code>","text":"<pre><code>sp_list(*, service_principal_name: str) -&gt; dict\n</code></pre> <p>Returns the definition information for a service principal.</p> Source code in <code>repository/shell/az/ad.py</code> <pre><code>@classmethod\ndef sp_list(\n    cls, *, service_principal_name: str\n) -&gt; dict:\n    \"\"\"\n    Returns the definition information for a service principal.\n    \"\"\"\n    command = SpaceDelimited(\n        line=(\n            \"az\",\n            \"ad\",\n            \"sp\",\n            \"list\",\n            \"--display-name\",\n            service_principal_name\n        ),\n    )\n    results = cls.execute(command=command)\n\n    return {\n        \"application_id\": results[0][\"appId\"],\n        \"object_id\": results[0][\"id\"],\n    }\n</code></pre>"},{"location":"source_code/repository/shell/az/az.html","title":"az","text":""},{"location":"source_code/repository/shell/az/az.html#repository.shell.az.az.Az","title":"Az","text":"<p>             Bases: <code>repository.shell.command.Command</code></p> <p>Interactions with Azure using Azure CLI.</p> Source code in <code>repository/shell/az/az.py</code> <pre><code>class Az(Command):\n    \"\"\"\n    Interactions with Azure using Azure CLI.\n    \"\"\"\n\n    @classmethod\n    def execute(\n        cls,\n        *,\n        command: SpaceDelimited,\n        cwd: Optional[str] = None,\n        env: _Environ = environ,\n        start_new_session: bool = False,\n        input: Optional[str] = None,\n    ) -&gt; Any:\n        \"\"\"\n        Executes an Azure CLI command.\n\n        raises:\n            Exception: If exit code is not zero.\n        \"\"\"\n\n        result = super().execute(\n            command=command,\n            cwd=cwd,\n            env=env,\n            start_new_session=start_new_session,\n            input=input,\n        )\n\n        return json.loads(result.stdout)\n</code></pre>"},{"location":"source_code/repository/shell/az/az.html#repository.shell.az.az.Az.execute","title":"execute  <code>classmethod</code>","text":"<pre><code>execute(\n    *,\n    command: SpaceDelimited,\n    cwd: Optional[str] = None,\n    env: _Environ = environ,\n    start_new_session: bool = False,\n    input: Optional[str] = None\n) -&gt; Any\n</code></pre> <p>Executes an Azure CLI command.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If exit code is not zero.</p> Source code in <code>repository/shell/az/az.py</code> <pre><code>@classmethod\ndef execute(\n    cls,\n    *,\n    command: SpaceDelimited,\n    cwd: Optional[str] = None,\n    env: _Environ = environ,\n    start_new_session: bool = False,\n    input: Optional[str] = None,\n) -&gt; Any:\n    \"\"\"\n    Executes an Azure CLI command.\n\n    raises:\n        Exception: If exit code is not zero.\n    \"\"\"\n\n    result = super().execute(\n        command=command,\n        cwd=cwd,\n        env=env,\n        start_new_session=start_new_session,\n        input=input,\n    )\n\n    return json.loads(result.stdout)\n</code></pre>"},{"location":"source_code/repository/shell/az/keyvault.html","title":"keyvault","text":""},{"location":"source_code/repository/shell/az/keyvault.html#repository.shell.az.keyvault.KeyVault","title":"KeyVault","text":"<p>             Bases: <code>repository.shell.az.az.Az</code></p> <p>Interactions with a key vault.</p> Source code in <code>repository/shell/az/keyvault.py</code> <pre><code>class KeyVault(Az):\n    \"\"\"\n    Interactions with a key vault.\n    \"\"\"\n\n    @classmethod\n    def delete_policy_service_principal(\n        cls, *, key_vault_name: str, sevice_principal_name: str\n    ) -&gt; dict:\n        \"\"\"\n        Removes the access policy for a service principal.\n\n        Raises:\n            Exception: If exit code is not zero.\n        \"\"\"\n        command = SpaceDelimited(\n            line=(\n                \"az\",\n                \"keyvault\",\n                \"delete-policy\",\n                \"--name\",\n                key_vault_name,\n                \"--object-id\",\n                sevice_principal_name,\n            )\n        )\n\n        return cls.execute(command=command)\n\n    @classmethod\n    def secret_delete(cls, *, vault_name: str, name: str) -&gt; list[dict]:\n        \"\"\"\n        Delete a secret from a key vault.\n\n        raises:\n            Exception: If exit code is not zero.\n        \"\"\"\n        command = SpaceDelimited(\n            line=(\n                \"az\",\n                \"keyvault\",\n                \"secret\",\n                \"delete\",\n                \"--vault-name\",\n                vault_name,\n                \"--name\",\n                name,\n            )\n        )\n\n        return cls.execute(command=command)\n\n    @classmethod\n    def secret_list(cls, *, key_vault_url: str) -&gt; list[str]:\n        \"\"\"\n        Fetch a list of the secrets defined in a key vault.\n\n        raises:\n            Exception: If exit code is not zero.\n        \"\"\"\n        command = SpaceDelimited(\n            line=(\"az\", \"keyvault\", \"secret\", \"list\", \"--id\", key_vault_url)\n        )\n\n        return [record[\"name\"] for record in cls.execute(command=command)]\n\n    @classmethod\n    def secret_set(\n        cls,\n        *,\n        vault_name: str,\n        secret_name: str,\n        value: SecretStr,\n        description: str,\n        upload: bool = False,\n    ) -&gt; dict:\n        \"\"\"\n        Set a secret in a key vault.\n\n        raises:\n            Exception: If exit code is not zero.\n        \"\"\"\n        if not upload:\n            command = SpaceDelimited(\n                line=(\n                    \"az\",\n                    \"keyvault\",\n                    \"secret\",\n                    \"set\",\n                    \"--description\",\n                    description,\n                    \"--name\",\n                    secret_name,\n                    \"--value\",\n                    value,\n                    \"--vault-name\",\n                    vault_name,\n                )\n            )\n\n            return cls.execute(command=command)\n        else:\n            with NamedTemporaryFile(\"w\") as file_out:\n                file_out.write(value.get_secret_value())\n                file_out.flush()\n                command = SpaceDelimited(\n                    line=(\n                        \"az\",\n                        \"keyvault\",\n                        \"secret\",\n                        \"set\",\n                        \"--description\",\n                        description,\n                        \"--name\",\n                        secret_name,\n                        \"--vault-name\",\n                        vault_name,\n                        \"--file\",\n                        file_out.name,\n                    )\n                )\n\n                return cls.execute(command=command)\n\n    @classmethod\n    def secret_set_content_type(\n        cls,\n        *,\n        vault_name: str,\n        secret_name: str,\n        description: str,\n    ) -&gt; dict:\n        \"\"\"\n        Set the content type description for a secret in a key vault.\n\n        raises:\n            Exception: If exit code is not zero.\n        \"\"\"\n        command = SpaceDelimited(\n            line=(\n                \"az\",\n                \"keyvault\",\n                \"secret\",\n                \"set-attributes\",\n                \"--name\",\n                secret_name,\n                \"--vault-name\",\n                vault_name,\n                \"--content-type\",\n                f\"'{description}'\",\n            )\n        )\n\n        return cls.execute(command=command)\n\n    @classmethod\n    def secret_show(\n        cls,\n        *,\n        vault_name: str,\n        secret_name: str,\n    ) -&gt; str:\n        \"\"\"\n        Retrieves a secret from a key vault.\n\n        raises:\n            Exception: If exit code is not zero.\n        \"\"\"\n        command = SpaceDelimited(\n            line=(\n                \"az\",\n                \"keyvault\",\n                \"secret\",\n                \"show\",\n                \"--name\",\n                secret_name,\n                \"--vault-name\",\n                vault_name,\n            )\n        )\n\n        result = cls.execute(command=command)\n\n        return result[\"value\"]\n\n    @classmethod\n    def set_policy_secret_service_principal(\n        cls, *, key_vault_name: str, sevice_principal_name: str, permissions: list[str]\n    ) -&gt; dict:\n        command = SpaceDelimited(\n            line=(\n                \"az\",\n                \"keyvault\",\n                \"set-policy\",\n                \"--name\",\n                key_vault_name,\n                \"--secret-permissions\",\n                \" \".join(permissions),\n                \"--object-id\",\n                sevice_principal_name,\n            )\n        )\n\n        return cls.execute(command=command)\n\n    @classmethod\n    def show(cls, *, name: str) -&gt; str:\n        \"\"\"\n        Returns the vault uri of a key vault.\n\n        raises:\n            Exception: If exit code is not zero.\n\n        \"\"\"\n        command = SpaceDelimited(\n            line=(\n                \"az\",\n                \"keyvault\",\n                \"show\",\n                \"--name\",\n                name\n            )\n        )\n\n        results = cls.execute(command=command)\n        cls.logger.debug(f'{results[\"properties\"][\"vaultUri\"]}')\n        return results[\"properties\"][\"vaultUri\"]\n</code></pre>"},{"location":"source_code/repository/shell/az/keyvault.html#repository.shell.az.keyvault.KeyVault.delete_policy_service_principal","title":"delete_policy_service_principal  <code>classmethod</code>","text":"<pre><code>delete_policy_service_principal(\n    *, key_vault_name: str, sevice_principal_name: str\n) -&gt; dict\n</code></pre> <p>Removes the access policy for a service principal.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If exit code is not zero.</p> Source code in <code>repository/shell/az/keyvault.py</code> <pre><code>@classmethod\ndef delete_policy_service_principal(\n    cls, *, key_vault_name: str, sevice_principal_name: str\n) -&gt; dict:\n    \"\"\"\n    Removes the access policy for a service principal.\n\n    Raises:\n        Exception: If exit code is not zero.\n    \"\"\"\n    command = SpaceDelimited(\n        line=(\n            \"az\",\n            \"keyvault\",\n            \"delete-policy\",\n            \"--name\",\n            key_vault_name,\n            \"--object-id\",\n            sevice_principal_name,\n        )\n    )\n\n    return cls.execute(command=command)\n</code></pre>"},{"location":"source_code/repository/shell/az/keyvault.html#repository.shell.az.keyvault.KeyVault.secret_delete","title":"secret_delete  <code>classmethod</code>","text":"<pre><code>secret_delete(*, vault_name: str, name: str) -&gt; list[dict]\n</code></pre> <p>Delete a secret from a key vault.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If exit code is not zero.</p> Source code in <code>repository/shell/az/keyvault.py</code> <pre><code>@classmethod\ndef secret_delete(cls, *, vault_name: str, name: str) -&gt; list[dict]:\n    \"\"\"\n    Delete a secret from a key vault.\n\n    raises:\n        Exception: If exit code is not zero.\n    \"\"\"\n    command = SpaceDelimited(\n        line=(\n            \"az\",\n            \"keyvault\",\n            \"secret\",\n            \"delete\",\n            \"--vault-name\",\n            vault_name,\n            \"--name\",\n            name,\n        )\n    )\n\n    return cls.execute(command=command)\n</code></pre>"},{"location":"source_code/repository/shell/az/keyvault.html#repository.shell.az.keyvault.KeyVault.secret_list","title":"secret_list  <code>classmethod</code>","text":"<pre><code>secret_list(*, key_vault_url: str) -&gt; list[str]\n</code></pre> <p>Fetch a list of the secrets defined in a key vault.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If exit code is not zero.</p> Source code in <code>repository/shell/az/keyvault.py</code> <pre><code>@classmethod\ndef secret_list(cls, *, key_vault_url: str) -&gt; list[str]:\n    \"\"\"\n    Fetch a list of the secrets defined in a key vault.\n\n    raises:\n        Exception: If exit code is not zero.\n    \"\"\"\n    command = SpaceDelimited(\n        line=(\"az\", \"keyvault\", \"secret\", \"list\", \"--id\", key_vault_url)\n    )\n\n    return [record[\"name\"] for record in cls.execute(command=command)]\n</code></pre>"},{"location":"source_code/repository/shell/az/keyvault.html#repository.shell.az.keyvault.KeyVault.secret_set","title":"secret_set  <code>classmethod</code>","text":"<pre><code>secret_set(\n    *,\n    vault_name: str,\n    secret_name: str,\n    value: SecretStr,\n    description: str,\n    upload: bool = False\n) -&gt; dict\n</code></pre> <p>Set a secret in a key vault.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If exit code is not zero.</p> Source code in <code>repository/shell/az/keyvault.py</code> <pre><code>@classmethod\ndef secret_set(\n    cls,\n    *,\n    vault_name: str,\n    secret_name: str,\n    value: SecretStr,\n    description: str,\n    upload: bool = False,\n) -&gt; dict:\n    \"\"\"\n    Set a secret in a key vault.\n\n    raises:\n        Exception: If exit code is not zero.\n    \"\"\"\n    if not upload:\n        command = SpaceDelimited(\n            line=(\n                \"az\",\n                \"keyvault\",\n                \"secret\",\n                \"set\",\n                \"--description\",\n                description,\n                \"--name\",\n                secret_name,\n                \"--value\",\n                value,\n                \"--vault-name\",\n                vault_name,\n            )\n        )\n\n        return cls.execute(command=command)\n    else:\n        with NamedTemporaryFile(\"w\") as file_out:\n            file_out.write(value.get_secret_value())\n            file_out.flush()\n            command = SpaceDelimited(\n                line=(\n                    \"az\",\n                    \"keyvault\",\n                    \"secret\",\n                    \"set\",\n                    \"--description\",\n                    description,\n                    \"--name\",\n                    secret_name,\n                    \"--vault-name\",\n                    vault_name,\n                    \"--file\",\n                    file_out.name,\n                )\n            )\n\n            return cls.execute(command=command)\n</code></pre>"},{"location":"source_code/repository/shell/az/keyvault.html#repository.shell.az.keyvault.KeyVault.secret_set_content_type","title":"secret_set_content_type  <code>classmethod</code>","text":"<pre><code>secret_set_content_type(\n    *, vault_name: str, secret_name: str, description: str\n) -&gt; dict\n</code></pre> <p>Set the content type description for a secret in a key vault.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If exit code is not zero.</p> Source code in <code>repository/shell/az/keyvault.py</code> <pre><code>@classmethod\ndef secret_set_content_type(\n    cls,\n    *,\n    vault_name: str,\n    secret_name: str,\n    description: str,\n) -&gt; dict:\n    \"\"\"\n    Set the content type description for a secret in a key vault.\n\n    raises:\n        Exception: If exit code is not zero.\n    \"\"\"\n    command = SpaceDelimited(\n        line=(\n            \"az\",\n            \"keyvault\",\n            \"secret\",\n            \"set-attributes\",\n            \"--name\",\n            secret_name,\n            \"--vault-name\",\n            vault_name,\n            \"--content-type\",\n            f\"'{description}'\",\n        )\n    )\n\n    return cls.execute(command=command)\n</code></pre>"},{"location":"source_code/repository/shell/az/keyvault.html#repository.shell.az.keyvault.KeyVault.secret_show","title":"secret_show  <code>classmethod</code>","text":"<pre><code>secret_show(*, vault_name: str, secret_name: str) -&gt; str\n</code></pre> <p>Retrieves a secret from a key vault.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If exit code is not zero.</p> Source code in <code>repository/shell/az/keyvault.py</code> <pre><code>@classmethod\ndef secret_show(\n    cls,\n    *,\n    vault_name: str,\n    secret_name: str,\n) -&gt; str:\n    \"\"\"\n    Retrieves a secret from a key vault.\n\n    raises:\n        Exception: If exit code is not zero.\n    \"\"\"\n    command = SpaceDelimited(\n        line=(\n            \"az\",\n            \"keyvault\",\n            \"secret\",\n            \"show\",\n            \"--name\",\n            secret_name,\n            \"--vault-name\",\n            vault_name,\n        )\n    )\n\n    result = cls.execute(command=command)\n\n    return result[\"value\"]\n</code></pre>"},{"location":"source_code/repository/shell/az/keyvault.html#repository.shell.az.keyvault.KeyVault.show","title":"show  <code>classmethod</code>","text":"<pre><code>show(*, name: str) -&gt; str\n</code></pre> <p>Returns the vault uri of a key vault.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If exit code is not zero.</p> Source code in <code>repository/shell/az/keyvault.py</code> <pre><code>@classmethod\ndef show(cls, *, name: str) -&gt; str:\n    \"\"\"\n    Returns the vault uri of a key vault.\n\n    raises:\n        Exception: If exit code is not zero.\n\n    \"\"\"\n    command = SpaceDelimited(\n        line=(\n            \"az\",\n            \"keyvault\",\n            \"show\",\n            \"--name\",\n            name\n        )\n    )\n\n    results = cls.execute(command=command)\n    cls.logger.debug(f'{results[\"properties\"][\"vaultUri\"]}')\n    return results[\"properties\"][\"vaultUri\"]\n</code></pre>"},{"location":"source_code/repository/shell/az/storage_account.html","title":"storage_account","text":""},{"location":"source_code/repository/shell/az/storage_account.html#repository.shell.az.storage_account.StorageAccount","title":"StorageAccount","text":"<p>             Bases: <code>repository.shell.az.az.Az</code></p> <p>Interactions with an Azure Storage Account.</p> Source code in <code>repository/shell/az/storage_account.py</code> <pre><code>class StorageAccount(Az):\n    \"\"\"\n    Interactions with an Azure Storage Account.\n    \"\"\"\n\n    @classmethod\n    def list_keys(\n        cls,\n        *,\n        account_name: str,\n    ) -&gt; list[SecretStr]:\n        \"\"\"\n        Retrieve keys from a storage account.\n\n        raises:\n            Exception: If exit code is not zero.\n        \"\"\"\n        command = SpaceDelimited(\n            line=(\n                \"az\",\n                \"storage\",\n                \"account\",\n                \"keys\",\n                \"list\",\n                \"--account-name\",\n                account_name,\n            )\n        )\n\n        return [\n            SecretStr(secret_value=record[\"value\"])\n            for record in cls.execute(command=command)\n        ]\n\n    @classmethod\n    def primary_key(\n        cls,\n        *,\n        account_name: str,\n    ) -&gt; SecretStr:\n        \"\"\"\n        Retrieve primary key from a storage account.\n\n        raises:\n            Exception: If exit code is not zero.\n        \"\"\"\n        keys = cls.list_keys(account_name=account_name)\n\n        return keys[0]\n\n    @classmethod\n    def show(\n        cls,\n        *,\n        account_name: str,\n    ) -&gt; dict:\n        \"\"\"\n        Retrieve definitional information from a storage account.\n\n        raises:\n            Exception: If exit code is not zero.\n        \"\"\"\n        command = SpaceDelimited(\n            line=(\n                \"az\",\n                \"storage\",\n                \"account\",\n                \"show\",\n                \"--name\",\n                account_name,\n            )\n        )\n\n        return cls.execute(command=command)\n\n    @classmethod\n    def share_create(\n        cls, *, account_key: SecretStr, account_name: str, share_name: str\n    ) -&gt; bool:\n        \"\"\"\n        Create a file share.\n\n        raises:\n            Exception: If exit code is not zero.\n        \"\"\"\n        command = SpaceDelimited(\n            line=(\n                \"az\",\n                \"storage\",\n                \"share\",\n                \"create\",\n                \"--account-key\",\n                account_key,\n                \"--account-name\",\n                account_name,\n                \"--name\",\n                share_name,\n            )\n        )\n\n        return cls.execute(command=command)\n\n    @classmethod\n    def share_exists(\n        cls, *, account_key: SecretStr, account_name: str, share_name: str\n    ) -&gt; bool:\n        \"\"\"\n        Check for the existence of a file share.\n\n        raises:\n            Exception: If exit code is not zero.\n        \"\"\"\n        command = SpaceDelimited(\n            line=(\n                \"az\",\n                \"storage\",\n                \"share\",\n                \"exists\",\n                \"--account-key\",\n                account_key,\n                \"--account-name\",\n                account_name,\n                \"--name\",\n                share_name,\n            )\n        )\n\n        results = cls.execute(command=command)\n\n        return results[\"exists\"]\n\n    @classmethod\n    def share_list(cls, *, account_key: SecretStr, account_name: str) -&gt; list[dict]:\n        \"\"\"\n        List the file shares in the storage account.\n\n        raises:\n            Exception: If exit code is not zero.\n        \"\"\"\n        command = SpaceDelimited(\n            line=(\n                \"az\",\n                \"storage\",\n                \"share\",\n                \"list\",\n                \"--account-key\",\n                account_key,\n                \"--account-name\",\n                account_name,\n            )\n        )\n\n        return cls.execute(command=command)\n</code></pre>"},{"location":"source_code/repository/shell/az/storage_account.html#repository.shell.az.storage_account.StorageAccount.list_keys","title":"list_keys  <code>classmethod</code>","text":"<pre><code>list_keys(*, account_name: str) -&gt; list[SecretStr]\n</code></pre> <p>Retrieve keys from a storage account.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If exit code is not zero.</p> Source code in <code>repository/shell/az/storage_account.py</code> <pre><code>@classmethod\ndef list_keys(\n    cls,\n    *,\n    account_name: str,\n) -&gt; list[SecretStr]:\n    \"\"\"\n    Retrieve keys from a storage account.\n\n    raises:\n        Exception: If exit code is not zero.\n    \"\"\"\n    command = SpaceDelimited(\n        line=(\n            \"az\",\n            \"storage\",\n            \"account\",\n            \"keys\",\n            \"list\",\n            \"--account-name\",\n            account_name,\n        )\n    )\n\n    return [\n        SecretStr(secret_value=record[\"value\"])\n        for record in cls.execute(command=command)\n    ]\n</code></pre>"},{"location":"source_code/repository/shell/az/storage_account.html#repository.shell.az.storage_account.StorageAccount.primary_key","title":"primary_key  <code>classmethod</code>","text":"<pre><code>primary_key(*, account_name: str) -&gt; SecretStr\n</code></pre> <p>Retrieve primary key from a storage account.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If exit code is not zero.</p> Source code in <code>repository/shell/az/storage_account.py</code> <pre><code>@classmethod\ndef primary_key(\n    cls,\n    *,\n    account_name: str,\n) -&gt; SecretStr:\n    \"\"\"\n    Retrieve primary key from a storage account.\n\n    raises:\n        Exception: If exit code is not zero.\n    \"\"\"\n    keys = cls.list_keys(account_name=account_name)\n\n    return keys[0]\n</code></pre>"},{"location":"source_code/repository/shell/az/storage_account.html#repository.shell.az.storage_account.StorageAccount.share_create","title":"share_create  <code>classmethod</code>","text":"<pre><code>share_create(\n    *,\n    account_key: SecretStr,\n    account_name: str,\n    share_name: str\n) -&gt; bool\n</code></pre> <p>Create a file share.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If exit code is not zero.</p> Source code in <code>repository/shell/az/storage_account.py</code> <pre><code>@classmethod\ndef share_create(\n    cls, *, account_key: SecretStr, account_name: str, share_name: str\n) -&gt; bool:\n    \"\"\"\n    Create a file share.\n\n    raises:\n        Exception: If exit code is not zero.\n    \"\"\"\n    command = SpaceDelimited(\n        line=(\n            \"az\",\n            \"storage\",\n            \"share\",\n            \"create\",\n            \"--account-key\",\n            account_key,\n            \"--account-name\",\n            account_name,\n            \"--name\",\n            share_name,\n        )\n    )\n\n    return cls.execute(command=command)\n</code></pre>"},{"location":"source_code/repository/shell/az/storage_account.html#repository.shell.az.storage_account.StorageAccount.share_exists","title":"share_exists  <code>classmethod</code>","text":"<pre><code>share_exists(\n    *,\n    account_key: SecretStr,\n    account_name: str,\n    share_name: str\n) -&gt; bool\n</code></pre> <p>Check for the existence of a file share.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If exit code is not zero.</p> Source code in <code>repository/shell/az/storage_account.py</code> <pre><code>@classmethod\ndef share_exists(\n    cls, *, account_key: SecretStr, account_name: str, share_name: str\n) -&gt; bool:\n    \"\"\"\n    Check for the existence of a file share.\n\n    raises:\n        Exception: If exit code is not zero.\n    \"\"\"\n    command = SpaceDelimited(\n        line=(\n            \"az\",\n            \"storage\",\n            \"share\",\n            \"exists\",\n            \"--account-key\",\n            account_key,\n            \"--account-name\",\n            account_name,\n            \"--name\",\n            share_name,\n        )\n    )\n\n    results = cls.execute(command=command)\n\n    return results[\"exists\"]\n</code></pre>"},{"location":"source_code/repository/shell/az/storage_account.html#repository.shell.az.storage_account.StorageAccount.share_list","title":"share_list  <code>classmethod</code>","text":"<pre><code>share_list(\n    *, account_key: SecretStr, account_name: str\n) -&gt; list[dict]\n</code></pre> <p>List the file shares in the storage account.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If exit code is not zero.</p> Source code in <code>repository/shell/az/storage_account.py</code> <pre><code>@classmethod\ndef share_list(cls, *, account_key: SecretStr, account_name: str) -&gt; list[dict]:\n    \"\"\"\n    List the file shares in the storage account.\n\n    raises:\n        Exception: If exit code is not zero.\n    \"\"\"\n    command = SpaceDelimited(\n        line=(\n            \"az\",\n            \"storage\",\n            \"share\",\n            \"list\",\n            \"--account-key\",\n            account_key,\n            \"--account-name\",\n            account_name,\n        )\n    )\n\n    return cls.execute(command=command)\n</code></pre>"},{"location":"source_code/repository/shell/az/storage_account.html#repository.shell.az.storage_account.StorageAccount.show","title":"show  <code>classmethod</code>","text":"<pre><code>show(*, account_name: str) -&gt; dict\n</code></pre> <p>Retrieve definitional information from a storage account.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If exit code is not zero.</p> Source code in <code>repository/shell/az/storage_account.py</code> <pre><code>@classmethod\ndef show(\n    cls,\n    *,\n    account_name: str,\n) -&gt; dict:\n    \"\"\"\n    Retrieve definitional information from a storage account.\n\n    raises:\n        Exception: If exit code is not zero.\n    \"\"\"\n    command = SpaceDelimited(\n        line=(\n            \"az\",\n            \"storage\",\n            \"account\",\n            \"show\",\n            \"--name\",\n            account_name,\n        )\n    )\n\n    return cls.execute(command=command)\n</code></pre>"},{"location":"source_code/repository/shell/delimited/comma_delimited.html","title":"comma_delimited","text":""},{"location":"source_code/repository/shell/delimited/comma_delimited.html#repository.shell.delimited.comma_delimited.CommaDelimited","title":"CommaDelimited","text":"<p>Represents a sequence of strings that are rendered as comma delimited.  When used as a normal string, the secret values will be masked.</p> Source code in <code>repository/shell/delimited/comma_delimited.py</code> <pre><code>class CommaDelimited:\n    \"\"\"\n    Represents a sequence of strings that are rendered as comma delimited.  When used as a normal string,\n    the secret values will be masked.\n    \"\"\"\n\n    def __init__(self, *, line: Sequence[Union[str, SecretStr, EqualDelimited]]):\n        self._line = line\n\n    def get_secret_value(self) -&gt; str:\n        \"\"\"\n        Performs the rendering including the unmasking of secret values.\n        \"\"\"\n        return \",\".join(\n            [\n                (\n                    item.get_secret_value()\n                    if isinstance(item, EqualDelimited) or isinstance(item, SecretStr)\n                    else item\n                )\n                for item in self._line\n            ]\n        )\n\n    def __repr__(self) -&gt; str:\n        return str(self)\n\n    def __str__(self) -&gt; str:\n        return \",\".join([str(item) for item in self._line])\n</code></pre>"},{"location":"source_code/repository/shell/delimited/comma_delimited.html#repository.shell.delimited.comma_delimited.CommaDelimited.get_secret_value","title":"get_secret_value","text":"<pre><code>get_secret_value() -&gt; str\n</code></pre> <p>Performs the rendering including the unmasking of secret values.</p> Source code in <code>repository/shell/delimited/comma_delimited.py</code> <pre><code>def get_secret_value(self) -&gt; str:\n    \"\"\"\n    Performs the rendering including the unmasking of secret values.\n    \"\"\"\n    return \",\".join(\n        [\n            (\n                item.get_secret_value()\n                if isinstance(item, EqualDelimited) or isinstance(item, SecretStr)\n                else item\n            )\n            for item in self._line\n        ]\n    )\n</code></pre>"},{"location":"source_code/repository/shell/delimited/equal_delimited.html","title":"equal_delimited","text":""},{"location":"source_code/repository/shell/delimited/equal_delimited.html#repository.shell.delimited.equal_delimited.EqualDelimited","title":"EqualDelimited","text":"<p>Represents a pair of strings that are delimited using an equals sign.  When used as a normal string, secret values will be masked.</p> Source code in <code>repository/shell/delimited/equal_delimited.py</code> <pre><code>class EqualDelimited:\n    \"\"\"\n    Represents a pair of strings that are delimited using an equals sign.  When used as a normal string,\n    secret values will be masked.\n    \"\"\"\n\n    def __init__(self, *, left: str, right: Union[str, SecretStr]):\n        self._left = left\n        self._right = right\n\n    def get_secret_value(self) -&gt; str:\n        \"\"\"\n        Renders an equals delimited string with secret values unmasked.\n        \"\"\"\n        return \"=\".join(\n            (\n                self._left,\n                (\n                    self._right.get_secret_value()\n                    if isinstance(self._right, SecretStr)\n                    else self._right\n                ),\n            )\n        )\n\n    def __repr__(self) -&gt; str:\n        return str(self)\n\n    def __str__(self):\n        return \"=\".join((self._left, str(self._right)))\n</code></pre>"},{"location":"source_code/repository/shell/delimited/equal_delimited.html#repository.shell.delimited.equal_delimited.EqualDelimited.get_secret_value","title":"get_secret_value","text":"<pre><code>get_secret_value() -&gt; str\n</code></pre> <p>Renders an equals delimited string with secret values unmasked.</p> Source code in <code>repository/shell/delimited/equal_delimited.py</code> <pre><code>def get_secret_value(self) -&gt; str:\n    \"\"\"\n    Renders an equals delimited string with secret values unmasked.\n    \"\"\"\n    return \"=\".join(\n        (\n            self._left,\n            (\n                self._right.get_secret_value()\n                if isinstance(self._right, SecretStr)\n                else self._right\n            ),\n        )\n    )\n</code></pre>"},{"location":"source_code/repository/shell/delimited/space_delimited.html","title":"space_delimited","text":""},{"location":"source_code/repository/shell/delimited/space_delimited.html#repository.shell.delimited.space_delimited.SpaceDelimited","title":"SpaceDelimited","text":"<p>Represents a sequence of space delimited strings.  When used as a normal string, secret vlaues will be masked.</p> Source code in <code>repository/shell/delimited/space_delimited.py</code> <pre><code>class SpaceDelimited:\n    \"\"\"\n    Represents a sequence of space delimited strings.  When used as a normal string, secret vlaues\n    will be masked.\n    \"\"\"\n\n    def __init__(\n        self, *, line: Sequence[Union[str, SecretStr, CommaDelimited, EqualDelimited]]\n    ):\n        self._line = line\n\n    def get_secret_value(self) -&gt; list[str]:\n        \"\"\"\n        Renders space delimited items as a list rather than a single string.  Secret values will be unmasked.\n        \"\"\"\n        return [\n            (\n                item.get_secret_value()\n                if isinstance(item, CommaDelimited)\n                or isinstance(item, EqualDelimited)\n                or isinstance(item, SecretStr)\n                else item\n            )\n            for item in self._line\n        ]\n\n    def __repr__(self) -&gt; str:\n        return str(self)\n\n    def __str__(self) -&gt; str:\n        return \" \".join([str(item) for item in self._line])\n</code></pre>"},{"location":"source_code/repository/shell/delimited/space_delimited.html#repository.shell.delimited.space_delimited.SpaceDelimited.get_secret_value","title":"get_secret_value","text":"<pre><code>get_secret_value() -&gt; list[str]\n</code></pre> <p>Renders space delimited items as a list rather than a single string.  Secret values will be unmasked.</p> Source code in <code>repository/shell/delimited/space_delimited.py</code> <pre><code>def get_secret_value(self) -&gt; list[str]:\n    \"\"\"\n    Renders space delimited items as a list rather than a single string.  Secret values will be unmasked.\n    \"\"\"\n    return [\n        (\n            item.get_secret_value()\n            if isinstance(item, CommaDelimited)\n            or isinstance(item, EqualDelimited)\n            or isinstance(item, SecretStr)\n            else item\n        )\n        for item in self._line\n    ]\n</code></pre>"},{"location":"source_code/secret/generate_key.html","title":"generate_key","text":"<p>Generate an encryption key.  Will error out if trying to overwrite an existing key.</p> <pre><code>python -m secret.generate_key file_name\n</code></pre> positional <ul> <li>file_name: Name of the file to place the key in--must not already exist.</li> </ul>"},{"location":"source_code/secret/generate_key.html#secret.generate_key.generate_key","title":"generate_key","text":"<pre><code>generate_key(file_name: str)\n</code></pre> <p>Generate a Fernet key.</p> Source code in <code>secret/generate_key.py</code> <pre><code>def generate_key(file_name: str):\n    \"\"\"\n    Generate a Fernet key.\n    \"\"\"\n    if os.path.exists(file_name):\n        print(f\"{file_name} already exists\")\n        exit(1)\n    key = Fernet.generate_key()\n    with open(file_name, \"w\") as file_out:\n        file_out.write(key.decode())\n</code></pre>"},{"location":"source_code/secret/set.html","title":"set","text":"<p>Sets a secret value in the master secrets.yaml file.</p> <p>Command line usage:</p> <pre><code>python -m secret.set\n</code></pre> prompts <ul> <li>Category: The group the secret belongs to.</li> <li>Name: The name of the secret.</li> <li>Secret: The value of the secret.</li> </ul>"},{"location":"source_code/secret/set.html#secret.set.set","title":"set","text":"<pre><code>set()\n</code></pre> <p>Sets an encrypted value in the secrets config file.</p> Source code in <code>secret/set.py</code> <pre><code>def set():\n    \"\"\"\n    Sets an encrypted value in the secrets config file.\n    \"\"\"\n    category = input(\"Category: \")\n    name = input(\"Name: \")\n    secret = getpass(\"Secret: \")\n\n    config = Config()\n    config.secrets.set(category, name, secret)\n</code></pre>"},{"location":"source_code/service/archive_encrypted/archive_encrypted_machine.html","title":"archive_encrypted_machine","text":""},{"location":"source_code/service/archive_encrypted/archive_encrypted_machine.html#service.archive_encrypted.archive_encrypted_machine.MachineArchiveEncrypted","title":"MachineArchiveEncrypted","text":"<p>             Bases: <code>state_machine.AbstractMachine</code></p> |+ <p>Archive a file by copying it to a staging folder, encrypting it using GPG, and moving the encrypted file to an archive folder.</p> <p>The steps to perform this are:</p> <ol> <li>Ensure the staging directory exists.</li> <li>Copy the source file to the staging folder.</li> <li>Encrypt the file in the staging folder using GPG.</li> <li>Ensure the archive directory exists.</li> <li>Move the encrypted file from staging to the archive folder.</li> <li>Report the Success/Failure outcomes back to where ever it was called from.</li> </ol> <p>The sequence diagram for the happy-path life cycle is presented below:</p> <pre><code>sequenceDiagram\n  autonumber\n  Caller-&gt;&gt;MachineArchiveEncrypted: start\n  MachineArchiveEncrypted-&gt;&gt;FileManager: ensure_staging_directory\n  FileManager-&gt;&gt;MachineArchiveEncrypted: directory created\n  MachineArchiveEncrypted-&gt;&gt;FileManager: copy_to_staging\n  FileManager-&gt;&gt;MachineArchiveEncrypted: file copied\n  MachineArchiveEncrypted-&gt;&gt;GPG: encrypt_file\n  GPG-&gt;&gt;MachineArchiveEncrypted: file encrypted\n  MachineArchiveEncrypted-&gt;&gt;FileManager: ensure_archive_directory\n  FileManager-&gt;&gt;MachineArchiveEncrypted: directory created\n  MachineArchiveEncrypted-&gt;&gt;FileManager: move_to_archive\n  FileManager-&gt;&gt;MachineArchiveEncrypted: file moved\n  MachineArchiveEncrypted-&gt;&gt;Caller: report_results</code></pre> <p>The state flow diagram showing all nodes and transitions is presented below:</p> <pre><code>stateDiagram-v2\n    [*] --&gt; ensure_staging_directory\n    ensure_staging_directory --&gt; copy_to_staging: success\n    ensure_staging_directory --&gt; report_results: failure\n    copy_to_staging --&gt; encrypt_file: success\n    copy_to_staging --&gt; remove_copied_file: failure\n    encrypt_file --&gt; ensure_archive_directory: success\n    encrypt_file --&gt; remove_copied_file: failure\n    ensure_archive_directory --&gt; move_to_archive: success\n    ensure_archive_directory --&gt; remove_encrypted_file: failure\n    move_to_archive --&gt; report_results: success\n    move_to_archive --&gt; remove_encrypted_file: failure\n    remove_copied_file --&gt; report_results: cleanup complete\n    remove_encrypted_file --&gt; remove_copied_file: cleanup complete\n    report_results --&gt; [*]\n\n    note right of ensure_staging_directory\n        Entry node\n    end note\n\n    note right of report_results\n        Terminal node\n    end note\n\n    note right of remove_copied_file\n        Rollback node\n    end note\n\n    note right of remove_encrypted_file\n        Rollback node\n    end note</code></pre> Source code in <code>service/archive_encrypted/archive_encrypted_machine.py</code> <pre><code>@machine\nclass MachineArchiveEncrypted(AbstractMachine):\n    \"\"\"\n    overview: |+\n        Archive a file by copying it to a staging folder, encrypting it using GPG,\n        and moving the encrypted file to an archive folder.\n\n        The steps to perform this are:\n\n        1. Ensure the staging directory exists.\n        2. Copy the source file to the staging folder.\n        3. Encrypt the file in the staging folder using GPG.\n        4. Ensure the archive directory exists.\n        5. Move the encrypted file from staging to the archive folder.\n        6. Report the Success/Failure outcomes back to where ever it was called from.\n\n        The sequence diagram for the happy-path life cycle is presented below:\n\n        ``` mermaid\n        sequenceDiagram\n          autonumber\n          Caller-&gt;&gt;MachineArchiveEncrypted: start\n          MachineArchiveEncrypted-&gt;&gt;FileManager: ensure_staging_directory\n          FileManager-&gt;&gt;MachineArchiveEncrypted: directory created\n          MachineArchiveEncrypted-&gt;&gt;FileManager: copy_to_staging\n          FileManager-&gt;&gt;MachineArchiveEncrypted: file copied\n          MachineArchiveEncrypted-&gt;&gt;GPG: encrypt_file\n          GPG-&gt;&gt;MachineArchiveEncrypted: file encrypted\n          MachineArchiveEncrypted-&gt;&gt;FileManager: ensure_archive_directory\n          FileManager-&gt;&gt;MachineArchiveEncrypted: directory created\n          MachineArchiveEncrypted-&gt;&gt;FileManager: move_to_archive\n          FileManager-&gt;&gt;MachineArchiveEncrypted: file moved\n          MachineArchiveEncrypted-&gt;&gt;Caller: report_results\n        ```\n\n        The state flow diagram showing all nodes and transitions is presented below:\n\n        ``` mermaid\n        stateDiagram-v2\n            [*] --&gt; ensure_staging_directory\n            ensure_staging_directory --&gt; copy_to_staging: success\n            ensure_staging_directory --&gt; report_results: failure\n            copy_to_staging --&gt; encrypt_file: success\n            copy_to_staging --&gt; remove_copied_file: failure\n            encrypt_file --&gt; ensure_archive_directory: success\n            encrypt_file --&gt; remove_copied_file: failure\n            ensure_archive_directory --&gt; move_to_archive: success\n            ensure_archive_directory --&gt; remove_encrypted_file: failure\n            move_to_archive --&gt; report_results: success\n            move_to_archive --&gt; remove_encrypted_file: failure\n            remove_copied_file --&gt; report_results: cleanup complete\n            remove_encrypted_file --&gt; remove_copied_file: cleanup complete\n            report_results --&gt; [*]\n\n            note right of ensure_staging_directory\n                Entry node\n            end note\n\n            note right of report_results\n                Terminal node\n            end note\n\n            note right of remove_copied_file\n                Rollback node\n            end note\n\n            note right of remove_encrypted_file\n                Rollback node\n            end note\n        ```\n    \"\"\"\n\n    @handle_exceptions(on_exception=\"report_results\")\n    @node\n    def ensure_staging_directory(self) -&gt; Transition:\n        \"\"\"\n        overview:\n            Ensure the staging directory exists.\n\n        is_entry: True\n\n        happy_paths:\n            - copy_to_staging\n\n        unhappy_paths:\n            - report_results\n        \"\"\"\n        DependencyArchiveEncrypted(logger=self.logger).ensure_staging_directory(\n            path=self.state.staging_folder\n        )\n\n        return self.success(exit_to=self.copy_to_staging)\n\n    @handle_exceptions(on_exception=\"remove_copied_file\")\n    @node\n    def copy_to_staging(self) -&gt; Transition:\n        \"\"\"\n        overview:\n            Copy the source file to the staging folder.\n\n        happy_paths:\n            - encrypt_file\n\n        unhappy_paths:\n            - remove_copied_file\n        \"\"\"\n        source_filename = os.path.basename(self.state.source_path)\n        staging_file_path = os.path.join(self.state.staging_folder, source_filename)\n\n        DependencyArchiveEncrypted(logger=self.logger).copy_to_staging(\n            from_path=self.state.source_path, to_path=staging_file_path\n        )\n\n        return self.success(exit_to=self.encrypt_file)\n\n    @handle_exceptions(on_exception=\"remove_copied_file\")\n    @node\n    def encrypt_file(self) -&gt; Transition:\n        \"\"\"\n        overview:\n            Encrypt the file in the staging folder using GPG.\n\n        happy_paths:\n            - ensure_archive_directory\n\n        unhappy_paths:\n            - remove_copied_file\n        \"\"\"\n        source_filename = os.path.basename(self.state.source_path)\n        staging_file_path = os.path.join(self.state.staging_folder, source_filename)\n        encrypted_file_path = os.path.join(\n            self.state.staging_folder, f\"{source_filename}.gpg\"\n        )\n\n        DependencyArchiveEncrypted(logger=self.logger).encrypt_file(\n            key_name=self.state.gpg_key_name,\n            from_file=staging_file_path,\n            to_file=encrypted_file_path,\n        )\n\n        return self.success(exit_to=self.ensure_archive_directory)\n\n    @handle_exceptions(on_exception=\"remove_encrypted_file\")\n    @node\n    def ensure_archive_directory(self) -&gt; Transition:\n        \"\"\"\n        overview:\n            Ensure the archive directory exists.\n\n        happy_paths:\n            - move_to_archive\n\n        unhappy_paths:\n            - remove_encrypted_file\n        \"\"\"\n        DependencyArchiveEncrypted(logger=self.logger).ensure_archive_directory(\n            path=self.state.archive_folder\n        )\n\n        return self.success(exit_to=self.move_to_archive)\n\n    @handle_exceptions(on_exception=\"remove_encrypted_file\")\n    @node\n    def move_to_archive(self) -&gt; Transition:\n        \"\"\"\n        overview:\n            Move the encrypted file from staging to the archive folder.\n\n        happy_paths:\n            - report_results\n\n        unhappy_paths:\n            - remove_encrypted_file\n        \"\"\"\n        source_filename = os.path.basename(self.state.source_path)\n        encrypted_file_name = f\"{source_filename}.gpg\"\n        staging_encrypted_path = os.path.join(\n            self.state.staging_folder, encrypted_file_name\n        )\n        archive_encrypted_path = os.path.join(\n            self.state.archive_folder, encrypted_file_name\n        )\n\n        DependencyArchiveEncrypted(logger=self.logger).move_to_archive(\n            from_path=staging_encrypted_path, to_path=archive_encrypted_path\n        )\n\n        return self.success(exit_to=self.report_results)\n\n    @handle_exceptions(on_exception=\"report_results\")\n    @node\n    def remove_copied_file(self) -&gt; Transition:\n        \"\"\"\n        overview:\n            Remove the copied file from staging (on error path after copy or encrypt failure).\n\n        happy_paths:\n            - report_results\n\n        unhappy_paths:\n            - report_results\n        \"\"\"\n        source_filename = os.path.basename(self.state.source_path)\n        staging_file_path = os.path.join(self.state.staging_folder, source_filename)\n\n        DependencyArchiveEncrypted(logger=self.logger).remove_copied_file(\n            path=staging_file_path\n        )\n\n        return self.success(exit_to=self.report_results)\n\n    @handle_exceptions(on_exception=\"remove_copied_file\")\n    @node\n    def remove_encrypted_file(self) -&gt; Transition:\n        \"\"\"\n        overview:\n            Remove the encrypted file from staging (on error path after encryption, archive directory, or move failure).\n\n        happy_paths:\n            - remove_copied_file\n\n        unhappy_paths:\n            - remove_copied_file\n        \"\"\"\n        source_filename = os.path.basename(self.state.source_path)\n        encrypted_file_path = os.path.join(\n            self.state.staging_folder, f\"{source_filename}.gpg\"\n        )\n        # Also check if file was partially moved to archive and remove it from there\n        archive_encrypted_path = os.path.join(\n            self.state.archive_folder, f\"{source_filename}.gpg\"\n        )\n\n        DependencyArchiveEncrypted(logger=self.logger).remove_encrypted_file(\n            path=encrypted_file_path\n        )\n        DependencyArchiveEncrypted(logger=self.logger).remove_from_archive(\n            path=archive_encrypted_path\n        )\n\n        return self.success(exit_to=self.remove_copied_file)\n\n    @property\n    def failure_prefix(self) -&gt; str:\n        return \"MachineArchiveEncrypted\"\n\n    @property\n    def state(self) -&gt; StateArchiveEncrypted:\n        return self._state  # pyright: ignore\n</code></pre>"},{"location":"source_code/service/archive_encrypted/archive_encrypted_machine.html#service.archive_encrypted.archive_encrypted_machine.MachineArchiveEncrypted.copy_to_staging","title":"copy_to_staging","text":"<pre><code>copy_to_staging() -&gt; Transition\n</code></pre> overview <p>Copy the source file to the staging folder.</p> happy_paths <ul> <li>encrypt_file</li> </ul> unhappy_paths <ul> <li>remove_copied_file</li> </ul> Source code in <code>service/archive_encrypted/archive_encrypted_machine.py</code> <pre><code>@handle_exceptions(on_exception=\"remove_copied_file\")\n@node\ndef copy_to_staging(self) -&gt; Transition:\n    \"\"\"\n    overview:\n        Copy the source file to the staging folder.\n\n    happy_paths:\n        - encrypt_file\n\n    unhappy_paths:\n        - remove_copied_file\n    \"\"\"\n    source_filename = os.path.basename(self.state.source_path)\n    staging_file_path = os.path.join(self.state.staging_folder, source_filename)\n\n    DependencyArchiveEncrypted(logger=self.logger).copy_to_staging(\n        from_path=self.state.source_path, to_path=staging_file_path\n    )\n\n    return self.success(exit_to=self.encrypt_file)\n</code></pre>"},{"location":"source_code/service/archive_encrypted/archive_encrypted_machine.html#service.archive_encrypted.archive_encrypted_machine.MachineArchiveEncrypted.encrypt_file","title":"encrypt_file","text":"<pre><code>encrypt_file() -&gt; Transition\n</code></pre> overview <p>Encrypt the file in the staging folder using GPG.</p> happy_paths <ul> <li>ensure_archive_directory</li> </ul> unhappy_paths <ul> <li>remove_copied_file</li> </ul> Source code in <code>service/archive_encrypted/archive_encrypted_machine.py</code> <pre><code>@handle_exceptions(on_exception=\"remove_copied_file\")\n@node\ndef encrypt_file(self) -&gt; Transition:\n    \"\"\"\n    overview:\n        Encrypt the file in the staging folder using GPG.\n\n    happy_paths:\n        - ensure_archive_directory\n\n    unhappy_paths:\n        - remove_copied_file\n    \"\"\"\n    source_filename = os.path.basename(self.state.source_path)\n    staging_file_path = os.path.join(self.state.staging_folder, source_filename)\n    encrypted_file_path = os.path.join(\n        self.state.staging_folder, f\"{source_filename}.gpg\"\n    )\n\n    DependencyArchiveEncrypted(logger=self.logger).encrypt_file(\n        key_name=self.state.gpg_key_name,\n        from_file=staging_file_path,\n        to_file=encrypted_file_path,\n    )\n\n    return self.success(exit_to=self.ensure_archive_directory)\n</code></pre>"},{"location":"source_code/service/archive_encrypted/archive_encrypted_machine.html#service.archive_encrypted.archive_encrypted_machine.MachineArchiveEncrypted.ensure_archive_directory","title":"ensure_archive_directory","text":"<pre><code>ensure_archive_directory() -&gt; Transition\n</code></pre> overview <p>Ensure the archive directory exists.</p> happy_paths <ul> <li>move_to_archive</li> </ul> unhappy_paths <ul> <li>remove_encrypted_file</li> </ul> Source code in <code>service/archive_encrypted/archive_encrypted_machine.py</code> <pre><code>@handle_exceptions(on_exception=\"remove_encrypted_file\")\n@node\ndef ensure_archive_directory(self) -&gt; Transition:\n    \"\"\"\n    overview:\n        Ensure the archive directory exists.\n\n    happy_paths:\n        - move_to_archive\n\n    unhappy_paths:\n        - remove_encrypted_file\n    \"\"\"\n    DependencyArchiveEncrypted(logger=self.logger).ensure_archive_directory(\n        path=self.state.archive_folder\n    )\n\n    return self.success(exit_to=self.move_to_archive)\n</code></pre>"},{"location":"source_code/service/archive_encrypted/archive_encrypted_machine.html#service.archive_encrypted.archive_encrypted_machine.MachineArchiveEncrypted.ensure_staging_directory","title":"ensure_staging_directory","text":"<pre><code>ensure_staging_directory() -&gt; Transition\n</code></pre> overview <p>Ensure the staging directory exists.</p> <p>is_entry: True</p> happy_paths <ul> <li>copy_to_staging</li> </ul> unhappy_paths <ul> <li>report_results</li> </ul> Source code in <code>service/archive_encrypted/archive_encrypted_machine.py</code> <pre><code>@handle_exceptions(on_exception=\"report_results\")\n@node\ndef ensure_staging_directory(self) -&gt; Transition:\n    \"\"\"\n    overview:\n        Ensure the staging directory exists.\n\n    is_entry: True\n\n    happy_paths:\n        - copy_to_staging\n\n    unhappy_paths:\n        - report_results\n    \"\"\"\n    DependencyArchiveEncrypted(logger=self.logger).ensure_staging_directory(\n        path=self.state.staging_folder\n    )\n\n    return self.success(exit_to=self.copy_to_staging)\n</code></pre>"},{"location":"source_code/service/archive_encrypted/archive_encrypted_machine.html#service.archive_encrypted.archive_encrypted_machine.MachineArchiveEncrypted.move_to_archive","title":"move_to_archive","text":"<pre><code>move_to_archive() -&gt; Transition\n</code></pre> overview <p>Move the encrypted file from staging to the archive folder.</p> happy_paths <ul> <li>report_results</li> </ul> unhappy_paths <ul> <li>remove_encrypted_file</li> </ul> Source code in <code>service/archive_encrypted/archive_encrypted_machine.py</code> <pre><code>@handle_exceptions(on_exception=\"remove_encrypted_file\")\n@node\ndef move_to_archive(self) -&gt; Transition:\n    \"\"\"\n    overview:\n        Move the encrypted file from staging to the archive folder.\n\n    happy_paths:\n        - report_results\n\n    unhappy_paths:\n        - remove_encrypted_file\n    \"\"\"\n    source_filename = os.path.basename(self.state.source_path)\n    encrypted_file_name = f\"{source_filename}.gpg\"\n    staging_encrypted_path = os.path.join(\n        self.state.staging_folder, encrypted_file_name\n    )\n    archive_encrypted_path = os.path.join(\n        self.state.archive_folder, encrypted_file_name\n    )\n\n    DependencyArchiveEncrypted(logger=self.logger).move_to_archive(\n        from_path=staging_encrypted_path, to_path=archive_encrypted_path\n    )\n\n    return self.success(exit_to=self.report_results)\n</code></pre>"},{"location":"source_code/service/archive_encrypted/archive_encrypted_machine.html#service.archive_encrypted.archive_encrypted_machine.MachineArchiveEncrypted.remove_copied_file","title":"remove_copied_file","text":"<pre><code>remove_copied_file() -&gt; Transition\n</code></pre> overview <p>Remove the copied file from staging (on error path after copy or encrypt failure).</p> happy_paths <ul> <li>report_results</li> </ul> unhappy_paths <ul> <li>report_results</li> </ul> Source code in <code>service/archive_encrypted/archive_encrypted_machine.py</code> <pre><code>@handle_exceptions(on_exception=\"report_results\")\n@node\ndef remove_copied_file(self) -&gt; Transition:\n    \"\"\"\n    overview:\n        Remove the copied file from staging (on error path after copy or encrypt failure).\n\n    happy_paths:\n        - report_results\n\n    unhappy_paths:\n        - report_results\n    \"\"\"\n    source_filename = os.path.basename(self.state.source_path)\n    staging_file_path = os.path.join(self.state.staging_folder, source_filename)\n\n    DependencyArchiveEncrypted(logger=self.logger).remove_copied_file(\n        path=staging_file_path\n    )\n\n    return self.success(exit_to=self.report_results)\n</code></pre>"},{"location":"source_code/service/archive_encrypted/archive_encrypted_machine.html#service.archive_encrypted.archive_encrypted_machine.MachineArchiveEncrypted.remove_encrypted_file","title":"remove_encrypted_file","text":"<pre><code>remove_encrypted_file() -&gt; Transition\n</code></pre> overview <p>Remove the encrypted file from staging (on error path after encryption, archive directory, or move failure).</p> happy_paths <ul> <li>remove_copied_file</li> </ul> unhappy_paths <ul> <li>remove_copied_file</li> </ul> Source code in <code>service/archive_encrypted/archive_encrypted_machine.py</code> <pre><code>@handle_exceptions(on_exception=\"remove_copied_file\")\n@node\ndef remove_encrypted_file(self) -&gt; Transition:\n    \"\"\"\n    overview:\n        Remove the encrypted file from staging (on error path after encryption, archive directory, or move failure).\n\n    happy_paths:\n        - remove_copied_file\n\n    unhappy_paths:\n        - remove_copied_file\n    \"\"\"\n    source_filename = os.path.basename(self.state.source_path)\n    encrypted_file_path = os.path.join(\n        self.state.staging_folder, f\"{source_filename}.gpg\"\n    )\n    # Also check if file was partially moved to archive and remove it from there\n    archive_encrypted_path = os.path.join(\n        self.state.archive_folder, f\"{source_filename}.gpg\"\n    )\n\n    DependencyArchiveEncrypted(logger=self.logger).remove_encrypted_file(\n        path=encrypted_file_path\n    )\n    DependencyArchiveEncrypted(logger=self.logger).remove_from_archive(\n        path=archive_encrypted_path\n    )\n\n    return self.success(exit_to=self.remove_copied_file)\n</code></pre>"},{"location":"source_code/state_machine/abstract_machine.html","title":"abstract_machine","text":""},{"location":"source_code/state_machine/abstract_machine.html#state_machine.abstract_machine.AbstractMachine","title":"AbstractMachine","text":"<p>Abstract base class for a state-machine.  Expects to have the failure_message and state properties overridden in derived classes.</p> Source code in <code>state_machine/abstract_machine.py</code> <pre><code>class AbstractMachine:\n    \"\"\"\n    Abstract base class for a state-machine.  Expects to have the failure_message and state properties\n    overridden in derived classes.\n    \"\"\"\n\n    __entry_nodes__: list[Callable[..., Transition]] = []\n    __entry_node__: Callable[..., Transition]\n    __named_entry_nodes__: list[str] = []\n    __nodes__: list[Callable[..., Transition]] = []\n    __named_nodes__: list[str] = []\n    __terminal_nodes__: list[Callable[..., Transition]] = []\n    __named_terminal_nodes__: list[str] = []\n    __overview__: str = \"\"\n    __todo__: str = \"\"\n    __Success__: type[Result] = Success\n    __Failure__: type[Result] = Failure\n\n    @classmethod\n    def validate(cls):\n        \"\"\"\n        Performs validation that the design documentation outlined in the docstrings for the\n        nodes are self-consistent.\n\n        Validations:\n            - Has an entry-node.\n            - Terminal-nodes don't have an exit path.\n            - All node methods are reachable.\n            - All paths have an implementing node method.\n            - Exception handlers route to a failure path.\n            - Exception handling is specified for all nodes.\n\n        raises:\n            NoEntryNode: If the machine has no entry nodes defined.\n            NoTerminalNode: If the machine has no terminal nodes defined.\n            UndefinedNode: If the design spec references a node that has no implementation.\n            UnreachableNode: If a node is implemented that is not in the design spec.\n            NotTerminalNode: If a terminal node has exit paths in the design spec.\n            NoExceptionHandling: If a node does not have a decorator specifying whether it should have exception handling.\n            IllegalTransition: If an exception path is not an unhappy path for the node.\n        \"\"\"\n        # confirm at least one entry node is defined\n        if not cls.__entry_nodes__:\n            raise NoEntryNodeError(f\"No entry nodes {cls.__module__}\")\n\n        # Confirm there is only one entry node.\n        if len(cls.__entry_nodes__) &gt; 1:\n            raise MultipleEntryNodeError(\n                f\"More than one entry node defined: {cls.__named_entry_nodes__}\"\n            )\n\n        cls.__entry_node__ = cls.__entry_nodes__[0]\n\n        # confirm at least one terminal node is defined\n        if not cls.__terminal_nodes__:\n            raise NoTerminalNodeError(f\"No terminal nodes {cls.__module__}\")\n\n        # collect the definitions of all of the nodes\n        all_nodes = cls.__entry_nodes__ + cls.__nodes__ + cls.__terminal_nodes__\n\n        # compile a list of all of the exit paths\n        exits = []\n        for node in all_nodes:\n            for method_name in node.__exits__:\n                if not hasattr(cls, method_name):\n                    raise UndefinedNodeError(\n                        f\"{cls.__module__}.{node.__node_name__} references undefined: {method_name}\"\n                    )\n                else:\n                    method = getattr(cls, method_name)\n                    exits.append(method.__node_name__)\n\n        # check exception handling specifications\n        for node in all_nodes:\n            if not hasattr(node, \"__has_exception_handling__\"):\n                raise NoExceptionHandlingError(\n                    f\"Node {cls.__module__}.{node.__node_name__} has neither @handle_exceptions nor @no_exceptions\"\n                )\n            elif (\n                node.__has_exception_handling__\n                and node.__on_exception__ not in node.__unhappy_paths__\n            ):\n                raise IllegalTransitionError(\n                    f\"{cls.__module__}.{node.__node_name__} exception handler not an allowable exit: {node.__on_exception__}\"\n                )\n\n        for node in all_nodes:\n            # confirm all of the nodes in the machine have a path that reaches them\n            if not node.__is_entry__ and node.__node_name__ not in exits:\n                raise UnreachableNodeError(\n                    f\"Unreachable node: {cls.__module__}.{node.__node_name__}\"\n                )\n\n            # confirm the terminal nodes have no exit paths\n            if node.__is_terminal__ and node.__exits__:\n                raise NotTerminalNodeError(\n                    f\"Node {cls.__module__}.{node.__node_name__} not terminal\"\n                )\n\n    def __init__(self, *, logger: Logger, state: BaseState):\n        self.logger = logger\n        self._state = state\n\n        self.results = []\n\n    def execute(\n        self,\n    ) -&gt; list[Result]:\n        \"\"\"\n        Executes the state-machine.  When the environment is set to \"dev\" in the master config file,\n        runtime validation that the behavior of the implementation matches the design specification\n        in the docstrings will be performed.\n\n        raises:\n            NoEntryNode: If the starting node is not an entry-node.\n            IllegalTransition: If a transition is made to a node that is not an exit-path of the current node.\n            IllegalTransition: If a Success result is sent down an unhappy-path.\n            IllegalTransition: If a Failure result is sent down a happy-path.\n            IllegalTransition: If no transition is provided and the node is not a terminal-node.\n        \"\"\"\n        machine_start_time = datetime.now(UTC)\n        self.logger.info(f\"{self.__class__.__name__.split('.')[-1]} started\")\n\n        # Set the first node to be executed.\n        self._current_node = self.__entry_node__\n\n        # Run until a terminal node is executed.\n        while True:\n            # Record the last node executed.\n            previous_node = self._current_node\n\n            # Execute the current node.\n            node_start_time = datetime.now(UTC)\n            self.logger.debug(\n                f\"{self.__class__.__name__.split('.')[-1]}.{self._current_node.__node_name__} started\"\n            )\n            transition = self._current_node()\n            self.logger.debug(\n                f\"{self.__class__.__name__.split('.')[-1]}.{self._current_node.__node_name__} completed runtime: {datetime.now(UTC) - node_start_time}\"\n            )\n\n            # Confirm the node returned a Transition.\n            if __debug__ and not isinstance(transition, Transition):\n                raise IllegalTransitionError(\n                    f\"{self._current_node} did not return a Transition: instead returned {type(transition)}\"\n                )\n\n            # Exit machine if the node is terminal.\n            if isinstance(transition, Exit):\n                if self._current_node.__exits__:\n                    raise NotTerminalNodeError(\n                        f\"{self.node_name} returned Exit but is not a terminal node.\"\n                    )\n                else:\n                    self.results.append(transition.result)\n                    break\n\n            self._current_node = transition.exit_to\n\n            # Can the transition be made?\n            if (\n                __debug__\n                and previous_node\n                and self._current_node.__node_name__ not in previous_node.__exits__\n            ):\n                raise IllegalTransitionError(\n                    f\"{previous_node.__node_name__} cannot transition to {self._current_node.__node_name__}\"\n                )\n\n            # Is a Failure being sent down a happy path?\n            if (\n                __debug__\n                and isinstance(transition.result, Failure)\n                and previous_node\n                and self._current_node.__node_name__\n                not in previous_node.__unhappy_paths__\n            ):\n                raise IllegalTransitionError(\n                    f\"{previous_node.__node_name__} made an unhappy transition on the happy path to {self._current_node.__node_name__}\"\n                )\n\n            # Is a Success being sent down an unhappy path?\n            if (\n                __debug__\n                and isinstance(transition.result, Success)\n                and previous_node\n                and self._current_node.__node_name__\n                not in previous_node.__happy_paths__\n            ):\n                raise IllegalTransitionError(\n                    f\"{previous_node.__node_name__} made an happy transition on the unhappy path to {self._current_node.__node_name__}\"\n                )\n\n            self.results.append(transition.result)\n\n        machine_end_time = datetime.now(UTC)\n        machine_run_time = machine_end_time - machine_start_time\n        self.logger.info(\n            f\"{self.__class__.__name__.split('.')[-1]} completed runtime: {machine_run_time}\"\n        )\n\n        return self.results\n\n    def exception(\n        self,\n        *,\n        exit_to: Callable[..., Transition],\n        exception: Exception,\n    ) -&gt; Transition:\n        \"\"\"\n        Returns a failure Transition to *exit_to*.\n\n        raises:\n            IllegalTransition: If *exit_to* is not a node.\n        \"\"\"\n        if (\n            __debug__\n            and not inspect.ismethod(exit_to)\n            and not hasattr(exit_to, \"__is_node__\")\n        ):\n            raise IllegalTransitionError(f\"{exit_to} is not a node\")\n\n        self.logger.error(f\"{self.node_name} {self.failure_prefix}  {exception}\")\n        self.logger.error(f\"{self.node_name} {self.failure_prefix}  {format_exc()}\")\n\n        return Transition(\n            result=Failure(\n                node=self.node_name,\n                message=f\"{self.failure_prefix} unrecognized exception: {exception}\",\n            ),\n            exit_to=exit_to,\n        )\n\n    def exit(self) -&gt; Transition:\n        \"\"\"\n        Exits the state-machine.\n        \"\"\"\n\n        return Exit(result=self.__Success__(node=self.node_name))\n\n    def failure(\n        self,\n        *,\n        exit_to: Callable[..., Transition],\n        message: str,\n    ) -&gt; Transition:\n        \"\"\"\n        Returns a failure Transition to *exit_to*.\n\n        raises:\n            IllegalTransition: If *exit_to* is not a bound method.\n        \"\"\"\n        if (\n            __debug__\n            and not inspect.ismethod(exit_to)\n            and not hasattr(exit_to, \"__is_node__\")\n        ):\n            raise IllegalTransitionError(f\"failure transition {exit_to} is not a node\")\n\n        self.logger.error(f\"{self.node_name} {self.failure_prefix}  {message}\")\n\n        return Transition(\n            result=Failure(\n                node=self.node_name,\n                message=f\"{self.failure_prefix} {message}\",\n            ),\n            exit_to=exit_to,\n        )\n\n    @no_exceptions\n    @node\n    def report_results(self) -&gt; Transition:\n        \"\"\"\n        overview:\n            The final exit node for all state-machines.\n\n        is_terminal: True\n        \"\"\"\n        return self.exit()\n\n    def success(self, *, exit_to: Callable[..., Transition]) -&gt; Transition:\n        \"\"\"\n        Returns a successful Transition to *exit_to*.\n\n        raises:\n            - IllegalTransition: If *exit_to* is not a bound method.\n        \"\"\"\n        if (\n            __debug__\n            and not inspect.ismethod(exit_to)\n            and not hasattr(exit_to, \"__is_node__\")\n        ):\n            raise IllegalTransitionError(f\"success transition {exit_to} is not a node\")\n\n        return Transition(result=self.__Success__(node=self.node_name), exit_to=exit_to)\n\n    @property\n    def failure_prefix(self) -&gt; str:\n        \"\"\"A message to be prepended to the failure reporting messages.\"\"\"\n        raise NotImplementedError()\n\n    @property\n    def node_name(self) -&gt; str:\n        \"\"\"The name of the method implementing the node.\"\"\"\n        return f\"{self.__class__.__name__.split('.')[-1]}.{self._current_node.__node_name__}\"\n\n    @property\n    def state(self) -&gt; BaseState:\n        \"\"\"The machine's state object.\"\"\"\n        raise NotImplementedError()\n</code></pre>"},{"location":"source_code/state_machine/abstract_machine.html#state_machine.abstract_machine.AbstractMachine.failure_prefix","title":"failure_prefix  <code>property</code>","text":"<pre><code>failure_prefix: str\n</code></pre> <p>A message to be prepended to the failure reporting messages.</p>"},{"location":"source_code/state_machine/abstract_machine.html#state_machine.abstract_machine.AbstractMachine.node_name","title":"node_name  <code>property</code>","text":"<pre><code>node_name: str\n</code></pre> <p>The name of the method implementing the node.</p>"},{"location":"source_code/state_machine/abstract_machine.html#state_machine.abstract_machine.AbstractMachine.state","title":"state  <code>property</code>","text":"<pre><code>state: state_machine.base_state.BaseState\n</code></pre> <p>The machine's state object.</p>"},{"location":"source_code/state_machine/abstract_machine.html#state_machine.abstract_machine.AbstractMachine.exception","title":"exception","text":"<pre><code>exception(\n    *,\n    exit_to: Callable[..., Transition],\n    exception: Exception\n) -&gt; Transition\n</code></pre> <p>Returns a failure Transition to exit_to.</p> <p>Raises:</p> Type Description <code>IllegalTransition</code> <p>If exit_to is not a node.</p> Source code in <code>state_machine/abstract_machine.py</code> <pre><code>def exception(\n    self,\n    *,\n    exit_to: Callable[..., Transition],\n    exception: Exception,\n) -&gt; Transition:\n    \"\"\"\n    Returns a failure Transition to *exit_to*.\n\n    raises:\n        IllegalTransition: If *exit_to* is not a node.\n    \"\"\"\n    if (\n        __debug__\n        and not inspect.ismethod(exit_to)\n        and not hasattr(exit_to, \"__is_node__\")\n    ):\n        raise IllegalTransitionError(f\"{exit_to} is not a node\")\n\n    self.logger.error(f\"{self.node_name} {self.failure_prefix}  {exception}\")\n    self.logger.error(f\"{self.node_name} {self.failure_prefix}  {format_exc()}\")\n\n    return Transition(\n        result=Failure(\n            node=self.node_name,\n            message=f\"{self.failure_prefix} unrecognized exception: {exception}\",\n        ),\n        exit_to=exit_to,\n    )\n</code></pre>"},{"location":"source_code/state_machine/abstract_machine.html#state_machine.abstract_machine.AbstractMachine.execute","title":"execute","text":"<pre><code>execute() -&gt; list[Result]\n</code></pre> <p>Executes the state-machine.  When the environment is set to \"dev\" in the master config file, runtime validation that the behavior of the implementation matches the design specification in the docstrings will be performed.</p> <p>Raises:</p> Type Description <code>NoEntryNode</code> <p>If the starting node is not an entry-node.</p> <code>IllegalTransition</code> <p>If a transition is made to a node that is not an exit-path of the current node.</p> <code>IllegalTransition</code> <p>If a Success result is sent down an unhappy-path.</p> <code>IllegalTransition</code> <p>If a Failure result is sent down a happy-path.</p> <code>IllegalTransition</code> <p>If no transition is provided and the node is not a terminal-node.</p> Source code in <code>state_machine/abstract_machine.py</code> <pre><code>def execute(\n    self,\n) -&gt; list[Result]:\n    \"\"\"\n    Executes the state-machine.  When the environment is set to \"dev\" in the master config file,\n    runtime validation that the behavior of the implementation matches the design specification\n    in the docstrings will be performed.\n\n    raises:\n        NoEntryNode: If the starting node is not an entry-node.\n        IllegalTransition: If a transition is made to a node that is not an exit-path of the current node.\n        IllegalTransition: If a Success result is sent down an unhappy-path.\n        IllegalTransition: If a Failure result is sent down a happy-path.\n        IllegalTransition: If no transition is provided and the node is not a terminal-node.\n    \"\"\"\n    machine_start_time = datetime.now(UTC)\n    self.logger.info(f\"{self.__class__.__name__.split('.')[-1]} started\")\n\n    # Set the first node to be executed.\n    self._current_node = self.__entry_node__\n\n    # Run until a terminal node is executed.\n    while True:\n        # Record the last node executed.\n        previous_node = self._current_node\n\n        # Execute the current node.\n        node_start_time = datetime.now(UTC)\n        self.logger.debug(\n            f\"{self.__class__.__name__.split('.')[-1]}.{self._current_node.__node_name__} started\"\n        )\n        transition = self._current_node()\n        self.logger.debug(\n            f\"{self.__class__.__name__.split('.')[-1]}.{self._current_node.__node_name__} completed runtime: {datetime.now(UTC) - node_start_time}\"\n        )\n\n        # Confirm the node returned a Transition.\n        if __debug__ and not isinstance(transition, Transition):\n            raise IllegalTransitionError(\n                f\"{self._current_node} did not return a Transition: instead returned {type(transition)}\"\n            )\n\n        # Exit machine if the node is terminal.\n        if isinstance(transition, Exit):\n            if self._current_node.__exits__:\n                raise NotTerminalNodeError(\n                    f\"{self.node_name} returned Exit but is not a terminal node.\"\n                )\n            else:\n                self.results.append(transition.result)\n                break\n\n        self._current_node = transition.exit_to\n\n        # Can the transition be made?\n        if (\n            __debug__\n            and previous_node\n            and self._current_node.__node_name__ not in previous_node.__exits__\n        ):\n            raise IllegalTransitionError(\n                f\"{previous_node.__node_name__} cannot transition to {self._current_node.__node_name__}\"\n            )\n\n        # Is a Failure being sent down a happy path?\n        if (\n            __debug__\n            and isinstance(transition.result, Failure)\n            and previous_node\n            and self._current_node.__node_name__\n            not in previous_node.__unhappy_paths__\n        ):\n            raise IllegalTransitionError(\n                f\"{previous_node.__node_name__} made an unhappy transition on the happy path to {self._current_node.__node_name__}\"\n            )\n\n        # Is a Success being sent down an unhappy path?\n        if (\n            __debug__\n            and isinstance(transition.result, Success)\n            and previous_node\n            and self._current_node.__node_name__\n            not in previous_node.__happy_paths__\n        ):\n            raise IllegalTransitionError(\n                f\"{previous_node.__node_name__} made an happy transition on the unhappy path to {self._current_node.__node_name__}\"\n            )\n\n        self.results.append(transition.result)\n\n    machine_end_time = datetime.now(UTC)\n    machine_run_time = machine_end_time - machine_start_time\n    self.logger.info(\n        f\"{self.__class__.__name__.split('.')[-1]} completed runtime: {machine_run_time}\"\n    )\n\n    return self.results\n</code></pre>"},{"location":"source_code/state_machine/abstract_machine.html#state_machine.abstract_machine.AbstractMachine.exit","title":"exit","text":"<pre><code>exit() -&gt; Transition\n</code></pre> <p>Exits the state-machine.</p> Source code in <code>state_machine/abstract_machine.py</code> <pre><code>def exit(self) -&gt; Transition:\n    \"\"\"\n    Exits the state-machine.\n    \"\"\"\n\n    return Exit(result=self.__Success__(node=self.node_name))\n</code></pre>"},{"location":"source_code/state_machine/abstract_machine.html#state_machine.abstract_machine.AbstractMachine.failure","title":"failure","text":"<pre><code>failure(\n    *, exit_to: Callable[..., Transition], message: str\n) -&gt; Transition\n</code></pre> <p>Returns a failure Transition to exit_to.</p> <p>Raises:</p> Type Description <code>IllegalTransition</code> <p>If exit_to is not a bound method.</p> Source code in <code>state_machine/abstract_machine.py</code> <pre><code>def failure(\n    self,\n    *,\n    exit_to: Callable[..., Transition],\n    message: str,\n) -&gt; Transition:\n    \"\"\"\n    Returns a failure Transition to *exit_to*.\n\n    raises:\n        IllegalTransition: If *exit_to* is not a bound method.\n    \"\"\"\n    if (\n        __debug__\n        and not inspect.ismethod(exit_to)\n        and not hasattr(exit_to, \"__is_node__\")\n    ):\n        raise IllegalTransitionError(f\"failure transition {exit_to} is not a node\")\n\n    self.logger.error(f\"{self.node_name} {self.failure_prefix}  {message}\")\n\n    return Transition(\n        result=Failure(\n            node=self.node_name,\n            message=f\"{self.failure_prefix} {message}\",\n        ),\n        exit_to=exit_to,\n    )\n</code></pre>"},{"location":"source_code/state_machine/abstract_machine.html#state_machine.abstract_machine.AbstractMachine.report_results","title":"report_results","text":"<pre><code>report_results() -&gt; Transition\n</code></pre> overview <p>The final exit node for all state-machines.</p> <p>is_terminal: True</p> Source code in <code>state_machine/abstract_machine.py</code> <pre><code>@no_exceptions\n@node\ndef report_results(self) -&gt; Transition:\n    \"\"\"\n    overview:\n        The final exit node for all state-machines.\n\n    is_terminal: True\n    \"\"\"\n    return self.exit()\n</code></pre>"},{"location":"source_code/state_machine/abstract_machine.html#state_machine.abstract_machine.AbstractMachine.success","title":"success","text":"<pre><code>success(\n    *, exit_to: Callable[..., Transition]\n) -&gt; Transition\n</code></pre> <p>Returns a successful Transition to exit_to.</p> <p>Raises:</p> Type Description <code>-IllegalTransition</code> <p>If exit_to is not a bound method.</p> Source code in <code>state_machine/abstract_machine.py</code> <pre><code>def success(self, *, exit_to: Callable[..., Transition]) -&gt; Transition:\n    \"\"\"\n    Returns a successful Transition to *exit_to*.\n\n    raises:\n        - IllegalTransition: If *exit_to* is not a bound method.\n    \"\"\"\n    if (\n        __debug__\n        and not inspect.ismethod(exit_to)\n        and not hasattr(exit_to, \"__is_node__\")\n    ):\n        raise IllegalTransitionError(f\"success transition {exit_to} is not a node\")\n\n    return Transition(result=self.__Success__(node=self.node_name), exit_to=exit_to)\n</code></pre>"},{"location":"source_code/state_machine/abstract_machine.html#state_machine.abstract_machine.AbstractMachine.validate","title":"validate  <code>classmethod</code>","text":"<pre><code>validate()\n</code></pre> <p>Performs validation that the design documentation outlined in the docstrings for the nodes are self-consistent.</p> Validations <ul> <li>Has an entry-node.</li> <li>Terminal-nodes don't have an exit path.</li> <li>All node methods are reachable.</li> <li>All paths have an implementing node method.</li> <li>Exception handlers route to a failure path.</li> <li>Exception handling is specified for all nodes.</li> </ul> <p>Raises:</p> Type Description <code>NoEntryNode</code> <p>If the machine has no entry nodes defined.</p> <code>NoTerminalNode</code> <p>If the machine has no terminal nodes defined.</p> <code>UndefinedNode</code> <p>If the design spec references a node that has no implementation.</p> <code>UnreachableNode</code> <p>If a node is implemented that is not in the design spec.</p> <code>NotTerminalNode</code> <p>If a terminal node has exit paths in the design spec.</p> <code>NoExceptionHandling</code> <p>If a node does not have a decorator specifying whether it should have exception handling.</p> <code>IllegalTransition</code> <p>If an exception path is not an unhappy path for the node.</p> Source code in <code>state_machine/abstract_machine.py</code> <pre><code>@classmethod\ndef validate(cls):\n    \"\"\"\n    Performs validation that the design documentation outlined in the docstrings for the\n    nodes are self-consistent.\n\n    Validations:\n        - Has an entry-node.\n        - Terminal-nodes don't have an exit path.\n        - All node methods are reachable.\n        - All paths have an implementing node method.\n        - Exception handlers route to a failure path.\n        - Exception handling is specified for all nodes.\n\n    raises:\n        NoEntryNode: If the machine has no entry nodes defined.\n        NoTerminalNode: If the machine has no terminal nodes defined.\n        UndefinedNode: If the design spec references a node that has no implementation.\n        UnreachableNode: If a node is implemented that is not in the design spec.\n        NotTerminalNode: If a terminal node has exit paths in the design spec.\n        NoExceptionHandling: If a node does not have a decorator specifying whether it should have exception handling.\n        IllegalTransition: If an exception path is not an unhappy path for the node.\n    \"\"\"\n    # confirm at least one entry node is defined\n    if not cls.__entry_nodes__:\n        raise NoEntryNodeError(f\"No entry nodes {cls.__module__}\")\n\n    # Confirm there is only one entry node.\n    if len(cls.__entry_nodes__) &gt; 1:\n        raise MultipleEntryNodeError(\n            f\"More than one entry node defined: {cls.__named_entry_nodes__}\"\n        )\n\n    cls.__entry_node__ = cls.__entry_nodes__[0]\n\n    # confirm at least one terminal node is defined\n    if not cls.__terminal_nodes__:\n        raise NoTerminalNodeError(f\"No terminal nodes {cls.__module__}\")\n\n    # collect the definitions of all of the nodes\n    all_nodes = cls.__entry_nodes__ + cls.__nodes__ + cls.__terminal_nodes__\n\n    # compile a list of all of the exit paths\n    exits = []\n    for node in all_nodes:\n        for method_name in node.__exits__:\n            if not hasattr(cls, method_name):\n                raise UndefinedNodeError(\n                    f\"{cls.__module__}.{node.__node_name__} references undefined: {method_name}\"\n                )\n            else:\n                method = getattr(cls, method_name)\n                exits.append(method.__node_name__)\n\n    # check exception handling specifications\n    for node in all_nodes:\n        if not hasattr(node, \"__has_exception_handling__\"):\n            raise NoExceptionHandlingError(\n                f\"Node {cls.__module__}.{node.__node_name__} has neither @handle_exceptions nor @no_exceptions\"\n            )\n        elif (\n            node.__has_exception_handling__\n            and node.__on_exception__ not in node.__unhappy_paths__\n        ):\n            raise IllegalTransitionError(\n                f\"{cls.__module__}.{node.__node_name__} exception handler not an allowable exit: {node.__on_exception__}\"\n            )\n\n    for node in all_nodes:\n        # confirm all of the nodes in the machine have a path that reaches them\n        if not node.__is_entry__ and node.__node_name__ not in exits:\n            raise UnreachableNodeError(\n                f\"Unreachable node: {cls.__module__}.{node.__node_name__}\"\n            )\n\n        # confirm the terminal nodes have no exit paths\n        if node.__is_terminal__ and node.__exits__:\n            raise NotTerminalNodeError(\n                f\"Node {cls.__module__}.{node.__node_name__} not terminal\"\n            )\n</code></pre>"},{"location":"source_code/state_machine/abstract_repository.html","title":"abstract_repository","text":""},{"location":"source_code/state_machine/abstract_repository.html#state_machine.abstract_repository.AbstractRepository","title":"AbstractRepository","text":"<p>Abstract base class for repositories.</p> <p>logger will be injected when accessing a repository action from a Dependency set of repositories for a machine.</p> Source code in <code>state_machine/abstract_repository.py</code> <pre><code>class AbstractRepository:\n    \"\"\"\n    Abstract base class for repositories.\n\n    *logger* will be injected when accessing a repository action from a Dependency set of repositories for a machine.\n    \"\"\"\n\n    logger: Logger\n\n    @classmethod\n    def execute(cls) -&gt; Any:\n        \"\"\"\n        Needs to be overriden in subclasses.  All actions taken by a repository should be executed in this method as\n        this is the assumed mocking point for unit tests.\n        \"\"\"\n        raise NotImplementedError()\n</code></pre>"},{"location":"source_code/state_machine/abstract_repository.html#state_machine.abstract_repository.AbstractRepository.execute","title":"execute  <code>classmethod</code>","text":"<pre><code>execute() -&gt; Any\n</code></pre> <p>Needs to be overriden in subclasses.  All actions taken by a repository should be executed in this method as this is the assumed mocking point for unit tests.</p> Source code in <code>state_machine/abstract_repository.py</code> <pre><code>@classmethod\ndef execute(cls) -&gt; Any:\n    \"\"\"\n    Needs to be overriden in subclasses.  All actions taken by a repository should be executed in this method as\n    this is the assumed mocking point for unit tests.\n    \"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"source_code/state_machine/base_dependency.html","title":"base_dependency","text":""},{"location":"source_code/state_machine/base_dependency.html#state_machine.base_dependency.BaseDependency","title":"BaseDependency  <code>dataclass</code>","text":"<p>Base class for representing repository dependencies used by machines.</p> Source code in <code>state_machine/base_dependency.py</code> <pre><code>@dataclass\nclass BaseDependency:\n    \"\"\"\n    Base class for representing repository dependencies used by machines.\n    \"\"\"\n\n    logger: Logger\n    \"\"\"Access to the logger.\"\"\"\n\n    def __getattribute__(self, name: str) -&gt; Any:\n        \"\"\"\n        Provides introspective magic to inject the logger into a repository at the time\n        at the time the repository is accessed.\n        \"\"\"\n        attribute = super().__getattribute__(name)\n        if hasattr(attribute, \"__self__\") and issubclass(\n            attribute.__self__, AbstractRepository\n        ):\n            attribute.__self__.logger = self.logger\n\n        return attribute\n</code></pre>"},{"location":"source_code/state_machine/base_dependency.html#state_machine.base_dependency.BaseDependency.logger","title":"logger  <code>instance-attribute</code>","text":"<pre><code>logger: state_machine.logger.Logger\n</code></pre> <p>Access to the logger.</p>"},{"location":"source_code/state_machine/base_dependency.html#state_machine.base_dependency.BaseDependency.__getattribute__","title":"__getattribute__","text":"<pre><code>__getattribute__(name: str) -&gt; Any\n</code></pre> <p>Provides introspective magic to inject the logger into a repository at the time at the time the repository is accessed.</p> Source code in <code>state_machine/base_dependency.py</code> <pre><code>def __getattribute__(self, name: str) -&gt; Any:\n    \"\"\"\n    Provides introspective magic to inject the logger into a repository at the time\n    at the time the repository is accessed.\n    \"\"\"\n    attribute = super().__getattribute__(name)\n    if hasattr(attribute, \"__self__\") and issubclass(\n        attribute.__self__, AbstractRepository\n    ):\n        attribute.__self__.logger = self.logger\n\n    return attribute\n</code></pre>"},{"location":"source_code/state_machine/base_state.html","title":"base_state","text":""},{"location":"source_code/state_machine/base_state.html#state_machine.base_state.BaseState","title":"BaseState","text":"<p>             Bases: <code>pydantic.BaseModel</code></p> <p>The base class for keeping track of the data state within a machine.</p> Source code in <code>state_machine/base_state.py</code> <pre><code>class BaseState(BaseModel):\n    \"\"\"The base class for keeping track of the data state within a machine.\"\"\"\n\n    model_config = ConfigDict(arbitrary_types_allowed=True)\n</code></pre>"},{"location":"source_code/state_machine/logger.html","title":"logger","text":""},{"location":"source_code/state_machine/logger.html#state_machine.logger.Logger","title":"Logger","text":"<p>Wraps standard Python logging with configuration pulled from the provided config file.</p> Source code in <code>state_machine/logger.py</code> <pre><code>class Logger:\n    \"\"\"\n    Wraps standard Python logging with configuration pulled from the provided config file.\n    \"\"\"\n\n    def __init__(self, *, file_name: str):\n        log_formatter = logging.Formatter(master_config.logging.format)\n        file_handler = logging.handlers.TimedRotatingFileHandler(\n            f\"{master_config.logging.path}/{file_name}.log\",\n            when=master_config.logging.rotation,\n            backupCount=master_config.logging.backup_count,\n        )\n        file_handler.setFormatter(log_formatter)\n\n        self._logger = logging.getLogger(__name__)\n        self._logger.addHandler(file_handler)\n\n        if master_config.logging.level.lower() == \"debug\":\n            self._logger.setLevel(logging.DEBUG)\n        elif master_config.logging.level.lower() == \"warning\":\n            self._logger.setLevel(logging.WARNING)\n        elif master_config.logging.level.lower() == \"error\":\n            self._logger.setLevel(logging.ERROR)\n        elif master_config.logging.level.lower() == \"critical\":\n            self._logger.setLevel(logging.CRITICAL)\n        else:\n            self._logger.setLevel(logging.INFO)\n\n        if master_config.logging.include_terminal:\n            console_handler = logging.StreamHandler()\n            console_handler.setFormatter(log_formatter)\n            self._logger.addHandler(console_handler)\n\n    def critical(self, message: str):\n        \"\"\"\n        Log a critical level message.\n        \"\"\"\n        self._logger.critical(message)\n\n    def debug(self, message: str):\n        \"\"\"\n        Log a debug level message.\n        \"\"\"\n        self._logger.debug(message)\n\n    def error(self, message: str):\n        \"\"\"\n        Log a error level message.\n        \"\"\"\n        self._logger.error(message)\n\n    def info(self, message: str):\n        \"\"\"\n        Log a info level message.\n        \"\"\"\n        self._logger.info(message)\n\n    def warning(self, message: str):\n        \"\"\"\n        Log a warning level message.\n        \"\"\"\n        self._logger.warning(message)\n</code></pre>"},{"location":"source_code/state_machine/logger.html#state_machine.logger.Logger.critical","title":"critical","text":"<pre><code>critical(message: str)\n</code></pre> <p>Log a critical level message.</p> Source code in <code>state_machine/logger.py</code> <pre><code>def critical(self, message: str):\n    \"\"\"\n    Log a critical level message.\n    \"\"\"\n    self._logger.critical(message)\n</code></pre>"},{"location":"source_code/state_machine/logger.html#state_machine.logger.Logger.debug","title":"debug","text":"<pre><code>debug(message: str)\n</code></pre> <p>Log a debug level message.</p> Source code in <code>state_machine/logger.py</code> <pre><code>def debug(self, message: str):\n    \"\"\"\n    Log a debug level message.\n    \"\"\"\n    self._logger.debug(message)\n</code></pre>"},{"location":"source_code/state_machine/logger.html#state_machine.logger.Logger.error","title":"error","text":"<pre><code>error(message: str)\n</code></pre> <p>Log a error level message.</p> Source code in <code>state_machine/logger.py</code> <pre><code>def error(self, message: str):\n    \"\"\"\n    Log a error level message.\n    \"\"\"\n    self._logger.error(message)\n</code></pre>"},{"location":"source_code/state_machine/logger.html#state_machine.logger.Logger.info","title":"info","text":"<pre><code>info(message: str)\n</code></pre> <p>Log a info level message.</p> Source code in <code>state_machine/logger.py</code> <pre><code>def info(self, message: str):\n    \"\"\"\n    Log a info level message.\n    \"\"\"\n    self._logger.info(message)\n</code></pre>"},{"location":"source_code/state_machine/logger.html#state_machine.logger.Logger.warning","title":"warning","text":"<pre><code>warning(message: str)\n</code></pre> <p>Log a warning level message.</p> Source code in <code>state_machine/logger.py</code> <pre><code>def warning(self, message: str):\n    \"\"\"\n    Log a warning level message.\n    \"\"\"\n    self._logger.warning(message)\n</code></pre>"},{"location":"source_code/state_machine/logger_model.html","title":"logger_model","text":""},{"location":"source_code/state_machine/logger_model.html#state_machine.logger_model.LoggerModel","title":"LoggerModel","text":"<p>             Bases: <code>pydantic.BaseModel</code></p> <p>Configurations in the Master Config file.</p> Source code in <code>state_machine/logger_model.py</code> <pre><code>class LoggerModel(BaseModel):\n    \"\"\"Configurations in the Master Config file.\"\"\"\n\n    @classmethod\n    def from_config(cls, *, config: Config):\n        master_config = {}\n        for config_item in cls.model_fields:\n            master_config[config_item] = config[config_item].as_dict()\n\n        return cls(**master_config)\n\n    logging: Logging\n    \"\"\"Configuration for logging.\"\"\"\n</code></pre>"},{"location":"source_code/state_machine/logger_model.html#state_machine.logger_model.LoggerModel.logging","title":"logging  <code>instance-attribute</code>","text":"<pre><code>logging: state_machine.logger_model.Logging\n</code></pre> <p>Configuration for logging.</p>"},{"location":"source_code/state_machine/logger_model.html#state_machine.logger_model.Logging","title":"Logging","text":"<p>             Bases: <code>pydantic.BaseModel</code></p> <p>Configurations for logging.</p> Source code in <code>state_machine/logger_model.py</code> <pre><code>class Logging(BaseModel):\n    \"\"\"Configurations for logging.\"\"\"\n\n    level: str\n    \"\"\"The log level.\"\"\"\n\n    format: str\n    \"\"\"The line format of the log entries.\"\"\"\n\n    include_terminal: bool\n    \"\"\"Indicates whether log output should display in the executing shell.\"\"\"\n\n    rotation: str\n    \"\"\"The frequency for rotating the log files.\"\"\"\n\n    backup_count: int\n    \"\"\"The number of log rotations to keep prior to deleting them.\"\"\"\n\n    path: str\n    \"\"\"The path to the location the logs are stored.\"\"\"\n</code></pre>"},{"location":"source_code/state_machine/logger_model.html#state_machine.logger_model.Logging.backup_count","title":"backup_count  <code>instance-attribute</code>","text":"<pre><code>backup_count: int\n</code></pre> <p>The number of log rotations to keep prior to deleting them.</p>"},{"location":"source_code/state_machine/logger_model.html#state_machine.logger_model.Logging.format","title":"format  <code>instance-attribute</code>","text":"<pre><code>format: str\n</code></pre> <p>The line format of the log entries.</p>"},{"location":"source_code/state_machine/logger_model.html#state_machine.logger_model.Logging.include_terminal","title":"include_terminal  <code>instance-attribute</code>","text":"<pre><code>include_terminal: bool\n</code></pre> <p>Indicates whether log output should display in the executing shell.</p>"},{"location":"source_code/state_machine/logger_model.html#state_machine.logger_model.Logging.level","title":"level  <code>instance-attribute</code>","text":"<pre><code>level: str\n</code></pre> <p>The log level.</p>"},{"location":"source_code/state_machine/logger_model.html#state_machine.logger_model.Logging.path","title":"path  <code>instance-attribute</code>","text":"<pre><code>path: str\n</code></pre> <p>The path to the location the logs are stored.</p>"},{"location":"source_code/state_machine/logger_model.html#state_machine.logger_model.Logging.rotation","title":"rotation  <code>instance-attribute</code>","text":"<pre><code>rotation: str\n</code></pre> <p>The frequency for rotating the log files.</p>"},{"location":"source_code/state_machine/result.html","title":"result","text":""},{"location":"source_code/state_machine/result.html#state_machine.result.Failure","title":"Failure","text":"<p>             Bases: <code>state_machine.result.Result</code></p> <p>Base class for a failing outcome.</p> Source code in <code>state_machine/result.py</code> <pre><code>class Failure(Result):\n    \"\"\"\n    Base class for a failing outcome.\n    \"\"\"\n\n    message: str = Field(frozen=True)\n    \"\"\"The reason for the failure.\"\"\"\n</code></pre>"},{"location":"source_code/state_machine/result.html#state_machine.result.Failure.message","title":"message  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>message: str = pydantic.Field(frozen=True)\n</code></pre> <p>The reason for the failure.</p>"},{"location":"source_code/state_machine/result.html#state_machine.result.Result","title":"Result","text":"<p>             Bases: <code>pydantic.BaseModel</code></p> <p>Base class for the results.</p> Source code in <code>state_machine/result.py</code> <pre><code>class Result(BaseModel):\n    \"\"\"\n    Base class for the results.\n    \"\"\"\n\n    node: str = Field(frozen=True)\n    \"\"\"The node the result was created in.\"\"\"\n</code></pre>"},{"location":"source_code/state_machine/result.html#state_machine.result.Result.node","title":"node  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>node: str = pydantic.Field(frozen=True)\n</code></pre> <p>The node the result was created in.</p>"},{"location":"source_code/state_machine/result.html#state_machine.result.Success","title":"Success","text":"<p>             Bases: <code>state_machine.result.Result</code></p> <p>Base class for a successful outcome.</p> Source code in <code>state_machine/result.py</code> <pre><code>class Success(Result):\n    \"\"\"\n    Base class for a successful outcome.\n    \"\"\"\n</code></pre>"},{"location":"source_code/state_machine/transition.html","title":"transition","text":""},{"location":"source_code/state_machine/transition.html#state_machine.transition.Exit","title":"Exit","text":"<p>             Bases: <code>state_machine.transition.Transition</code></p> <p>The expected return type of a terminal node.  result and exit will be ignored.</p> Source code in <code>state_machine/transition.py</code> <pre><code>class Exit(Transition):\n    \"\"\"The expected return type of a terminal node.  *result* and *exit* will be ignored.\"\"\"\n\n    result: Result = Field(frozen=True)\n    \"\"\"The result of the node's actions.\"\"\"\n\n    exit_to: Optional[Callable[..., \"Transition\"]] = Field(default=None, frozen=True) # type: ignore\n    \"\"\"The next node to be executed.\"\"\"\n</code></pre>"},{"location":"source_code/state_machine/transition.html#state_machine.transition.Exit.exit_to","title":"exit_to  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>exit_to: typing.Optional[\n    typing.Callable[\n        ..., state_machine.transition.Transition\n    ]\n] = pydantic.Field(default=None, frozen=True)\n</code></pre> <p>The next node to be executed.</p>"},{"location":"source_code/state_machine/transition.html#state_machine.transition.Exit.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: state_machine.result.Result = pydantic.Field(\n    frozen=True\n)\n</code></pre> <p>The result of the node's actions.</p>"},{"location":"source_code/state_machine/transition.html#state_machine.transition.Transition","title":"Transition","text":"<p>             Bases: <code>pydantic.BaseModel</code></p> <p>The expected return type from a node.</p> Source code in <code>state_machine/transition.py</code> <pre><code>class Transition(BaseModel):\n    \"\"\"The expected return type from a node.\"\"\"\n\n    result: Result = Field(frozen=True)\n    \"\"\"The result of the node's actions.\"\"\"\n\n    exit_to: Callable[..., \"Transition\"] = Field(frozen=True)\n    \"\"\"The next node to be executed.\"\"\"\n</code></pre>"},{"location":"source_code/state_machine/transition.html#state_machine.transition.Transition.exit_to","title":"exit_to  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>exit_to: typing.Callable[\n    ..., state_machine.transition.Transition\n] = pydantic.Field(frozen=True)\n</code></pre> <p>The next node to be executed.</p>"},{"location":"source_code/state_machine/transition.html#state_machine.transition.Transition.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: state_machine.result.Result = pydantic.Field(\n    frozen=True\n)\n</code></pre> <p>The result of the node's actions.</p>"},{"location":"source_code/state_machine/config/attribute_dict.html","title":"attribute_dict","text":""},{"location":"source_code/state_machine/config/attribute_dict.html#state_machine.config.attribute_dict.AttributeDict","title":"AttributeDict","text":"<p>Nestable key-value pairs that are accessible as either attributes or key-indexes (like a javacript object).</p> Source code in <code>state_machine/config/attribute_dict.py</code> <pre><code>class AttributeDict:\n    \"\"\"\n    Nestable key-value pairs that are accessible as either attributes or key-indexes (like a javacript object).\n    \"\"\"\n\n    def __init__(self, init_value: Optional[dict] = None):\n        self._attributes = {}\n        if init_value is not None:\n            for name, value in init_value.items():\n                self.add_attribute(name, value)\n\n    def add_attribute(self, name: str, value: Any):\n        \"\"\"\n        Add attributes.\n        \"\"\"\n        if isinstance(value, dict):\n            self._attributes[name] = AttributeDict(value)\n        else:\n            self._attributes[name] = value\n\n    def as_dict(self) -&gt; dict:\n        \"\"\"\n        Converts the attribute structure to a dictionary.\n        \"\"\"\n        ret = {}\n        for name, value in self._attributes.items():\n            if isinstance(value, AttributeDict):\n                ret[name] = value.as_dict()\n            else:\n                ret[name] = value\n\n        return ret\n\n    def __contains__(self, name: str):\n        return name in self._attributes\n\n    def __getattribute__(self, name: str) -&gt; Any:\n        if (\n            name != \"_attributes\"\n            and hasattr(self, \"_attributes\")\n            and name in self._attributes\n        ):\n            return self._attributes[name]\n        else:\n            return super().__getattribute__(name)\n\n    def __getitem__(self, name: str):\n        return self._attributes[name]\n\n    def __setitem__(self, name: str, value: Any):\n        self.add_attribute(name, value)\n</code></pre>"},{"location":"source_code/state_machine/config/attribute_dict.html#state_machine.config.attribute_dict.AttributeDict.add_attribute","title":"add_attribute","text":"<pre><code>add_attribute(name: str, value: Any)\n</code></pre> <p>Add attributes.</p> Source code in <code>state_machine/config/attribute_dict.py</code> <pre><code>def add_attribute(self, name: str, value: Any):\n    \"\"\"\n    Add attributes.\n    \"\"\"\n    if isinstance(value, dict):\n        self._attributes[name] = AttributeDict(value)\n    else:\n        self._attributes[name] = value\n</code></pre>"},{"location":"source_code/state_machine/config/attribute_dict.html#state_machine.config.attribute_dict.AttributeDict.as_dict","title":"as_dict","text":"<pre><code>as_dict() -&gt; dict\n</code></pre> <p>Converts the attribute structure to a dictionary.</p> Source code in <code>state_machine/config/attribute_dict.py</code> <pre><code>def as_dict(self) -&gt; dict:\n    \"\"\"\n    Converts the attribute structure to a dictionary.\n    \"\"\"\n    ret = {}\n    for name, value in self._attributes.items():\n        if isinstance(value, AttributeDict):\n            ret[name] = value.as_dict()\n        else:\n            ret[name] = value\n\n    return ret\n</code></pre>"},{"location":"source_code/state_machine/config/config.html","title":"config","text":""},{"location":"source_code/state_machine/config/config.html#state_machine.config.config.Config","title":"Config","text":"<p>             Bases: <code>state_machine.config.attribute_dict.AttributeDict</code></p> <p>Persists configuration definitions.  Defaults to a config.yaml files in the projects folder.  It will recursively search up the folders and use the first config.yaml file it finds in the folder structure.</p> <p>Encrypted secrets are stored in a separate secrets.yaml file.</p> Source code in <code>state_machine/config/config.py</code> <pre><code>class Config(AttributeDict):\n    \"\"\"\n    Persists configuration definitions.  Defaults to a config.yaml files in the projects folder.  It will\n    recursively search up the folders and use the first config.yaml file it finds in the folder structure.\n\n    Encrypted secrets are stored in a separate secrets.yaml file.\n    \"\"\"\n\n    filename = \"config.yaml\"\n\n    @classmethod\n    def config_file(cls, config_project_path: str = \"\") -&gt; str:\n        \"\"\"\n        Walks up the folder structure searching for the requested config.yaml file.\n        Will create the file if it does not exists.\n        \"\"\"\n        config_path = os.path.join(\"./\", config_project_path)\n        config_filename = os.path.join(config_path, cls.filename)\n\n        if os.path.exists(config_filename):\n            return config_filename\n        elif config_project_path == \"\" and config_path == \"./\":\n            with open(config_filename, \"w\"):\n                pass\n            return config_filename\n        elif config_project_path == \"\":\n            return cls.config_file(os.path.split(config_path)[0])\n        else:\n            with open(config_filename, \"w\"):\n                pass\n            return config_filename\n\n    def __init__(self, config_path: Union[dict, str] = \"\"):\n        if isinstance(config_path, str) and not config_path:\n            yaml = YAML()\n            self._config_filename = self.config_file(config_path)\n            with open(self._config_filename, \"r\") as file_in:\n                configurations = yaml.load(file_in)\n        elif isinstance(config_path, str):\n            yaml = YAML()\n            self._config_filename = config_path\n            with open(self._config_filename, \"r\") as file_in:\n                configurations = yaml.load(file_in)\n        else:\n            configurations = config_path\n\n        if configurations is None:\n            configurations = {}\n\n        super().__init__(configurations)\n\n        if isinstance(config_path, str):\n            self._secrets = Secrets(config_path)\n        else:\n            self._secrets = Secrets()\n\n    def set(self, section: str, key: str, value: str):\n        \"\"\"\n        Adds or overwrites a configuration value.\n        \"\"\"\n        if section in self:\n            self[section].add_attribute(key, value)\n        else:\n            self.add_attribute(section, {key: value})\n\n        with open(self._config_filename, \"w\") as file_out:\n            yaml = YAML()\n            yaml.dump(self.as_dict(), file_out)\n\n    @property\n    def from_file(self) -&gt; str:\n        \"\"\"\n        The config.yaml file the configurations were loaded from.\n        \"\"\"\n        return self._config_filename\n\n    @property\n    def secrets(self) -&gt; Secrets:\n        \"\"\"\n        Access to the encrypted secrets.\n        \"\"\"\n        return self._secrets\n</code></pre>"},{"location":"source_code/state_machine/config/config.html#state_machine.config.config.Config.from_file","title":"from_file  <code>property</code>","text":"<pre><code>from_file: str\n</code></pre> <p>The config.yaml file the configurations were loaded from.</p>"},{"location":"source_code/state_machine/config/config.html#state_machine.config.config.Config.secrets","title":"secrets  <code>property</code>","text":"<pre><code>secrets: state_machine.config.secrets.Secrets\n</code></pre> <p>Access to the encrypted secrets.</p>"},{"location":"source_code/state_machine/config/config.html#state_machine.config.config.Config.config_file","title":"config_file  <code>classmethod</code>","text":"<pre><code>config_file(config_project_path: str = '') -&gt; str\n</code></pre> <p>Walks up the folder structure searching for the requested config.yaml file. Will create the file if it does not exists.</p> Source code in <code>state_machine/config/config.py</code> <pre><code>@classmethod\ndef config_file(cls, config_project_path: str = \"\") -&gt; str:\n    \"\"\"\n    Walks up the folder structure searching for the requested config.yaml file.\n    Will create the file if it does not exists.\n    \"\"\"\n    config_path = os.path.join(\"./\", config_project_path)\n    config_filename = os.path.join(config_path, cls.filename)\n\n    if os.path.exists(config_filename):\n        return config_filename\n    elif config_project_path == \"\" and config_path == \"./\":\n        with open(config_filename, \"w\"):\n            pass\n        return config_filename\n    elif config_project_path == \"\":\n        return cls.config_file(os.path.split(config_path)[0])\n    else:\n        with open(config_filename, \"w\"):\n            pass\n        return config_filename\n</code></pre>"},{"location":"source_code/state_machine/config/config.html#state_machine.config.config.Config.set","title":"set","text":"<pre><code>set(section: str, key: str, value: str)\n</code></pre> <p>Adds or overwrites a configuration value.</p> Source code in <code>state_machine/config/config.py</code> <pre><code>def set(self, section: str, key: str, value: str):\n    \"\"\"\n    Adds or overwrites a configuration value.\n    \"\"\"\n    if section in self:\n        self[section].add_attribute(key, value)\n    else:\n        self.add_attribute(section, {key: value})\n\n    with open(self._config_filename, \"w\") as file_out:\n        yaml = YAML()\n        yaml.dump(self.as_dict(), file_out)\n</code></pre>"},{"location":"source_code/state_machine/config/encrypted_attribute_dict.html","title":"encrypted_attribute_dict","text":""},{"location":"source_code/state_machine/config/encrypted_attribute_dict.html#state_machine.config.encrypted_attribute_dict.EncryptedAttributeDict","title":"EncryptedAttributeDict","text":"<p>Encrypted, nestable key-value pairs that are accessible as either attributes or key-indexes (like a javacript object).</p> Source code in <code>state_machine/config/encrypted_attribute_dict.py</code> <pre><code>class EncryptedAttributeDict:\n    \"\"\"\n    Encrypted, nestable key-value pairs that are accessible as either attributes or key-indexes (like a javacript object).\n    \"\"\"\n\n    FERNET_KEY = None\n\n    def __init__(self, init_value: Optional[dict] = None):\n        self._attributes = {}\n        if init_value is not None:\n            for name, value in init_value.items():\n                self.add_attribute(name, value)\n\n    def add_attribute(self, name: str, value: Any):\n        \"\"\"\n        Add attributes.\n\n        :param name: The name of the attribute.\n        :param value: Either a scalar value or a dictionary. Scalar values will be encrypted.\n        \"\"\"\n        if isinstance(value, dict):\n            self._attributes[name] = EncryptedAttributeDict(value)\n        else:\n            self._attributes[name] = self.encrypt(value)\n\n    def as_dict(self) -&gt; dict:\n        \"\"\"\n        Converts the attribute structure to a dictionary containing the encrypted values.\n        \"\"\"\n        ret = {}\n        for name, value in self._attributes.items():\n            if isinstance(value, EncryptedAttributeDict):\n                ret[name] = value.as_dict()\n            else:\n                ret[name] = value\n\n        return ret\n\n    def decrypt(self, value: Any) -&gt; Any:\n        \"\"\"\n        Returns the unencrypted value.\n        \"\"\"\n        if not isinstance(value, str) or not value.startswith(\":ENC:\"):\n            return value\n\n        value = value[5:]\n\n        fernet = Fernet(self.fernet_key())\n        return fernet.decrypt(value.encode(\"utf-8\")).decode(\"utf-8\")\n\n    def encrypt(self, value: str) -&gt; str:\n        \"\"\"\n        Returns the encrypted value.\n        \"\"\"\n        if value.startswith(\":ENC:\"):\n            return value\n\n        fernet = Fernet(self.fernet_key())\n        return f\":ENC:{fernet.encrypt(value.encode('utf-8')).decode('utf-8')}\"\n\n    def fernet_key(self) -&gt; str:\n        \"\"\"\n        Reads and returns the encryption key.\n        \"\"\"\n        if not self.FERNET_KEY:\n            with open(os.path.join(\"/etc\", \"fernet.key\"), \"r\") as file_in:\n                self.FERNET_KEY = file_in.read()\n        return self.FERNET_KEY\n\n    def __contains__(self, name: str):\n        return name in self._attributes\n\n    def __getattribute__(self, name: str) -&gt; Any:\n        if (\n            name != \"_attributes\"\n            and hasattr(self, \"_attributes\")\n            and name in self._attributes\n        ):\n            return self.decrypt(self._attributes[name])\n        else:\n            return super().__getattribute__(name)\n\n    def __getitem__(self, name: str):\n        return self.decrypt(self._attributes[name])\n\n    def __setitem__(self, name: str, value: Any):\n        self.add_attribute(name, value)\n</code></pre>"},{"location":"source_code/state_machine/config/encrypted_attribute_dict.html#state_machine.config.encrypted_attribute_dict.EncryptedAttributeDict.add_attribute","title":"add_attribute","text":"<pre><code>add_attribute(name: str, value: Any)\n</code></pre> <p>Add attributes.</p> <p>:param name: The name of the attribute. :param value: Either a scalar value or a dictionary. Scalar values will be encrypted.</p> Source code in <code>state_machine/config/encrypted_attribute_dict.py</code> <pre><code>def add_attribute(self, name: str, value: Any):\n    \"\"\"\n    Add attributes.\n\n    :param name: The name of the attribute.\n    :param value: Either a scalar value or a dictionary. Scalar values will be encrypted.\n    \"\"\"\n    if isinstance(value, dict):\n        self._attributes[name] = EncryptedAttributeDict(value)\n    else:\n        self._attributes[name] = self.encrypt(value)\n</code></pre>"},{"location":"source_code/state_machine/config/encrypted_attribute_dict.html#state_machine.config.encrypted_attribute_dict.EncryptedAttributeDict.as_dict","title":"as_dict","text":"<pre><code>as_dict() -&gt; dict\n</code></pre> <p>Converts the attribute structure to a dictionary containing the encrypted values.</p> Source code in <code>state_machine/config/encrypted_attribute_dict.py</code> <pre><code>def as_dict(self) -&gt; dict:\n    \"\"\"\n    Converts the attribute structure to a dictionary containing the encrypted values.\n    \"\"\"\n    ret = {}\n    for name, value in self._attributes.items():\n        if isinstance(value, EncryptedAttributeDict):\n            ret[name] = value.as_dict()\n        else:\n            ret[name] = value\n\n    return ret\n</code></pre>"},{"location":"source_code/state_machine/config/encrypted_attribute_dict.html#state_machine.config.encrypted_attribute_dict.EncryptedAttributeDict.decrypt","title":"decrypt","text":"<pre><code>decrypt(value: Any) -&gt; Any\n</code></pre> <p>Returns the unencrypted value.</p> Source code in <code>state_machine/config/encrypted_attribute_dict.py</code> <pre><code>def decrypt(self, value: Any) -&gt; Any:\n    \"\"\"\n    Returns the unencrypted value.\n    \"\"\"\n    if not isinstance(value, str) or not value.startswith(\":ENC:\"):\n        return value\n\n    value = value[5:]\n\n    fernet = Fernet(self.fernet_key())\n    return fernet.decrypt(value.encode(\"utf-8\")).decode(\"utf-8\")\n</code></pre>"},{"location":"source_code/state_machine/config/encrypted_attribute_dict.html#state_machine.config.encrypted_attribute_dict.EncryptedAttributeDict.encrypt","title":"encrypt","text":"<pre><code>encrypt(value: str) -&gt; str\n</code></pre> <p>Returns the encrypted value.</p> Source code in <code>state_machine/config/encrypted_attribute_dict.py</code> <pre><code>def encrypt(self, value: str) -&gt; str:\n    \"\"\"\n    Returns the encrypted value.\n    \"\"\"\n    if value.startswith(\":ENC:\"):\n        return value\n\n    fernet = Fernet(self.fernet_key())\n    return f\":ENC:{fernet.encrypt(value.encode('utf-8')).decode('utf-8')}\"\n</code></pre>"},{"location":"source_code/state_machine/config/encrypted_attribute_dict.html#state_machine.config.encrypted_attribute_dict.EncryptedAttributeDict.fernet_key","title":"fernet_key","text":"<pre><code>fernet_key() -&gt; str\n</code></pre> <p>Reads and returns the encryption key.</p> Source code in <code>state_machine/config/encrypted_attribute_dict.py</code> <pre><code>def fernet_key(self) -&gt; str:\n    \"\"\"\n    Reads and returns the encryption key.\n    \"\"\"\n    if not self.FERNET_KEY:\n        with open(os.path.join(\"/etc\", \"fernet.key\"), \"r\") as file_in:\n            self.FERNET_KEY = file_in.read()\n    return self.FERNET_KEY\n</code></pre>"},{"location":"source_code/state_machine/config/encryption.html","title":"encryption","text":"<p>Convenience wrappers for performing encryption and decryption actions.</p>"},{"location":"source_code/state_machine/config/encryption.html#state_machine.config.encryption.decrypt","title":"decrypt","text":"<pre><code>decrypt(value: str) -&gt; str\n</code></pre> <p>Decrypt the value.  Assumes a key has been installed in /etc/fernet.key</p> Source code in <code>state_machine/config/encryption.py</code> <pre><code>def decrypt(value: str) -&gt; str:\n    \"\"\"\n    Decrypt the *value*.  Assumes a key has been installed in /etc/fernet.key\n    \"\"\"\n    with open(\"/etc/fernet.key\") as file_in:\n        key = file_in.read()\n\n    fernet = Fernet(bytes(key.encode(\"utf-8\")))\n    return fernet.decrypt(bytes(value.encode(\"utf-8\"))).decode(\"utf-8\")\n</code></pre>"},{"location":"source_code/state_machine/config/encryption.html#state_machine.config.encryption.encrypt","title":"encrypt","text":"<pre><code>encrypt(value: str) -&gt; str\n</code></pre> <p>Encrypt the value.  Assumes a key has been installed in /etc/fernet.key.</p> Source code in <code>state_machine/config/encryption.py</code> <pre><code>def encrypt(value: str) -&gt; str:\n    \"\"\"\n    Encrypt the *value*.  Assumes a key has been installed in /etc/fernet.key.\n    \"\"\"\n    with open(\"/etc/fernet.key\") as file_in:\n        key = file_in.read()\n\n    fernet = Fernet(bytes(key.encode(\"utf-8\")))\n    return fernet.encrypt(bytes(value.encode(\"utf-8\"))).decode(\"utf-8\")\n</code></pre>"},{"location":"source_code/state_machine/config/secrets.html","title":"secrets","text":""},{"location":"source_code/state_machine/config/secrets.html#state_machine.config.secrets.Secrets","title":"Secrets","text":"<p>             Bases: <code>state_machine.config.encrypted_attribute_dict.EncryptedAttributeDict</code></p> <p>Persists encrypted configuration definitions.  Defaults to a secrets.yaml files in the project's folder.  It will recursively search up the folders and use the first secrets.yaml file it finds in the folder structure.</p> Source code in <code>state_machine/config/secrets.py</code> <pre><code>class Secrets(EncryptedAttributeDict):\n    \"\"\"\n    Persists encrypted configuration definitions.  Defaults to a secrets.yaml files in the project's folder.  It will\n    recursively search up the folders and use the first secrets.yaml file it finds in the folder structure.\n    \"\"\"\n\n    filename = \"secrets.yaml\"\n\n    @classmethod\n    def config_file(cls, config_project_path: str = \"\") -&gt; str:\n        \"\"\"\n        Walks up the folder structure searching for the requested secrets.yaml file.\n        Will create the file if it does not exists.\n        \"\"\"\n        config_path = os.path.join(\"./\", config_project_path)\n        config_filename = os.path.join(config_path, cls.filename)\n\n        if os.path.exists(config_filename):\n            return config_filename\n        elif config_path == \"./\":\n            with open(config_filename, \"w\"):\n                pass\n            return config_filename\n        else:\n            return cls.config_file(os.path.split(config_path)[0])\n\n    def __init__(self, config_path: Union[dict, str] = \"\"):\n        \"\"\"\n        :param config_path: When a string is passed in, it's the path to the secrets.yaml file. When a dictionary is passed in, it's the inital structure.\n        \"\"\"\n        yaml = YAML()\n        if isinstance(config_path, str):\n            self._config_filename = self.config_file(config_path)\n            with open(self._config_filename, \"r\") as file_in:\n                configurations = yaml.load(file_in)\n        else:\n            configurations = config_path\n\n        if configurations is None:\n            configurations = {}\n\n        super().__init__(configurations)\n\n    def set(self, section: str, key: str, value: str):\n        \"\"\"\n        Adds or overwrites a secret value.\n        \"\"\"\n        if section in self:\n            self[section].add_attribute(key, value)\n        else:\n            self.add_attribute(section, {key: value})\n\n        with open(self._config_filename, \"w\") as file_out:\n            yaml = YAML()\n            yaml.dump(self.as_dict(), file_out)\n\n    @property\n    def from_file(self) -&gt; str:\n        return self._config_filename\n</code></pre>"},{"location":"source_code/state_machine/config/secrets.html#state_machine.config.secrets.Secrets.__init__","title":"__init__","text":"<pre><code>__init__(config_path: Union[dict, str] = '')\n</code></pre> <p>:param config_path: When a string is passed in, it's the path to the secrets.yaml file. When a dictionary is passed in, it's the inital structure.</p> Source code in <code>state_machine/config/secrets.py</code> <pre><code>def __init__(self, config_path: Union[dict, str] = \"\"):\n    \"\"\"\n    :param config_path: When a string is passed in, it's the path to the secrets.yaml file. When a dictionary is passed in, it's the inital structure.\n    \"\"\"\n    yaml = YAML()\n    if isinstance(config_path, str):\n        self._config_filename = self.config_file(config_path)\n        with open(self._config_filename, \"r\") as file_in:\n            configurations = yaml.load(file_in)\n    else:\n        configurations = config_path\n\n    if configurations is None:\n        configurations = {}\n\n    super().__init__(configurations)\n</code></pre>"},{"location":"source_code/state_machine/config/secrets.html#state_machine.config.secrets.Secrets.config_file","title":"config_file  <code>classmethod</code>","text":"<pre><code>config_file(config_project_path: str = '') -&gt; str\n</code></pre> <p>Walks up the folder structure searching for the requested secrets.yaml file. Will create the file if it does not exists.</p> Source code in <code>state_machine/config/secrets.py</code> <pre><code>@classmethod\ndef config_file(cls, config_project_path: str = \"\") -&gt; str:\n    \"\"\"\n    Walks up the folder structure searching for the requested secrets.yaml file.\n    Will create the file if it does not exists.\n    \"\"\"\n    config_path = os.path.join(\"./\", config_project_path)\n    config_filename = os.path.join(config_path, cls.filename)\n\n    if os.path.exists(config_filename):\n        return config_filename\n    elif config_path == \"./\":\n        with open(config_filename, \"w\"):\n            pass\n        return config_filename\n    else:\n        return cls.config_file(os.path.split(config_path)[0])\n</code></pre>"},{"location":"source_code/state_machine/config/secrets.html#state_machine.config.secrets.Secrets.set","title":"set","text":"<pre><code>set(section: str, key: str, value: str)\n</code></pre> <p>Adds or overwrites a secret value.</p> Source code in <code>state_machine/config/secrets.py</code> <pre><code>def set(self, section: str, key: str, value: str):\n    \"\"\"\n    Adds or overwrites a secret value.\n    \"\"\"\n    if section in self:\n        self[section].add_attribute(key, value)\n    else:\n        self.add_attribute(section, {key: value})\n\n    with open(self._config_filename, \"w\") as file_out:\n        yaml = YAML()\n        yaml.dump(self.as_dict(), file_out)\n</code></pre>"},{"location":"source_code/state_machine/decorator/handle_exceptions.html","title":"handle_exceptions","text":""},{"location":"source_code/state_machine/decorator/handle_exceptions.html#state_machine.decorator.handle_exceptions.handle_exceptions","title":"handle_exceptions","text":"<pre><code>handle_exceptions(*, on_exception: str) -&gt; Callable\n</code></pre> <p>Wraps a node that may raise exceptions in a try block with the failure exiting to the node specified in on_exception.</p> <p>Raises:</p> Type Description <code>state_machine.exception.machine.NotANodeError</code> <p>If the function has not been decorated with @node.</p> Source code in <code>state_machine/decorator/handle_exceptions.py</code> <pre><code>def handle_exceptions(*, on_exception: str) -&gt; Callable:\n    \"\"\"\n    Wraps a node that may raise exceptions in a try block with the failure exiting\n    to the node specified in *on_exception*.\n\n    raises:\n        NotANodeError: If the function has not been decorated with @node.\n    \"\"\"\n\n    def wrapper(func: Callable[..., Transition]) -&gt; Callable[..., Transition]:\n        if not hasattr(func, \"__is_node__\"):\n            raise NotANodeError(\n                f\"{func.__module__.split('.')[-1]}.{func.__name__} is not decorated with @node\"\n            )\n\n        def try_(self: Any) -&gt; Transition:\n            try:\n                return func(self)\n            except Exception as exception:\n                exit_to = getattr(self, on_exception)\n                return self.exception(\n                    exit_to=exit_to,\n                    exception=exception,\n                )\n\n        # Copy documentation and validation information to the wrapping function.\n        try_.__node_name__ = func.__node_name__\n        try_.__is_node__ = func.__is_node__\n        try_.__is_entry__ = func.__is_entry__\n        try_.__is_terminal__ = func.__is_terminal__\n        try_.__overview__ = func.__overview__\n        try_.__happy_paths__ = func.__happy_paths__\n        try_.__unhappy_paths__ = func.__unhappy_paths__\n        try_.__exits__ = func.__exits__\n        try_.__invokes_machine__ = func.__invokes_machine__\n        try_.__on_exception__ = on_exception\n        try_.__has_exception_handling__ = True\n\n        return try_\n\n    return wrapper\n</code></pre>"},{"location":"source_code/state_machine/decorator/machine.html","title":"machine","text":""},{"location":"source_code/state_machine/decorator/machine.html#state_machine.decorator.machine.machine","title":"machine","text":"<pre><code>machine(cls: type) -&gt; type\n</code></pre> <p>Compiles meta information and performs a sanity check on a state-machine definition.</p> <p>Raises:</p> Type Description <code>state_machine.exception.documentation.MissingDocStringError</code> <p>If the docstring is not defined.</p> <code>state_machine.exception.documentation.MissingOverviewError</code> <p>If the overview section of the docstring is missing.</p> Source code in <code>state_machine/decorator/machine.py</code> <pre><code>def machine(cls: type) -&gt; type:\n    \"\"\"\n    Compiles meta information and performs a sanity check on a state-machine definition.\n\n    raises:\n        MissingDocStringError: If the docstring is not defined.\n        MissingOverviewError: If the overview section of the docstring is missing.\n    \"\"\"\n\n    # confirm doc string exists\n    if __debug__ and not cls.__doc__:\n        raise MissingDocStringError(f\"Missing doc string {cls.__module__}\")\n\n    # assign the Success type for the machine\n    cls.__Success__ = Success\n\n    # assign the Failure type for the machine\n    cls.__Failure__ = Failure\n\n    # the allowable starting nodes for execution\n    cls.__entry_nodes__ = []\n    cls.__named_entry_nodes__ = []\n\n    # the nodes that represent the end of execution\n    cls.__terminal_nodes__ = []\n    cls.__named_terminal_nodes__ = []\n\n    # the nodes the machine contains\n    cls.__nodes__ = []\n    cls.__named_nodes__ = []\n\n    # the state variables the machine contains\n    cls.__states__ = []\n\n    # extract the specifications from the doc string\n    yaml = YAML()\n    doc = yaml.load(cls.__doc__)\n\n    # general description of what the state-machine does\n    cls.__overview__ = doc.get(\"overview\", \"\")\n    if __debug__ and not cls.__overview__:\n        raise MissingOverviewError(\n            f\"No overview documentation provided for {cls.__name__}\"\n        )\n\n    # get any todo notes\n    cls.__todo__ = doc.get(\"todo\", \"\")\n\n    # compile the distribution of the node methods\n    for method_name, _ in inspect.getmembers(cls):\n        method = getattr(cls, method_name)\n        if hasattr(method, \"__is_node__\"):\n            if method.__is_entry__:\n                cls.__entry_nodes__.append(method)\n                cls.__named_entry_nodes__.append(method.__node_name__)\n            if method.__is_terminal__:\n                cls.__terminal_nodes__.append(method)\n                cls.__named_terminal_nodes__.append(method.__node_name__)\n            if not method.__is_entry__ and not method.__is_terminal__:\n                cls.__nodes__.append(method)\n                cls.__named_nodes__.append(method.__node_name__)\n\n    if __debug__:\n        # perform a sanity check on the state-machine definition\n        cls.validate()\n\n    return cls\n</code></pre>"},{"location":"source_code/state_machine/decorator/no_exceptions.html","title":"no_exceptions","text":""},{"location":"source_code/state_machine/decorator/no_exceptions.html#state_machine.decorator.no_exceptions.no_exceptions","title":"no_exceptions","text":"<pre><code>no_exceptions(func: Callable) -&gt; Callable[..., Transition]\n</code></pre> <p>Indicates the node will not raise exceptions.</p> <p>Raises:</p> Type Description <code>state_machine.exception.machine.NotANodeError</code> <p>If the function has not been decorated with @node.</p> Source code in <code>state_machine/decorator/no_exceptions.py</code> <pre><code>def no_exceptions(func: Callable) -&gt; Callable[..., Transition]:\n    \"\"\"\n    Indicates the node will not raise exceptions.\n\n    raises:\n        NotANodeError: If the function has not been decorated with @node.\n    \"\"\"\n    if not hasattr(func, \"__is_node__\"):\n        raise NotANodeError(\n            f\"{func.__module__.split('.')[-1]}.{func.__name__} is not decorated with @node\"\n        )\n\n    func.__has_exception_handling__ = False\n\n    return func\n</code></pre>"},{"location":"source_code/state_machine/decorator/node.html","title":"node","text":""},{"location":"source_code/state_machine/decorator/node.html#state_machine.decorator.node.node","title":"node","text":"<pre><code>node(\n    func: Callable[..., Transition],\n) -&gt; Callable[..., Transition]\n</code></pre> <p>Provides meta information neccessary for performing sanity checks on state-machine definitions.</p> <p>Raises:</p> Type Description <code>state_machine.exception.documentation.MissingDocStringError</code> <p>If the docstring is missing from the node.</p> <code>state_machine.exception.documentation.MissingOverviewError</code> <p>If the overview section is not present in the docstring.</p> <code>MissingProcessError</code> <p>If the process section is not present in the docstring.</p> Source code in <code>state_machine/decorator/node.py</code> <pre><code>def node(func: Callable[..., Transition]) -&gt; Callable[..., Transition]:\n    \"\"\"\n    Provides meta information neccessary for performing sanity checks on state-machine definitions.\n\n    raises:\n        MissingDocStringError: If the docstring is missing from the node.\n        MissingOverviewError: If the overview section is not present in the docstring.\n        MissingProcessError: If the process section is not present in the docstring.\n    \"\"\"\n\n    # Make sure the name does not override base functionality.\n    reserved_method_names = (\n        \"validate\",\n        \"excetion\",\n        \"exit\",\n        \"failure\",\n        \"execute\",\n        \"success\",\n        \"failure_prefix\",\n        \"logger\",\n        \"master_config\",\n        \"my_config\",\n        \"node_name\",\n        \"state\",\n    )\n    if func.__name__ in reserved_method_names:\n        raise OverrideError(\n            f\"{func.__name__} is a reserved method name and cannot be used as a node name\"\n        )\n\n    # Confirm doc string exists.\n    if not func.__doc__:\n        raise MissingDocStringError(f\"Missing doc string {func.__name__}\")\n\n    # Get the name of the node for convenient future reference.\n    func.__node_name__ = func.__name__\n\n    # Label the method as a node.\n    func.__is_node__ = True\n\n    # Extract the specifications for the node from the doc string.\n    yaml = YAML()\n    doc = yaml.load(func.__doc__)\n\n    # Find out whether the node is an entry node.\n    func.__is_entry__ = doc.get(\"is_entry\", False)\n\n    # Find out whether the node is a terminal node.\n    func.__is_terminal__ = doc.get(\"is_terminal\", False)\n\n    # General description of what the node does.\n    func.__overview__ = doc.get(\"overview\", \"\")\n    if not func.__overview__:\n        raise MissingOverviewError(\n            f\"No overview documentation provided for {func.__name__}\"\n        )\n\n    # Get the happy paths.\n    func.__happy_paths__ = doc.get(\"happy_paths\", [])\n\n    # Get the unhappy paths.\n    func.__unhappy_paths__ = doc.get(\"unhappy_paths\", [])\n\n    # Compile the allowable exits.\n    func.__exits__ = func.__happy_paths__ + func.__unhappy_paths__\n\n    # Record whether the node executes another state-machine.\n    func.__invokes_machine__ = doc.get(\"invokes_machine\", \"\")\n\n    return func\n</code></pre>"},{"location":"source_code/state_machine/exception/documentation.html","title":"documentation","text":""},{"location":"source_code/state_machine/exception/documentation.html#state_machine.exception.documentation.MissingDocStringError","title":"MissingDocStringError","text":"<p>             Bases: <code>Exception</code></p> <p>Raised when a node or machine is missing a docstring.</p> Source code in <code>state_machine/exception/documentation.py</code> <pre><code>class MissingDocStringError(Exception):\n    \"\"\"\n    Raised when a node or machine is missing a docstring.\n    \"\"\"\n</code></pre>"},{"location":"source_code/state_machine/exception/documentation.html#state_machine.exception.documentation.MissingOverviewError","title":"MissingOverviewError","text":"<p>             Bases: <code>Exception</code></p> <p>Raised when a node or machine is missing the overview section in the docstring.</p> Source code in <code>state_machine/exception/documentation.py</code> <pre><code>class MissingOverviewError(Exception):\n    \"\"\"\n    Raised when a node or machine is missing the overview section in the docstring.\n    \"\"\"\n</code></pre>"},{"location":"source_code/state_machine/exception/documentation.html#state_machine.exception.documentation.MissingProcessError","title":"MissingProcessError","text":"<p>             Bases: <code>Exception</code></p> <p>Raised when a node is missing the process section in the docstring.</p> Source code in <code>state_machine/exception/documentation.py</code> <pre><code>class MissingProcessError(Exception):\n    \"\"\"\n    Raised when a node is missing the process section in the docstring.\n    \"\"\"\n</code></pre>"},{"location":"source_code/state_machine/exception/machine.html","title":"machine","text":""},{"location":"source_code/state_machine/exception/machine.html#state_machine.exception.machine.IllegalTransitionError","title":"IllegalTransitionError","text":"<p>             Bases: <code>Exception</code></p> <p>Raised when a node tries to make a transition the design says it shouldn't.</p> Source code in <code>state_machine/exception/machine.py</code> <pre><code>class IllegalTransitionError(Exception):\n    \"\"\"\n    Raised when a node tries to make a transition the design says it shouldn't.\n    \"\"\"\n</code></pre>"},{"location":"source_code/state_machine/exception/machine.html#state_machine.exception.machine.MultipleEntryNodeError","title":"MultipleEntryNodeError","text":"<p>             Bases: <code>Exception</code></p> <p>Raised when a machine has more than one entry-node.</p> Source code in <code>state_machine/exception/machine.py</code> <pre><code>class MultipleEntryNodeError(Exception):\n    \"\"\"\n    Raised when a machine has more than one entry-node.\n    \"\"\"\n</code></pre>"},{"location":"source_code/state_machine/exception/machine.html#state_machine.exception.machine.NoEntryNodeError","title":"NoEntryNodeError","text":"<p>             Bases: <code>Exception</code></p> <p>Raised when a machine has no entry-nodes, or the first node to be executed is not an entry-node.</p> Source code in <code>state_machine/exception/machine.py</code> <pre><code>class NoEntryNodeError(Exception):\n    \"\"\"\n    Raised when a machine has no entry-nodes, or the first node to be executed is not an entry-node.\n    \"\"\"\n</code></pre>"},{"location":"source_code/state_machine/exception/machine.html#state_machine.exception.machine.NoExceptionHandlingError","title":"NoExceptionHandlingError","text":"<p>             Bases: <code>Exception</code></p> <p>Raised when a node is not decorated with either @handle_exceptions or @no_exceptions.</p> Source code in <code>state_machine/exception/machine.py</code> <pre><code>class NoExceptionHandlingError(Exception):\n    \"\"\"\n    Raised when a node is not decorated with either @handle_exceptions or @no_exceptions.\n    \"\"\"\n</code></pre>"},{"location":"source_code/state_machine/exception/machine.html#state_machine.exception.machine.NoTerminalNodeError","title":"NoTerminalNodeError","text":"<p>             Bases: <code>Exception</code></p> <p>Raised when a machine has no terminal-nodes.</p> Source code in <code>state_machine/exception/machine.py</code> <pre><code>class NoTerminalNodeError(Exception):\n    \"\"\"\n    Raised when a machine has no terminal-nodes.\n    \"\"\"\n</code></pre>"},{"location":"source_code/state_machine/exception/machine.html#state_machine.exception.machine.NotANodeError","title":"NotANodeError","text":"<p>             Bases: <code>Exception</code></p> <p>Raised when a method is decorated with @handle_exceptions but not with @node.</p> Source code in <code>state_machine/exception/machine.py</code> <pre><code>class NotANodeError(Exception):\n    \"\"\"\n    Raised when a method is decorated with @handle_exceptions but not with @node.\n    \"\"\"\n</code></pre>"},{"location":"source_code/state_machine/exception/machine.html#state_machine.exception.machine.NotTerminalNodeError","title":"NotTerminalNodeError","text":"<p>             Bases: <code>Exception</code></p> <p>Raised when a node exits with None but is not a terminal-node.</p> Source code in <code>state_machine/exception/machine.py</code> <pre><code>class NotTerminalNodeError(Exception):\n    \"\"\"\n    Raised when a node exits with None but is not a terminal-node.\n    \"\"\"\n</code></pre>"},{"location":"source_code/state_machine/exception/machine.html#state_machine.exception.machine.OverrideError","title":"OverrideError","text":"<p>             Bases: <code>Exception</code></p> <p>Raised when a method name will override functionality in the base class.</p> Source code in <code>state_machine/exception/machine.py</code> <pre><code>class OverrideError(Exception):\n    \"\"\"\n    Raised when a method name will override functionality in the base class.\n    \"\"\"\n</code></pre>"},{"location":"source_code/state_machine/exception/machine.html#state_machine.exception.machine.UndefinedNodeError","title":"UndefinedNodeError","text":"<p>             Bases: <code>Exception</code></p> <p>Raised when a node in the design specification has no implementation.</p> Source code in <code>state_machine/exception/machine.py</code> <pre><code>class UndefinedNodeError(Exception):\n    \"\"\"\n    Raised when a node in the design specification has no implementation.\n    \"\"\"\n</code></pre>"},{"location":"source_code/state_machine/exception/machine.html#state_machine.exception.machine.UnreachableNodeError","title":"UnreachableNodeError","text":"<p>             Bases: <code>Exception</code></p> <p>Raised when a non-entry node is not an exit path for any other nodes.</p> Source code in <code>state_machine/exception/machine.py</code> <pre><code>class UnreachableNodeError(Exception):\n    \"\"\"\n    Raised when a non-entry node is not an exit path for any other nodes.\n    \"\"\"\n</code></pre>"},{"location":"source_code/tests/mocks/mock_logger.html","title":"mock_logger","text":""},{"location":"source_code/tests/mocks/mock_logger.html#tests.mocks.mock_logger.MockLogger","title":"MockLogger","text":"<p>             Bases: <code>state_machine.Logger</code></p> <p>Mocks the logger.</p> Source code in <code>tests/mocks/mock_logger.py</code> <pre><code>class MockLogger(Logger):\n    \"\"\"\n    Mocks the logger.\n    \"\"\"\n\n    def __init__(self):\n        pass\n\n    def critical(self, message: str):\n        pass\n\n    def debug(self, message: str):\n        pass\n\n    def error(self, message: str):\n        pass\n\n    def info(self, message: str):\n        pass\n\n    def warn(self, message: str):\n        pass\n</code></pre>"},{"location":"source_code/tests/test_state_machine/decorator/test_handle_exceptions.html","title":"test_handle_exceptions","text":""},{"location":"source_code/tests/test_state_machine/decorator/test_machine.html","title":"test_machine","text":""},{"location":"source_code/tests/test_state_machine/decorator/test_node.html","title":"test_node","text":""},{"location":"source_code/tests/test_state_machine/machine/test_failure_down_happy_path.html","title":"test_failure_down_happy_path","text":""},{"location":"source_code/tests/test_state_machine/machine/test_happy_path.html","title":"test_happy_path","text":""},{"location":"source_code/tests/test_state_machine/machine/test_illegal_transition.html","title":"test_illegal_transition","text":""},{"location":"source_code/tests/test_state_machine/machine/test_no_transition.html","title":"test_no_transition","text":""},{"location":"source_code/tests/test_state_machine/machine/test_success_down_unhappy_path.html","title":"test_success_down_unhappy_path","text":""}]}